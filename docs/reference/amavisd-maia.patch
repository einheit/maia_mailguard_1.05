*** amavisd-new-2.2.1/amavisd	2007-01-04 20:22:56.000000000 -0800
--- ../amavisd-maia	2007-01-04 21:02:46.000000000 -0800
***************
*** 1,5 ****
--- 1,19 ----
  #!/usr/bin/perl -T
  
+ # This is amavisd-maia, a derivative of amavisd-new that has been modified to
+ # include support for Maia Mailguard.  Maia Mailguard is a set of PHP4 and
+ # Perl scripts designed to offer users the ability to view and modify personal
+ # virus- and spam-checking preferences, whitelists/blacklists, manage their
+ # quarantined files, and report spam effectively.
+ #
+ # Maia Mailguard was written by Robert LeBlanc <rjl@renaissoft.com> 
+ # and David Morton <mortonda@dgrmm.net>, and is
+ # available at http://www.maiamailguard.com/
+ #
+ # $Id: amavisd-maia 1152 2007-01-05 05:37:42Z rjl $
+ 
  #------------------------------------------------------------------------------
+ # What follows here are the comments from amavisd-new 2.2.1:
+ #
  # This is amavisd-new.
  # It is an interface between message transfer agent (MTA) and virus
***************
*** 95,98 ****
--- 109,114 ----
  #  Amavis::SpamControl
  #  Amavis::Unpackers
+ #Maia-related packages: --------------------------------------------------------
+ #  Amavis::Maia
  #------------------------------------------------------------------------------
  
***************
*** 241,245 ****
        $max_servers $max_requests $child_timeout
        %current_policy_bank %policy_bank %interface_policy
!       $unix_socketname $inet_socket_port $inet_socket_bind
        $insert_received_line $relayhost_is_client $smtpd_recipient_limit
        $MAXLEVELS $MAXFILES
--- 257,261 ----
        $max_servers $max_requests $child_timeout
        %current_policy_bank %policy_bank %interface_policy
!       $inet_socket_port $inet_socket_bind
        $insert_received_line $relayhost_is_client $smtpd_recipient_limit
        $MAXLEVELS $MAXFILES
***************
*** 250,256 ****
        $virus_check_negative_ttl $virus_check_positive_ttl
        $spam_check_negative_ttl $spam_check_positive_ttl
!       $enable_ldap $default_ldap
        @keep_decoded_original_maps @map_full_type_to_short_type_maps
        @viruses_that_fake_sender_maps
      )],
      'unpack' => [qw(
--- 266,285 ----
        $virus_check_negative_ttl $virus_check_positive_ttl
        $spam_check_negative_ttl $spam_check_positive_ttl
! 
!       $enable_ldap $default_ldap $virus_lovers_ldap $spam_lovers_ldap
!       $banned_files_lovers_ldap $bad_header_lovers_ldap
!       $bypass_virus_checks_ldap $bypass_spam_checks_ldap
!       $bypass_banned_checks_ldap $bypass_header_checks_ldap
!       $spam_tag_level_ldap $spam_tag2_level_ldap $spam_kill_level_ldap
!       $spam_modifies_subj_ldap $local_domains_ldap
!       $spam_quarantine_to_ldap $virus_quarantine_to_ldap
!       $banned_quarantine_to_ldap $bad_header_quarantine_to_ldap
!       $spam_whitelist_sender_ldap $spam_blacklist_sender_ldap
! 
        @keep_decoded_original_maps @map_full_type_to_short_type_maps
        @viruses_that_fake_sender_maps
+ 
+       %no_autocreate_domains @no_autocreate_domains_acl $no_autocreate_domains_re
+       $key_file
      )],
      'unpack' => [qw(
***************
*** 263,267 ****
      )],
      'platform' => [qw(
!       $can_truncate $unicode_aware $eol
        &D_REJECT &D_BOUNCE &D_DISCARD &D_PASS
      )],
--- 292,296 ----
      )],
      'platform' => [qw(
!       $can_truncate $unicode_aware $eol $encryption_key
        &D_REJECT &D_BOUNCE &D_DISCARD &D_PASS
      )],
***************
*** 300,304 ****
        $addr_extension_virus $addr_extension_spam
        $addr_extension_banned $addr_extension_bad_header
!       $gets_addr_in_quoted_form @debug_sender_acl
      )],
    );
--- 329,333 ----
        $addr_extension_virus $addr_extension_spam
        $addr_extension_banned $addr_extension_bad_header
!       $gets_addr_in_quoted_form @debug_sender_acl $unix_socketname
      )],
    );
***************
*** 310,313 ****
--- 339,343 ----
  use Carp ();
  use Errno qw(ENOENT EACCES);
+ use IO::File;
  
  use vars @EXPORT;
***************
*** 373,380 ****
  }
  
! $myproduct_name = 'amavisd-new';
! $myversion_id = '2.2.1'; $myversion_date = '20041222';
  
! $myversion = "$myproduct_name-$myversion_id ($myversion_date)";
  $myversion_id_numeric =  # x.yyyzzz, allows numerical comparision, like Perl $]
    sprintf("%8.6f", $1 + ($2 + $3/1000)/1000)
--- 403,410 ----
  }
  
! $myproduct_name = 'amavisd-maia';
! $myversion_id = '1.0.2'; $myversion_date = '20070105';
  
! $myversion = "Maia Mailguard 1.0.2";
  $myversion_id_numeric =  # x.yyyzzz, allows numerical comparision, like Perl $]
    sprintf("%8.6f", $1 + ($2 + $3/1000)/1000)
***************
*** 455,461 ****
  # starting with 2.2.1 this restriction is lifted.
  $sql_select_white_black_list =
!   'SELECT wb FROM wblist,mailaddr'
!   . ' WHERE (wblist.rid=?) AND (wblist.sid=mailaddr.id)'
!   . '   AND (mailaddr.email IN (%k))'
    . ' ORDER BY mailaddr.priority DESC';
  
--- 485,493 ----
  # starting with 2.2.1 this restriction is lifted.
  $sql_select_white_black_list =
!   'SELECT wblist.wb FROM wblist,mailaddr,users'
!   . ' WHERE (users.id=?)'
!   . ' AND (wblist.rid=users.maia_user_id)'
!   . ' AND (wblist.sid=mailaddr.id)'
!   . ' AND (mailaddr.email IN (%k))'
    . ' ORDER BY mailaddr.priority DESC';
  
***************
*** 463,467 ****
  # Receiving mail related
  
- # $unix_socketname = '/var/amavis/amavisd.sock'; # traditional amavis client protocol
  # $inet_socket_port = 10024;      # accept SMTP on this TCP port
  # $inet_socket_port = [10024,10026,10027];  # ...possibly on more than one
--- 495,498 ----
***************
*** 573,578 ****
  #
  # Bounce and Reject are similar: in both cases sender gets a non-delivery
! # notification, either generated by amavisd-new, or by MTA. The notification
! # issued by amavisd-new may be more informative, while on the other hand
  # MTA may be able to do a true reject on the original SMTP session
  # (e.g. with sendmail milter), or else it just generates normal non-delivery
--- 604,609 ----
  #
  # Bounce and Reject are similar: in both cases sender gets a non-delivery
! # notification, either generated by amavisd-maia, or by MTA. The notification
! # issued by amavisd-maia may be more informative, while on the other hand
  # MTA may be able to do a true reject on the original SMTP session
  # (e.g. with sendmail milter), or else it just generates normal non-delivery
***************
*** 581,585 ****
  # than Reject, but sendmail-milter users may prefer Reject.
  #
! # Bounce and Discard are similar: in both cases amavisd-new confirms
  # to MTA the message reception with success code 250. The difference is
  # in sender notification: Bounce sends a non-delivery notification to sender,
--- 612,616 ----
  # than Reject, but sendmail-milter users may prefer Reject.
  #
! # Bounce and Discard are similar: in both cases amavisd-maia confirms
  # to MTA the message reception with success code 250. The difference is
  # in sender notification: Bounce sends a non-delivery notification to sender,
***************
*** 607,611 ****
  #
  # D_BOUNCE   mail will not be delivered to its recipients, a non-delivery
! #            notification (bounce) will be sent to the sender by amavisd-new;
  #            Exception: bounce (DSN) will not be sent if a virus name matches
  #            $viruses_that_fake_sender_maps, or to messages from mailing lists
--- 638,642 ----
  #
  # D_BOUNCE   mail will not be delivered to its recipients, a non-delivery
! #            notification (bounce) will be sent to the sender by amavisd-maia;
  #            Exception: bounce (DSN) will not be sent if a virus name matches
  #            $viruses_that_fake_sender_maps, or to messages from mailing lists
***************
*** 618,631 ****
  #            (e.g. Postfix). If this is not possible (e.g. different recipients
  #            have different tolerances to bad mail contents and not using LMTP)
! #            amavisd-new sends a bounce by itself (same as D_BOUNCE).
  #
  # Notes:
  #   D_REJECT and D_BOUNCE are similar, the difference is in who is responsible
  #            for informing the sender about non-delivery, and how informative
! #            the notification can be (amavisd-new knows more than MTA);
  #   With D_REJECT, MTA may reject original SMTP, or send DSN (delivery status
  #            notification, colloquially called 'bounce') - depending on MTA;
  #            Best suited for sendmail milter, especially for spam.
! #   With D_BOUNCE, amavisd-new (not MTA) sends DSN (can better explain the
  #            reason for mail non-delivery but unable to reject the original
  #            SMTP session, is in position to suppress DSN if considered
--- 649,662 ----
  #            (e.g. Postfix). If this is not possible (e.g. different recipients
  #            have different tolerances to bad mail contents and not using LMTP)
! #            amavisd-maia sends a bounce by itself (same as D_BOUNCE).
  #
  # Notes:
  #   D_REJECT and D_BOUNCE are similar, the difference is in who is responsible
  #            for informing the sender about non-delivery, and how informative
! #            the notification can be (amavisd-maia knows more than MTA);
  #   With D_REJECT, MTA may reject original SMTP, or send DSN (delivery status
  #            notification, colloquially called 'bounce') - depending on MTA;
  #            Best suited for sendmail milter, especially for spam.
! #   With D_BOUNCE, amavisd-maia (not MTA) sends DSN (can better explain the
  #            reason for mail non-delivery but unable to reject the original
  #            SMTP session, is in position to suppress DSN if considered
***************
*** 750,754 ****
    [qr/^RPM\b/                         => 'rpm'],
    [qr/^(Transport Neutral Encapsulation Format|TNEF)\b/i => 'tnef'],
!   [qr/^Microsoft cabinet file\b/      => 'cab'],
  
    [qr/^(uuencoded|xxencoded)\b/i      => 'uue'],
--- 781,785 ----
    [qr/^RPM\b/                         => 'rpm'],
    [qr/^(Transport Neutral Encapsulation Format|TNEF)\b/i => 'tnef'],
!   [qr/^Microsoft cabinet file\b/i     => 'cab'],
  
    [qr/^(uuencoded|xxencoded)\b/i      => 'uue'],
***************
*** 897,901 ****
    my(@config_files) = @_;
    for my $config_file (@config_files) {
!     my($msg);
      my($errn) = stat($config_file) ? 0 : 0+$!;
      if    ($errn == ENOENT) { $msg = "does not exist" }
--- 928,932 ----
    my(@config_files) = @_;
    for my $config_file (@config_files) {
!     my($msg, $fh);
      my($errn) = stat($config_file) ? 0 : 0+$!;
      if    ($errn == ENOENT) { $msg = "does not exist" }
***************
*** 919,922 ****
--- 950,963 ----
    $lock_file    = "$MYHOME/amavisd.lock"    if !defined $lock_file;
    $pid_file     = "$MYHOME/amavisd.pid"     if !defined $pid_file;
+   $encryption_key = undef;
+   if (defined $key_file) {
+     my $fh = new IO::File;
+     if ($fh->open("<" . $key_file)) {
+       sysread($fh, $encryption_key, 56);
+       $fh->close;
+     } else {
+ 	  die "Encyption key not found or unreadable: $key_file \nIf you don't need encryption in the database, comment out \$key_file in amavisd.conf\n$!";
+     }
+   }
  
    $X_HEADER_TAG = 'X-Virus-Scanned'               if !defined $X_HEADER_TAG;
***************
*** 1058,1063 ****
  
  # Log either to syslog or a file
! sub write_log($$$) {
!   my($level,$errmsg,$am_id) = @_;
  
    my($old_locale) = setlocale(LC_TIME,"C");  # English dates required!
--- 1099,1104 ----
  
  # Log either to syslog or a file
! sub write_log($$$$) {
!   my($level,$errmsg,$am_id,$bypass_sanitize) = @_;
  
    my($old_locale) = setlocale(LC_TIME,"C");  # English dates required!
***************
*** 1069,1073 ****
    }
    $am_id = !defined $am_id ? '' : "($am_id) ";
!   $errmsg = Amavis::Util::sanitize_str($errmsg);
  # if (length($errmsg) > 2000) {  # crop at some arbitrary limit (< LINE_MAX)
  #   $errmsg = substr($errmsg,0,2000) . "...";
--- 1110,1114 ----
    }
    $am_id = !defined $am_id ? '' : "($am_id) ";
!   $errmsg = Amavis::Util::sanitize_str($errmsg) if !$bypass_sanitize;
  # if (length($errmsg) > 2000) {  # crop at some arbitrary limit (< LINE_MAX)
  #   $errmsg = substr($errmsg,0,2000) . "...";
***************
*** 1337,1345 ****
  
  # write log entry
! sub do_log($$) {
!   my($level, $errmsg) = @_;
    if (ll($level)) {
      $level = 0  if $level > 0 && ($DEBUG || $debug_oneshot);
!     write_log($level, $errmsg, am_id());
    }
  }
--- 1378,1386 ----
  
  # write log entry
! sub do_log($$;$) {
!   my($level, $errmsg, $bypass_sanitize) = @_;
    if (ll($level)) {
      $level = 0  if $level > 0 && ($DEBUG || $debug_oneshot);
!     write_log($level, $errmsg, am_id(), $bypass_sanitize);
    }
  }
***************
*** 1631,1635 ****
  #     }
        close(STDIN)       or die "Can't close STDIN: $!";
!       close(main::stdin) or die "Can't close main::stdin: $!";
        open(STDIN, "<$stdin_from")
          or die "Can't reopen STDIN on $stdin_from: $!";
--- 1672,1676 ----
  #     }
        close(STDIN)       or die "Can't close STDIN: $!";
!       close(main::stdin);
        open(STDIN, "<$stdin_from")
          or die "Can't reopen STDIN on $stdin_from: $!";
***************
*** 1684,1688 ****
        close(main::stderr) or die "Can't close main::stderr: $!";
        close(main::stdout) or die "Can't close main::stdout: $!";
!       close(main::STDOUT) or die "Can't close main::STDOUT: $!";
        open(STDOUT, ">$stdout_to")
          or die "Can't reopen STDOUT on $stdout_to: $!";
--- 1725,1729 ----
        close(main::stderr) or die "Can't close main::stderr: $!";
        close(main::stdout) or die "Can't close main::stdout: $!";
!       close(main::STDOUT);
        open(STDOUT, ">$stdout_to")
          or die "Can't reopen STDOUT on $stdout_to: $!";
***************
*** 1825,1829 ****
      $client_ip = 'IPv6:' . $client_ip;
    }
!   my($s) = sprintf("from %s%s\n by %s%s (amavisd-new, %s)",
      ($conn->smtp_helo eq '' ? 'unknown' : $conn->smtp_helo),
      ($client_ip eq '' ? '' : " ([$client_ip])"),
--- 1866,1870 ----
      $client_ip = 'IPv6:' . $client_ip;
    }
!   my($s) = sprintf("from %s%s\n by %s%s (amavisd-maia, %s)",
      ($conn->smtp_helo eq '' ? 'unknown' : $conn->smtp_helo),
      ($client_ip eq '' ? '' : " ([$client_ip])"),
***************
*** 2018,2022 ****
  # mailbox address, as per rfc2821.
  #
! # Internal (unquoted) form is used internally by amavisd-new and other mail sw,
  # external (quoted) form is used in SMTP commands and message headers.
  #
--- 2059,2063 ----
  # mailbox address, as per rfc2821.
  #
! # Internal (unquoted) form is used internally by amavisd-maia and other mail sw,
  # external (quoted) form is used in SMTP commands and message headers.
  #
***************
*** 2057,2061 ****
  # mailbox address, as per rfc2821.
  #
! # Internal (unquoted) form is used internally by amavisd-new and other mail sw,
  # external (quoted) form is used in SMTP commands and message headers.
  #
--- 2098,2102 ----
  # mailbox address, as per rfc2821.
  #
! # Internal (unquoted) form is used internally by amavisd-maia and other mail sw,
  # external (quoted) form is used in SMTP commands and message headers.
  #
***************
*** 2328,2332 ****
  BEGIN {
    import Amavis::Util qw(ll do_log);
!   import Amavis::Conf qw(:platform c cr ca);
    import Amavis::Timing qw(section_time);
    import Amavis::rfc2821_2822_Tools qw(split_address make_query_keys);
--- 2369,2376 ----
  BEGIN {
    import Amavis::Util qw(ll do_log);
!   import Amavis::Conf qw(:platform c cr ca
!                          %no_autocreate_domains 
!                          @no_autocreate_domains_acl 
!                          $no_autocreate_domains_re);
    import Amavis::Timing qw(section_time);
    import Amavis::rfc2821_2822_Tools qw(split_address make_query_keys);
***************
*** 2755,2758 ****
--- 2799,5552 ----
  
  #
+ package Amavis::Maia;
+ use strict;
+ 
+ BEGIN {
+    use Exporter ();
+    use vars qw(@ISA @EXPORT @EXPORT_OK %EXPORT_TAGS $VERSION);
+    use POSIX qw(strftime);
+    use Net::SMTP;
+    use Digest::MD5;
+    $VERSION = '1.15';
+    @ISA = qw(Exporter);
+    %EXPORT_TAGS = ();
+    @EXPORT = ();
+    @EXPORT_OK = qw(&maia_connect
+                    &maia_disconnect
+                    &maia_read_system_config
+                    &maia_autocreate_users
+                    &maia_store_mail
+                    &maia_get_recipient_id
+                    &maia_set_mail_status
+                    &maia_record_viruses
+                    &maia_record_tests
+                    &maia_record_banned_files
+                    &maia_delete_mail
+                    &maia_get_database_type
+                    &maia_get_mysql_size_limit
+                    &maia_should_discard_ham
+                    &maia_delete_mail_recipient_reference
+                    &maia_discard_if_requested
+                    &maia_recipient_is_local
+                    &maia_recipient_can_be_autocreated
+                    &maia_filter_pattern
+                    &maia_wblist_lookup
+                    &maia_cleanup);
+ }
+ use subs @EXPORT_OK;
+ 
+ BEGIN {
+    import Amavis::Conf qw(:confvars :platform);
+    import Amavis::Timing qw(section_time);
+    import Amavis::Util qw(untaint do_log prolong_timer);
+    import Amavis::Lookup qw(lookup);
+    import Amavis::rfc2821_2822_Tools qw(split_address);
+    import Mail::SpamAssassin;
+ }
+ 
+ # Connect to a Maia DSN (not exported)
+ sub maia_connect_to_sql(@) {
+     my(@dsns) = @_;  # a list of DSNs to try connecting to sequentially
+     my($dbh);
+     do_log(3,"Maia: [connect_to_sql] Connecting to SQL database server");
+     for my $tmpdsn (@dsns) {
+ 	my($dsn, $username, $password) = @$tmpdsn;
+ 	do_log(4, "Maia: [connect_to_sql] Trying '$dsn'");
+ 	$dbh = DBI->connect($dsn, $username, $password,
+ 			    {PrintError => 0, RaiseError => 0, Taint => 1, AutoCommit => 1} );
+ 	if ($dbh) { do_log(3,"Maia: [connect_to_sql] '$dsn' succeeded"); last }
+ 	do_log(0, "Maia: [connect_to_sql] Couldn't connect to DSN '$dsn': " .
+ 		  $DBI::errstr);
+     }
+     do_log(0, "Maia: [connect_to_sql] Couldn't connect to any DSN at all!") if !$dbh && @dsns>1;
+ 
+     return $dbh;
+ }
+ 
+ 
+ # Connect to the Maia database, return a connection handle
+ sub maia_connect() {
+     my($dbh) = maia_connect_to_sql(@lookup_sql_dsn);
+     if (!defined($dbh)) {
+        do_log(0, "Maia: [connect] SQL server(s) not reachable, ABORTING");
+        die;
+     } else {
+        $dbh->{'RaiseError'} = 1;
+        my $dbtype = maia_get_database_type($dbh);
+        if ($dbtype =~ /^mysql$/si) {
+            do_log(3, "Maia: [connect] Database type is MySQL");
+        } elsif ($dbtype =~ /^pg$/si) {
+            do_log(3, "Maia: [connect] Database type is PostgreSQL");
+        } else {
+            do_log(0, sprintf("Maia: [connect] Database type '%s' is not supported, ABORTING", $dbtype));
+            die;
+        }
+     }
+     section_time("maia_connect");
+     return $dbh;
+ }
+ 
+ 
+ # Close the connection to the Maia database
+ sub maia_disconnect($) {
+     my($dbh) = @_;
+ 
+     do_log(3, "Maia: [disconnect] Disconnecting from SQL database");
+     $dbh->disconnect();
+     section_time("maia_disconnect");
+ }
+ 
+ 
+ # Read amavisd-relevant system-wide Maia configuration parameters
+ sub maia_read_system_config($) {
+     my($dbh) = @_;
+     my($query, $sth, @row);
+     my $enable_false_negative_management = 0;
+     my $enable_virus_checking = 0;
+     my $enable_spam_checking = 0;
+     my $enable_bad_header_checking = 0;
+     my $enable_banned_files_checking = 0;
+     my $enable_user_autocreation = 0;
+     my $enable_stats_tracking = 0;
+     my $enable_spamtraps = 0;
+     my $size_limit = 0;
+     my $oversize_policy = "R";
+     my $internal_auth = 0;
+     my $system_default_user_is_local = 1;
+ 
+     $query = "SELECT enable_false_negative_management, " .
+                     "enable_virus_scanning, " .
+                     "enable_spam_filtering, " .
+                     "enable_bad_header_checking, " .
+                     "enable_banned_files_checking, " .
+                     "enable_user_autocreation, " .
+                     "enable_stats_tracking, " .
+                     "enable_spamtraps, " .
+                     "size_limit, " .
+                     "oversize_policy, " .
+                     "internal_auth, " .
+                     "system_default_user_is_local " .
+              "FROM maia_config";
+ 
+     $sth = $dbh->prepare($query)
+           or do_log(0, sprintf("Maia: [read_system_config] Couldn't prepare query: %s", $dbh->errstr));
+     $sth->execute()
+           or do_log(0, sprintf("Maia: [read_system_config] Couldn't execute query: %s", $sth->errstr));
+ 
+     if (@row = $sth->fetchrow_array()) {
+         $enable_false_negative_management = 1 * ($row[0] =~ /^Y$/);
+         $enable_virus_checking = 1 * ($row[1] =~ /^Y$/);
+         $enable_spam_checking = 1 * ($row[2] =~ /^Y$/);
+         $enable_bad_header_checking = 1 * ($row[3] =~ /^Y$/);
+         $enable_banned_files_checking = 1 * ($row[4] =~ /^Y$/);
+         $enable_user_autocreation = 1 * ($row[5] =~ /^Y$/);
+         $enable_stats_tracking = 1 * ($row[6] =~ /^Y$/);
+         $enable_spamtraps = 1 * ($row[7] =~ /^Y$/);
+         $size_limit = $1 if $row[8] =~ /^([0-9]+)$/si;
+         $oversize_policy = $1 if $row[9] =~ /^([PB])$/si;
+         $internal_auth = 1 * ($row[10] =~ /^Y$/);
+         $system_default_user_is_local = 1 * ($row[11] =~ /^Y$/);
+     } else {
+         do_log(0, "Maia: [read_system_config] Config table is empty!");
+         die "Maia configuration table is empty, ABORTING";
+     }
+ 
+     $sth->finish;
+ 
+     do_log(3, sprintf("Maia: [read_system_config] False negative management is %s", ($enable_false_negative_management ? "ENABLED" : "DISABLED")));
+     do_log(3, sprintf("Maia: [read_system_config] Virus scanning is %s", ($enable_virus_checking ? "ENABLED" : "DISABLED")));
+     do_log(3, sprintf("Maia: [read_system_config] Spam filtering is %s", ($enable_spam_checking ? "ENABLED" : "DISABLED")));
+     do_log(3, sprintf("Maia: [read_system_config] Bad header checking is %s", ($enable_bad_header_checking ? "ENABLED" : "DISABLED")));
+     do_log(3, sprintf("Maia: [read_system_config] Banned files checking is %s", ($enable_banned_files_checking ? "ENABLED" : "DISABLED")));
+     do_log(3, sprintf("Maia: [read_system_config] User autocreation is %s", ($enable_user_autocreation ? "ENABLED" : "DISABLED")));
+     do_log(3, sprintf("Maia: [read_system_config] Internal authentication mechanism is %s", ($internal_auth ? "ENABLED" : "DISABLED")));
+     do_log(3, sprintf("Maia: [read_system_config] Stats tracking is %s", ($enable_stats_tracking ? "ENABLED" : "DISABLED")));
+     do_log(3, sprintf("Maia: [read_system_config] Spam traps are %s", ($enable_spamtraps ? "ENABLED" : "DISABLED")));
+     do_log(3, sprintf("Maia: [read_system_config] Mail larger than %ld bytes will be %s", $size_limit, ($oversize_policy =~ /^P$/si ? "PASSED" : "BOUNCED")));
+     do_log(3, sprintf("Maia: [read_system_config] The system default user (@.) %s apply to non-local recipients", ($system_default_user_is_local ? "WILL NOT" : "WILL")));
+     do_log(3, sprintf("Maia: [read_system_config] Blowfish encryption is %s", ((defined $encryption_key) ? "ENABLED" : "DISABLED")));
+ 
+     section_time("maia_read_system_config");
+     return $enable_false_negative_management,
+            $enable_virus_checking,
+            $enable_spam_checking,
+            $enable_bad_header_checking,
+            $enable_banned_files_checking,
+            $enable_user_autocreation,
+            $enable_stats_tracking,
+            $enable_spamtraps,
+            $size_limit,
+            $oversize_policy,
+            $internal_auth,
+            $system_default_user_is_local;
+ }
+ 
+ 
+ # Encrypt a text string using a specified key (not exported).
+ sub maia_encrypt_text($$) {
+     my ($key, $plaintext) = @_;
+     my ($cipher);
+ 
+     require Crypt::CBC;
+ 
+     $key = $1 if $key =~ /^([^\0]{56})$/si; # untaint
+     $cipher = Crypt::CBC->new( {'key' => $key,
+                                 'cipher' => 'Blowfish',
+                                 'regenerate_key' => 0,
+                                 'padding' => 'null',
+                                 'prepend_iv' => 1,
+ 				'header' => 'randomiv'
+                               } );
+ 
+     return $cipher->encrypt($plaintext);
+ }
+ 
+ 
+ # Returns a randomly-generated 8-character alphanumeric
+ # password and its 32-byte MD5 hash. (not exported)
+ sub maia_generate_random_password() {
+     my(@chars, $password, $digest);
+     my($md5) = Digest::MD5->new;
+ 
+     @chars = ("A".."Z", "a".."z", 0..9);
+     $password = join("", @chars[ map { rand @chars } (1..8) ]);
+     $md5->add($password);
+     $digest = $1 if $md5->hexdigest =~ /^([0-9a-f]{32})$/; # untaint
+     $digest = untaint($digest);
+     return ($password, $digest);
+ }
+ 
+ 
+ # Returns the name of the DBD driver in use
+ # e.g. "mysql", "pg", etc.
+ sub maia_get_database_type($) {
+     my ($dbh) = @_;
+ 
+     return $dbh->{Driver}->{Name};
+ }
+ 
+ 
+ # Returns MySQL's max_allowed_packet size, in bytes
+ sub maia_get_mysql_size_limit($) {
+     my ($dbh) = @_;
+     my ($sth, @row, $show, $bytes);
+ 
+     $bytes = 0;
+     $show = "SHOW VARIABLES LIKE 'max_allowed_packet'";
+     $sth = $dbh->prepare($show)
+                or die (sprintf("Maia: [get_mysql_size_limit] Couldn't prepare query: %s", $dbh->errstr));
+     $sth->execute()
+         or die (sprintf("Maia: [get_mysql_size_limit] Couldn't execute query: %s", $dbh->errstr));
+     if (@row = $sth->fetchrow_array()) {
+         $bytes = $1 if $row[1] =~ /^([0-9]+)$/si; # untaint
+     }
+     $bytes = untaint($bytes);
+     do_log(3, sprintf("Maia: [get_mysql_size_limit] MySQL max_allowed_packet size is %ld bytes", $bytes));
+ 
+     section_time("maia_get_mysql_size_limit");
+     return $bytes;
+ }
+ 
+ 
+ # Filters a user-supplied pseudo-regexp to escape any
+ # metacharacters and interpret only DOS-style wildcards (*,?)
+ sub maia_filter_pattern($) {
+     my ($pattern) = @_;
+ 
+     $pattern = $1 if $pattern =~ /^(.+)$/si; # untaint
+     my $regexp = quotemeta($pattern);  # escape any regexp metacharacters
+     $regexp =~ s/\\\*/\.\*/g;          # interpret '*' as '.*'
+     $regexp =~ s/\\\?/\./g;            # interpret '?' as '.'
+     do_log(5, sprintf("Maia: [filter_pattern] Original: '%s', Filtered: '%s'",
+                       $pattern, $regexp), 1);
+ 
+     return $regexp;
+ }
+ 
+ 
+ # Looks up a sender's address against a specific recipient's
+ # whitelist and blacklist patterns.  Patterns are pseudo-regexps 
+ # that may contain DOS-style wildcards (*,?).
+ sub maia_wblist_lookup($$$) {
+     my ($dbh, $user_id, $sender) = @_;
+     my $recip;
+     my $wb = undef;
+     my $mkey = undef;
+ 
+     $user_id = $1 if $user_id =~ /^(\d+)$/si; # untaint
+     $sender = $1 if $sender =~ /^(.+\@.+\..+)$/si; # untaint
+     my $select = "SELECT email FROM users WHERE id = ?";
+     my $sth = $dbh->prepare($select)
+                   or die (sprintf("Maia: [wblist_lookup] Couldn't prepare query: %s", $dbh->errstr));
+     $sth->execute($user_id)
+         or die (sprintf("Maia: [wblist_lookup] Couldn't execute query: %s", $dbh->errstr));
+     if (my @row = $sth->fetchrow_array()) {
+         $recip = $1 if $row[0] =~ /^(.+)$/; # untaint
+     }
+     $sth->finish;
+     do_log(3, sprintf("Maia: [wblist_lookup] Sender: %s, Recipient: %s", $sender, $recip));
+ 
+     $select = "SELECT wb, mailaddr.email AS pattern " .
+               "FROM wblist, mailaddr, users, maia_users " .
+               "WHERE wblist.sid = mailaddr.id " .
+               "AND maia_users.id = wblist.rid " .
+               "AND users.maia_user_id = maia_users.id " .
+               "AND users.id = ?";
+     $sth = $dbh->prepare($select)
+                   or die (sprintf("Maia: [wblist_lookup] Couldn't prepare query: %s", $dbh->errstr));
+     $sth->execute($user_id)
+         or die (sprintf("Maia: [wblist_lookup] Couldn't execute query: %s", $dbh->errstr));
+     while (!defined ($mkey) && (my @row = $sth->fetchrow_array())) {
+         my $result = $1 if $row[0] =~ /^([WB])$/; # untaint
+         my $pattern = $1 if $row[1] =~ /^(.+)$/; # untaint
+         $pattern = '*' . $1 if $pattern =~ /^(\@.+)$/; # for backward compatibility
+         my $regexp = maia_filter_pattern($pattern);
+         do_log(5, sprintf("Maia: [wblist_lookup] Testing regexp '\/\^%s\$\/'", $regexp), 1);
+         if ($sender =~ /^$regexp$/si) {
+             $wb = $result;
+             $mkey = $pattern;
+         }
+     }
+     $sth->finish;
+ 
+     if (defined($wb) && defined($mkey)) {
+         do_log(3, sprintf("Maia: [wblist_lookup] Sender %s matches pattern '%s', result: '%s'",
+                           $sender, $mkey, $wb));
+     } else {
+         do_log(5, sprintf("Maia: [wblist_lookup] No matches for sender %s and recipient %s",
+                           $sender, $recip));
+     }
+ 
+     return ($wb, $mkey);
+ }
+ 
+ 
+ # Sends an e-mail via the downstream MTA (not exported)
+ sub maia_send_email($$$$$) {
+     my ($smtp_server, $smtp_port, $from, $to, $body) = @_;
+ 
+     $smtp_server = untaint($smtp_server);
+     $smtp_port = untaint($smtp_port);
+     $from = untaint($from);
+     $to = untaint($to);
+     $body = untaint($body);
+     my($smtp) = Net::SMTP->new($smtp_server, Port => $smtp_port) ;
+     die "Couldn't connect to SMTP server" unless $smtp;
+     $smtp->mail($from) ;
+     $smtp->to($to) ;
+     $smtp->data() ;
+     $smtp->datasend($body . "\n") ;
+     $smtp->dataend() ;
+     $smtp->quit() ;
+ }
+ 
+ 
+ # Assigns a random password to a new user and sends
+ # the user an e-mail with temporary login credentials. (not exported)
+ sub maia_issue_password($$$) {
+     my ($dbh, $user_email, $user_id) = @_;
+     my ($select, $update, $sth, @row);
+     my ($smtp_server, $smtp_port, $admin_email, $newuser_template_file, $login_url);
+     $select = "SELECT admin_email, " .
+                      "newuser_template_file, " .
+                      "reminder_login_url, " .
+                      "smtp_server, " .
+                      "smtp_port " .
+               "FROM maia_config WHERE id = 0";
+     $sth = $dbh->prepare($select)
+                or die (sprintf("Maia: [issue_password] Couldn't prepare query: %s", $dbh->errstr));
+     $sth->execute()
+         or die (sprintf("Maia: [issue_password] Couldn't execute query: %s", $dbh->errstr));
+     if (@row = $sth->fetchrow_array()) {
+         $admin_email = $1 if $row[0] =~ /^(.+\@.+)$/si; # untaint
+         $admin_email = untaint($admin_email);
+         $newuser_template_file = $1 if $row[1] =~ /^(.+)$/si; # untaint
+         $newuser_template_file = untaint($newuser_template_file);
+         $login_url = $1 if $row[2] =~ /^(.+)$/si; # untaint
+         $login_url = untaint($login_url);
+         $smtp_server = $1 if $row[3] =~ /^(.+)$/si; # untaint
+         $smtp_server = untaint($smtp_server);
+         $smtp_port = $1 if $row[4] =~ /^([1-9]+[0-9]*)$/si; # untaint
+         $smtp_port = untaint($smtp_port);
+     }
+     $sth->finish;
+ 
+     # Read the e-mail template file into memory once
+     open TEMPLATEFILE, "<" . $newuser_template_file
+         or die ("Maia: [issue_password] Unable to open $newuser_template_file\n");
+     my($template) = "";
+     my($line);
+     while ($line = <TEMPLATEFILE>) {
+         $template .= $line;
+     }
+     close TEMPLATEFILE;
+ 
+     my($password, $digest) = maia_generate_random_password();
+ 
+     $update = "UPDATE maia_users SET password = ? WHERE id = ?";
+     $sth = $dbh->prepare($update)
+                or die (sprintf("Maia: [issue_password] Couldn't prepare query: %s", $dbh->errstr));
+     $sth->execute($digest, $user_id)
+         or die (sprintf("Maia: [issue_password] Couldn't execute query: %s", $dbh->errstr));
+ 
+     # Perform substitutions in the template
+     my($body) = $template;
+     $body =~ s/%%LOGIN%%/$user_email/g;
+     $body =~ s/%%PASSWORD%%/$password/g;
+     $body =~ s/%%ADMINEMAIL%%/$admin_email/g;
+     $body =~ s/%%LOGINURL%%/$login_url/g;
+ 
+     # Send the e-mail
+     maia_send_email($smtp_server, $smtp_port, $admin_email, $user_email, $body);
+ }
+ 
+ 
+ # Determine whether an e-mail recipient is "local" or not
+ sub maia_recipient_is_local($$$) {
+     my($dbh, $recipient, $local_domain_tables) = @_;
+     my($select, $sth, @row, $domain);
+     my $is_local = 0;
+ 
+     $recipient = $1 if $recipient =~ /^(.+\@.+)$/si; # untaint
+     $recipient = untaint($recipient);
+     $domain = $1 if $recipient =~ /^.+(\@.+)$/si; # untaint;
+     $domain = untaint($domain);
+ 
+     #if the user is listed in users, then they should be local. --DGM
+     $select = "SELECT id from users WHERE email = ?";
+     $sth = $dbh->prepare($select)
+                or do_log(0, sprintf("Maia: [recipient_is_local] Couldn't prepare query: %s", $dbh->errstr));
+     $sth->execute($recipient)
+         or do_log(0, sprintf("Maia: [recipient_is_local] Couldn't execute query: %s", $dbh->errstr));
+     if (@row = $sth->fetchrow_array()) { 
+         do_log(3, sprintf("Maia: [recipient_is_local] Recipient %s is local", $recipient));
+         return 1;
+     }
+     
+     #otherwise, check for local domain and local lookup tables.
+     $select = "SELECT id FROM maia_domains WHERE domain = ?";
+     $sth = $dbh->prepare($select)
+                or do_log(0, sprintf("Maia: [recipient_is_local] Couldn't prepare query: %s", $dbh->errstr));
+     $sth->execute($domain)
+         or do_log(0, sprintf("Maia: [recipient_is_local] Couldn't execute query: %s", $dbh->errstr));
+     $is_local = ((@row = $sth->fetchrow_array()) || lookup(0,$recipient, @$local_domain_tables));
+     $sth->finish;
+     do_log(3, sprintf("Maia: [recipient_is_local] Recipient %s is %slocal", $recipient, $is_local ? "" : "non-"));
+ 
+     return $is_local;
+ }
+ 
+ 
+ # Determine whether user-autocreation is allowed for a (local) recipient
+ sub maia_recipient_can_be_autocreated($$$) {
+     my($dbh, $recipient, $no_autocreate_domain_tables) = @_;
+     my($select, $sth, @row, $domain);
+     my $can_be_autocreated = 0;
+ 
+     $recipient = $1 if $recipient =~ /^(.+\@.+)$/si; # untaint
+     $recipient = untaint($recipient);
+     $domain = $1 if $recipient =~ /^.+(\@.+)$/si; # untaint;
+     $domain = untaint($domain);
+ 
+     $select = "SELECT id FROM maia_domains WHERE domain = ? AND enable_user_autocreation = 'N'";
+     $sth = $dbh->prepare($select)
+                or do_log(0, sprintf("Maia: [recipient_can_be_autocreated] Couldn't prepare query: %s", $dbh->errstr));
+     $sth->execute($domain)
+         or do_log(0, sprintf("Maia: [recipient_can_be_autocreated] Couldn't execute query: %s", $dbh->errstr));
+     $can_be_autocreated = !((@row = $sth->fetchrow_array()) || lookup(0,$recipient, @$no_autocreate_domain_tables));
+     $sth->finish;
+     do_log(3, sprintf("Maia: [recipient_can_be_autocreated] Recipient %s can%s be auto-created",
+            $recipient, $can_be_autocreated ? "" : "not"));
+ 
+     return $can_be_autocreated;
+ }
+ 
+ 
+ # Auto-create users as necessary from the recipient list
+ sub maia_autocreate_users($$$$$) {
+     my($dbh, $msginfo, $internal_auth, $local_domain_tables,
+        $no_autocreate_domain_tables) = @_;
+     my($select, $insert, $update, $sth, $sth2, @row, @row2);
+     my($recipient, $policy_id, $user_id, $domain, $email_id);
+     my($policy_virus_lover, $policy_spam_lover, $policy_banned_files_lover);
+     my($policy_bad_header_lover, $policy_bypass_virus_checks);
+     my($policy_bypass_spam_checks, $policy_bypass_banned_checks);
+     my($policy_bypass_header_checks, $policy_spam_modifies_subj);
+     my($policy_discard_viruses, $policy_discard_spam);
+     my($policy_discard_banned_files, $policy_discard_bad_headers);
+     my($policy_spam_tag_level, $policy_spam_tag2_level, $policy_spam_kill_level);
+     my($default_reminders, $default_charts, $default_language, $default_charset, $default_auto_whitelist);
+     my($default_items_per_page, $default_theme_id, $default_quarantine_digest_interval, $default_truncate_subject);
+     my($default_truncate_email, $default_spamtrap);
+     my $nodefault = 0;
+     my $dbtype = maia_get_database_type($dbh);
+ 
+     $select = "SELECT id FROM users WHERE email = ?";
+     $sth = $dbh->prepare($select)
+                or do_log(0, sprintf("Maia: [autocreate_users] Couldn't prepare query: %s", $dbh->errstr));
+     for my $r (@{$msginfo->per_recip_data}) {
+ 
+         if (maia_recipient_is_local($dbh, $r->recip_addr, $local_domain_tables)) {
+ 
+             if (maia_recipient_can_be_autocreated($dbh, $r->recip_addr, $no_autocreate_domain_tables)) {
+ 
+                 $recipient = $1 if $r->recip_addr =~ /^(.+\@.+)$/si; # untaint
+                 $recipient = untaint($recipient);
+ 
+                 $sth->execute($recipient)
+                     or do_log(0, sprintf("Maia: [autocreate_users] Couldn't execute query: %s", $dbh->errstr));
+ 
+                 if (@row = $sth->fetchrow_array()) {
+                     do_log(3, sprintf("Maia: [autocreate_users] Recipient %s already exists", $recipient));
+                 } else {
+                     do_log(3, sprintf("Maia: [autocreate_users] Adding new recipient %s", $recipient));
+ 
+                     # find appropriate defaults to inherit
+                     # - try to find a suitable default based on the recipient's domain first
+                     # - use the 'Default' policy next.  (It's a serious error if it doesn't)
+                     
+                     my($localpart,$domain) = split_address($recipient);
+                     $domain = lc($domain);
+                     $domain = $1 if $domain =~ /^(.+\..+)$/si; # untaint
+                     $domain = untaint($domain);
+ 
+                     $select = "SELECT reminders, charts, language, charset, auto_whitelist, " .
+                            "items_per_page, theme_id, quarantine_digest_interval, truncate_subject, truncate_email " .
+                            "FROM maia_users where user_name=?";
+ 
+                     $sth2 = $dbh->prepare($select)
+                                 or do_log(0, sprintf("Maia: [autocreate_users] Couldn't prepare query: %s", $dbh->errstr));
+                     $sth2->execute($domain)
+                                 or do_log(0, sprintf("Maia: [autocreate_users] Couldn't execute query: %s", $dbh->errstr));
+                     if (@row2 = $sth2->fetchrow_array()) {
+                         do_log(3, sprintf("Maia: [autocreate_users] Using default maia_user settings for domain %s", $domain));
+                     } else {
+                         $sth2->execute("@.")
+                             or do_log(0, sprintf("Maia: [autocreate_users] Couldn't execute query: %s", $dbh->errstr));
+                         if (@row2 = $sth2->fetchrow_array()) {
+                             do_log(3, 'Maia: [autocreate_users] Using default maia_user settings for @.');
+                         } else {
+                             do_log(0, 'Maia: [autocreate_users] No defailt @. user found!');
+                         }
+                     }
+                     
+                     $default_reminders = $1 if $row2[0] =~ /^([YN])$/si; # untaint
+                     $default_charts = $1 if $row2[1] =~ /^([YN])$/si; # untaint
+                     $default_language = $1 if $row2[2] =~ /^(\w+)$/si; # untaint
+                     $default_charset = $1 if $row[3] =~ /^([-\w]+)$/si; # untaint
+                     $default_auto_whitelist = $1 if $row2[4] =~ /^([YN])$/si; # untaint
+                     $default_items_per_page = $1 if $row2[5] =~ /^([0-9]+)$/si; # untaint
+                     $default_theme_id = $1 if $row2[6] =~ /^([0-9]+)$/si; # untaint
+                     $default_quarantine_digest_interval = $1 if $row2[7] =~ /^([0-9]+)$/si; # untaint
+                     $default_truncate_subject = $1 if $row2[8] =~ /^([0-9]+)$/si; # untaint
+                     $default_truncate_email = $1 if $row2[9] =~ /^([0-9]+)$/si; # untaint
+                     $default_spamtrap = 'N'; #for safety, this is always 'N'
+                     
+                     $sth2->finish;
+ 
+ 					#this taint buisiness is getting stupid; for some reason one of these was causing problems.
+ 					#So ... I hit them all with the big hammer.
+ 					$default_reminders=untaint($default_reminders);
+ 					$default_charts=untaint($default_charts);
+ 					$default_language=untaint($default_language);
+ 					$default_charset=untaint($default_charset);
+ 					$default_auto_whitelist=untaint($default_auto_whitelist);
+ 					$default_items_per_page=untaint($default_items_per_page);
+ 					$default_theme_id=untaint($default_theme_id);
+ 					$default_quarantine_digest_interval=untaint($default_quarantine_digest_interval);
+ 					$default_truncate_subject=untaint($default_truncate_subject);
+ 					$default_truncate_email=untaint($default_truncate_email);
+ 					$default_spamtrap=untaint($default_spamtrap);
+ 
+                     
+                     # create a new user with defaults from above
+                     if ($dbtype =~ /^mysql$/si) { # MySQL
+ 
+                         $insert = "INSERT INTO maia_users (user_name, reminders, charts, language, charset, auto_whitelist, " .
+                                   "items_per_page, theme_id, quarantine_digest_interval, truncate_subject, truncate_email, spamtrap) " .
+                                   "VALUES (?,?,?,?,?,?,?,?,?,?,?,?)";
+                         $sth2 = $dbh->prepare($insert)
+                             or do_log(0, sprintf("Maia: [autocreate_users] Couldn't prepare query: %s", $dbh->errstr));
+                         $sth2->execute($recipient, $default_reminders, $default_charts, $default_language, $default_charset, $default_auto_whitelist,
+                                     $default_items_per_page, $default_theme_id, $default_quarantine_digest_interval, $default_truncate_subject,
+                                     $default_truncate_email, $default_spamtrap)
+                             or do_log(0, sprintf("Maia: [autocreate_users] Couldn't execute query: %s", $dbh->errstr));
+                         $select = "SELECT LAST_INSERT_ID()";
+                         $sth2 = $dbh->prepare($select)
+                             or do_log(0, sprintf("Maia: [autocreate_users] Couldn't prepare query: %s", $dbh->errstr));
+                         $sth2->execute()
+                             or do_log(0, sprintf("Maia: [autocreate_users] Couldn't execute query: %s", $dbh->errstr));
+                         if (@row2 = $sth2->fetchrow_array()) {
+                             $user_id = $1 if $row2[0] =~ /^([1-9]+[0-9]*)$/si; # untaint
+                             $user_id = untaint($user_id);
+                         } else {
+                             do_log(0, sprintf("Maia: [autocreate_users] Can't find new user %s", $recipient));
+                         }
+                         $sth2->finish;
+ 
+                     } elsif ($dbtype =~ /^pg$/si) { # PostgreSQL
+ 
+                         $select = "SELECT NEXTVAL('maia_users_id_seq')";
+                         $sth2 = $dbh->prepare($select)
+                             or do_log(0, sprintf("Maia: [autocreate_users] Couldn't prepare query: %s", $dbh->errstr));
+                         $sth2->execute()
+                             or do_log(0, sprintf("Maia: [autocreate_users] Couldn't execute query: %s", $dbh->errstr));
+                         if (@row2 = $sth2->fetchrow_array()) {
+                             $user_id = $1 if $row2[0] =~ /^([1-9]+[0-9]*)$/si; # untaint
+                             $user_id = untaint($user_id);
+                         } else {
+                             do_log(0, sprintf("Maia: [autocreate_users] Can't find new user %s", $recipient));
+                         }
+                         $sth2->finish;
+                         $insert = "INSERT INTO maia_users (id, user_name, reminders, charts, language, charset, auto_whitelist, " .
+                                   "items_per_page, theme_id, quarantine_digest_interval, truncate_subject, truncate_email, spamtrap) " .
+                                   "VALUES (?, ?,?,?,?,?,?,?,?,?,?,?,?)";
+                         $sth2 = $dbh->prepare($insert)
+                             or do_log(0, sprintf("Maia: [autocreate_users] Couldn't prepare query: %s", $dbh->errstr));
+                         $sth2->execute($user_id, $recipient, $default_reminders, $default_charts, $default_language, $default_charset, $default_auto_whitelist,
+                                         $default_items_per_page, $default_theme_id, $default_quarantine_digest_interval, $default_truncate_subject,
+                                         $default_truncate_email, $default_spamtrap)
+                             or do_log(0, sprintf("Maia: [autocreate_users] Couldn't execute query: %s", $dbh->errstr));
+                         $sth2->finish;
+                     }
+ 
+                     # create a new policy for this user
+                     # - try to find a suitable default policy based on the recipient's domain first
+                     # - use the 'Default' policy next, if it exists
+                     # - use the hard-coded database defaults, if all else fails
+                     $select = "SELECT virus_lover, " .
+                                      "spam_lover, " .
+                                      "banned_files_lover, " .
+                                      "bad_header_lover, " .
+                                      "bypass_virus_checks, " .
+                                      "bypass_spam_checks, " .
+                                      "bypass_banned_checks, " .
+                                      "bypass_header_checks, " .
+                                      "discard_viruses, " .
+                                      "discard_spam, " .
+                                      "discard_banned_files, " .
+                                      "discard_bad_headers, " .
+                                      "spam_modifies_subj, " .
+                                      "spam_tag_level, " .
+                                      "spam_tag2_level, " .
+                                      "spam_kill_level " .
+                               "FROM policy WHERE policy_name = ?";
+                     $sth2 = $dbh->prepare($select)
+                         or do_log(0, sprintf("Maia: [autocreate_users] Couldn't prepare query: %s", $dbh->errstr));
+                     $sth2->execute($domain)
+                         or do_log(0, sprintf("Maia: [autocreate_users] Couldn't execute query: %s", $dbh->errstr));
+                     if (@row2 = $sth2->fetchrow_array()) {
+                         # use domain default policy settings
+                         do_log(3, sprintf("Maia: [autocreate_users] Using default policies for domain %s", $domain));
+                         $policy_virus_lover = $1 if $row2[0] =~ /^([YN])$/si; # untaint
+                         $policy_spam_lover = $1 if $row2[1] =~ /^([YN])$/si; # untaint
+                         $policy_banned_files_lover = $1 if $row2[2] =~ /^([YN])$/si; # untaint
+                         $policy_bad_header_lover = $1 if $row2[3] =~ /^([YN])$/si; # untaint
+                         $policy_bypass_virus_checks = $1 if $row2[4] =~ /^([YN])$/si; # untaint
+                         $policy_bypass_spam_checks = $1 if $row2[5] =~ /^([YN])$/si; # untaint
+                         $policy_bypass_banned_checks = $1 if $row2[6] =~ /^([YN])$/si; # untaint
+                         $policy_bypass_header_checks = $1 if $row2[7] =~ /^([YN])$/si; # untaint
+                         $policy_discard_viruses = $1 if $row2[8] =~ /^([YN])$/si; # untaint
+                         $policy_discard_spam = $1 if $row2[9] =~ /^([YN])$/si; # untaint
+                         $policy_discard_banned_files = $1 if $row2[10] =~ /^([YN])$/si; # untaint
+                         $policy_discard_bad_headers = $1 if $row2[11] =~ /^([YN])$/si; # untaint
+                         $policy_spam_modifies_subj = $1 if $row2[12] =~ /^([YN])$/si; # untaint
+                         $policy_spam_tag_level = $1 if $row2[13] =~ /^([0-9\-\.]+)$/si; # untaint
+                         $policy_spam_tag2_level = $1 if $row2[14] =~ /^([0-9\-\.]+)$/si; # untaint
+                         $policy_spam_kill_level = $1 if $row2[15] =~ /^([0-9\-\.]+)$/si; # untaint
+                         $nodefault = 0;
+                     } else {
+                         $sth2->execute("Default")
+                             or do_log(0, sprintf("Maia: [autocreate_users] Couldn't execute query: %s", $dbh->errstr));
+                         if (@row2 = $sth2->fetchrow_array()) {
+                             # use global default policy settings
+                             do_log(3, "Maia: [autocreate_users] Using global default policies");
+                             $policy_virus_lover = $1 if $row2[0] =~ /^([YN])$/si; # untaint
+                             $policy_spam_lover = $1 if $row2[1] =~ /^([YN])$/si; # untaint
+                             $policy_banned_files_lover = $1 if $row2[2] =~ /^([YN])$/si; # untaint
+                             $policy_bad_header_lover = $1 if $row2[3] =~ /^([YN])$/si; # untaint
+                             $policy_bypass_virus_checks = $1 if $row2[4] =~ /^([YN])$/si; # untaint
+                             $policy_bypass_spam_checks = $1 if $row2[5] =~ /^([YN])$/si; # untaint
+                             $policy_bypass_banned_checks = $1 if $row2[6] =~ /^([YN])$/si; # untaint
+                             $policy_bypass_header_checks = $1 if $row2[7] =~ /^([YN])$/si; # untaint
+                             $policy_discard_viruses = $1 if $row2[8] =~ /^([YN])$/si; # untaint
+                             $policy_discard_spam = $1 if $row2[9] =~ /^([YN])$/si; # untaint
+                             $policy_discard_banned_files = $1 if $row2[10] =~ /^([YN])$/si; # untaint
+                             $policy_discard_bad_headers = $1 if $row2[11] =~ /^([YN])$/si; # untaint
+                             $policy_spam_modifies_subj = $1 if $row2[12] =~ /^([YN])$/si; # untaint
+                             $policy_spam_tag_level = $1 if $row2[13] =~ /^([0-9\-\.]+)$/si; # untaint
+                             $policy_spam_tag2_level = $1 if $row2[14] =~ /^([0-9\-\.]+)$/si; # untaint
+                             $policy_spam_kill_level = $1 if $row2[15] =~ /^([0-9\-\.]+)$/si; # untaint
+                             $nodefault = 0;
+                         } else {
+                             do_log(0, "Maia: [autocreate_users] No default policy entry (@.) exists!");
+                             do_log(3, "Maia: [autocreate_users] Using database default policies");
+                             $nodefault = 1;
+                         }
+                     }
+                     $sth2->finish;
+ 
+                     $policy_virus_lover = untaint($policy_virus_lover);
+                     $policy_spam_lover = untaint($policy_spam_lover);
+                     $policy_banned_files_lover = untaint($policy_banned_files_lover);
+                     $policy_bad_header_lover = untaint($policy_bad_header_lover);
+                     $policy_bypass_virus_checks = untaint($policy_bypass_virus_checks);
+                     $policy_bypass_spam_checks = untaint($policy_bypass_spam_checks);
+                     $policy_bypass_banned_checks = untaint($policy_bypass_banned_checks);
+                     $policy_bypass_header_checks = untaint($policy_bypass_header_checks);
+                     $policy_discard_viruses = untaint($policy_discard_viruses);
+                     $policy_discard_spam = untaint($policy_discard_spam);
+                     $policy_discard_banned_files = untaint($policy_discard_banned_files);
+                     $policy_discard_bad_headers = untaint($policy_discard_bad_headers);
+                     $policy_spam_modifies_subj = untaint($policy_spam_modifies_subj);
+                     $policy_spam_tag_level = untaint($policy_spam_tag_level);
+                     $policy_spam_tag2_level = untaint($policy_spam_tag2_level);
+                     $policy_spam_kill_level = untaint($policy_spam_kill_level);
+ 
+                     if ($dbtype =~ /^mysql$/si) { # MySQL
+                         if ($nodefault) {
+                             $insert = "INSERT INTO policy (policy_name) VALUES (?)";
+                             $sth2 = $dbh->prepare($insert)
+                                 or do_log(0, sprintf("Maia: [autocreate_users] Couldn't prepare query: %s", $dbh->errstr));
+                             $sth2->execute($recipient)
+                                 or do_log(0, sprintf("Maia: [autocreate_users] Couldn't execute query: %s", $dbh->errstr));
+                         } else {
+                             $insert = "INSERT INTO policy (policy_name, " .
+                                                           "virus_lover, " .
+                                                           "spam_lover, " .
+                                                           "banned_files_lover, " .
+                                                           "bad_header_lover, " .
+                                                           "bypass_virus_checks, " .
+                                                           "bypass_spam_checks, " .
+                                                           "bypass_banned_checks, " .
+                                                           "bypass_header_checks, " .
+                                                           "discard_viruses, " .
+                                                           "discard_spam, " .
+                                                           "discard_banned_files, " .
+                                                           "discard_bad_headers, " .
+                                                           "spam_modifies_subj, " .
+                                                           "spam_tag_level, " .
+                                                           "spam_tag2_level, " .
+                                                           "spam_kill_level" .
+                                       ") VALUES (?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?)";
+                             $sth2 = $dbh->prepare($insert)
+                                 or do_log(0, sprintf("Maia: [autocreate_users] Couldn't prepare query: %s", $dbh->errstr));
+                             $sth2->execute($recipient,
+                                            $policy_virus_lover,
+                                            $policy_spam_lover,
+                                            $policy_banned_files_lover,
+                                            $policy_bad_header_lover,
+                                            $policy_bypass_virus_checks,
+                                            $policy_bypass_spam_checks,
+                                            $policy_bypass_banned_checks,
+                                            $policy_bypass_header_checks,
+                                            $policy_discard_viruses,
+                                            $policy_discard_spam,
+                                            $policy_discard_banned_files,
+                                            $policy_discard_bad_headers,
+                                            $policy_spam_modifies_subj,
+                                            $policy_spam_tag_level,
+                                            $policy_spam_tag2_level,
+                                            $policy_spam_kill_level)
+                                 or do_log(0, sprintf("Maia: [autocreate_users] Couldn't execute query: %s", $dbh->errstr));
+                         }
+                         $select = "SELECT LAST_INSERT_ID()";
+                         $sth2 = $dbh->prepare($select)
+                             or do_log(0, sprintf("Maia: [autocreate_users] Couldn't prepare query: %s", $dbh->errstr));
+                         $sth2->execute()
+                             or do_log(0, sprintf("Maia: [autocreate_users] Couldn't execute query: %s", $dbh->errstr));
+                         if (@row2 = $sth2->fetchrow_array()) {
+                             $policy_id = $1 if $row2[0] =~ /^([1-9]+[0-9]*)$/si; # untaint
+                             $policy_id = untaint($policy_id);
+                         } else {
+                             do_log(0, sprintf("Maia: [autocreate_users] Can't find new policy for %s", $recipient));
+                         }
+                         $sth2->finish;
+ 
+                     } elsif ($dbtype =~ /^pg$/si) { # PostgreSQL
+ 
+                         $select = "SELECT NEXTVAL('policy_id_seq')";
+                         $sth2 = $dbh->prepare($select)
+                             or do_log(0, sprintf("Maia: [autocreate_users] Couldn't prepare query: %s", $dbh->errstr));
+                         $sth2->execute()
+                             or do_log(0, sprintf("Maia: [autocreate_users] Couldn't execute query: %s", $dbh->errstr));
+                         if (@row2 = $sth2->fetchrow_array()) {
+                             $policy_id = $1 if $row2[0] =~ /^([1-9]+[0-9]*)$/si; # untaint
+                             $policy_id = untaint($policy_id);
+                         } else {
+                             do_log(0, sprintf("Maia: [autocreate_users] Can't find new policy for %s", $recipient));
+                         }
+                         $sth2->finish;
+                         if ($nodefault) {
+                             $insert = "INSERT INTO policy (id, policy_name) VALUES (?, ?)";
+                             $sth2 = $dbh->prepare($insert)
+                                 or do_log(0, sprintf("Maia: [autocreate_users] Couldn't prepare query: %s", $dbh->errstr));
+                             $sth2->execute($policy_id, $recipient)
+                                 or do_log(0, sprintf("Maia: [autocreate_users] Couldn't execute query: %s", $dbh->errstr));
+                         } else {
+                             $insert = "INSERT INTO policy (id, " .
+                                                           "policy_name, " .
+                                                           "virus_lover, " .
+                                                           "spam_lover, " .
+                                                           "banned_files_lover, " .
+                                                           "bad_header_lover, " .
+                                                           "bypass_virus_checks, " .
+                                                           "bypass_spam_checks, " .
+                                                           "bypass_banned_checks, " .
+                                                           "bypass_header_checks, " .
+                                                           "discard_viruses, " .
+                                                           "discard_spam, " .
+                                                           "discard_banned_files, " .
+                                                           "discard_bad_headers, " .
+                                                           "spam_modifies_subj, " .
+                                                           "spam_tag_level, " .
+                                                           "spam_tag2_level, " .
+                                                           "spam_kill_level" .
+                                       ") VALUES (?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?)";
+                             $sth2 = $dbh->prepare($insert)
+                                 or do_log(0, sprintf("Maia: [autocreate_users] Couldn't prepare query: %s", $dbh->errstr));
+                             $sth2->execute($policy_id,
+                                            $recipient,
+                                            $policy_virus_lover,
+                                            $policy_spam_lover,
+                                            $policy_banned_files_lover,
+                                            $policy_bad_header_lover,
+                                            $policy_bypass_virus_checks,
+                                            $policy_bypass_spam_checks,
+                                            $policy_bypass_banned_checks,
+                                            $policy_bypass_header_checks,
+                                            $policy_discard_viruses,
+                                            $policy_discard_spam,
+                                            $policy_discard_banned_files,
+                                            $policy_discard_bad_headers,
+                                            $policy_spam_modifies_subj,
+                                            $policy_spam_tag_level,
+                                            $policy_spam_tag2_level,
+                                            $policy_spam_kill_level)
+                                 or do_log(0, sprintf("Maia: [autocreate_users] Couldn't execute query: %s", $dbh->errstr));
+                         }
+ 
+                     }
+ 
+                     # Assign a reasonable priority to the e-mail address
+                     # based on how "specific" it is--the more "dots", the more specific,
+                     # e.g. user@mail.example.com is more specific than user@example.com
+                     # E-mail addresses start at priority 10 and higher.
+                     my $dot_count = 0;
+                     my $tmp = $recipient;
+                     while ($tmp =~ /(\.)/g) {
+                         $dot_count++;
+                     }
+                     my $priority = 10 + 2 * $dot_count;
+ 
+                     # Create a new address for this user
+                     if ($dbtype =~ /^mysql$/si) { # MySQL
+ 
+                         $insert = "INSERT INTO users(policy_id, email, priority, maia_user_id, maia_domain_id) VALUES (?,?,?,?,?)";
+                         $sth2 = $dbh->prepare($insert)
+                             or do_log(0, sprintf("Maia: [autocreate_users] Couldn't prepare query: %s", $dbh->errstr));
+                         $sth2->execute($policy_id, $recipient, $priority, $user_id, 0)
+                             or do_log(0, sprintf("Maia: [autocreate_users] Couldn't execute query: %s", $dbh->errstr));
+                         $select = "SELECT LAST_INSERT_ID()";
+                         $sth2 = $dbh->prepare($select)
+                             or do_log(0, sprintf("Maia: [autocreate_users] Couldn't prepare query: %s", $dbh->errstr));
+                         $sth2->execute()
+                             or do_log(0, sprintf("Maia: [autocreate_users] Couldn't execute query: %s", $dbh->errstr));
+                         if (@row2 = $sth2->fetchrow_array()) {
+                             $email_id = $1 if $row2[0] =~ /^([1-9]+[0-9]*)$/si; # untaint
+                             $email_id = untaint($email_id);
+                         } else {
+                             do_log(0, sprintf("Maia: [autocreate_users] Can't find new policy for %s", $recipient));
+                         }
+                         $sth2->finish;
+ 
+                     } elsif ($dbtype =~ /^pg$/si) { # PostgreSQL
+ 
+                         $select = "SELECT NEXTVAL('users_id_seq')";
+                         $sth2 = $dbh->prepare($select)
+                             or do_log(0, sprintf("Maia: [autocreate_users] Couldn't prepare query: %s", $dbh->errstr));
+                         $sth2->execute()
+                             or do_log(0, sprintf("Maia: [autocreate_users] Couldn't execute query: %s", $dbh->errstr));
+                         if (@row2 = $sth2->fetchrow_array()) {
+                             $email_id = $1 if $row2[0] =~ /^([1-9]+[0-9]*)$/si; # untaint
+                             $email_id = untaint($email_id);
+                         } else {
+                             do_log(0, sprintf("Maia: [autocreate_users] Can't find new policy for %s", $recipient));
+                         }
+                         $sth2->finish;
+                         $insert = "INSERT INTO users(id, policy_id, email, priority, maia_user_id, maia_domain_id) VALUES (?,?,?,?,?,?)";
+                         $sth2 = $dbh->prepare($insert)
+                             or do_log(0, sprintf("Maia: [autocreate_users] Couldn't prepare query: %s", $dbh->errstr));
+                         $sth2->execute($email_id, $policy_id, $recipient, $priority, $user_id, 0)
+                             or do_log(0, sprintf("Maia: [autocreate_users] Couldn't execute query: %s", $dbh->errstr));
+ 
+                     }
+ 
+                     # Record this e-mail address as the user's primary address
+                     $update = "UPDATE maia_users SET primary_email_id = ? WHERE id = ?";
+                     $sth2 = $dbh->prepare($update)
+                         or do_log(0, sprintf("Maia: [autocreate_users] Couldn't prepare query: %s", $dbh->errstr));
+                     $sth2->execute($email_id, $user_id)
+                         or do_log(0, sprintf("Maia: [autocreate_users] Couldn't execute query: %s", $dbh->errstr));
+ 
+                     if ($internal_auth) {
+ 
+                         # Issue a random password and send temporary credentials
+                         # to the new user.
+                         maia_issue_password($dbh, $recipient, $user_id);
+                     }
+ 
+                 }
+ 
+             } else {
+ 
+                 do_log(3, sprintf("Maia: [autocreate_users] Ignoring recipient %s: on do-not-autocreate list by domain", $r->recip_addr));
+ 
+             }
+ 
+         } else {
+             do_log(3, sprintf("Maia: [autocreate_users] Ignoring non-local recipient %s", $r->recip_addr));
+         }
+     }
+     $sth->finish;
+     section_time("maia_autocreate_users");
+ }
+ 
+ # token generator uses Data::UUID from CPAN
+ #   possible bug in smp systems
+ #   if collisions occur, see this possible patch:
+ #   http://rt.cpan.org/NoAuth/Bug.html?id=15042
+ # appended to random token generated from password generator  
+ #   credit: http://web.uconn.edu/~cdavid/cgi-bin/book/make_password_html.pl  
+ # total: 64 characters
+ sub maia_token_generate(){  
+   use Data::UUID;  
+   my $ug    = new Data::UUID;  
+   my $uuid = $ug->create_hex();  
+   $uuid =~ s/0x(.*)/$1/;  
+ 
+   my (@passset,$rnd_passwd,$randum_num);  
+   my ($randum_num);  
+   @passset = ('A'..'Z','0'..'9');  
+   $rnd_passwd = "";  
+   for (my $i = 0; $i<32;$i++){  
+     $randum_num = int(rand($#passset+1));  
+     $rnd_passwd .= @passset[$randum_num];  
+   }  
+ 
+   return untaint($uuid . $rnd_passwd );  
+ }  
+ 
+ # Store e-mail in the database
+ sub maia_store_mail($$$$$@) {
+     my($dbh, $msginfo, $oversized, $enable_stats_tracking, $system_default_user_is_local, @local_domain_tables) = @_;
+     my($insert, $select, $sth, $sth2, $sth3, @row, @row2, $contents);
+     my $size = $1 if ($msginfo->orig_header_size + 1 + $msginfo->orig_body_size) =~ m/^([0-9]+)$/; # untaint
+     $size = untaint($size);
+     my $sender = $1 if $msginfo->sender =~ m/^(.*)$/; # untaint
+     $sender = untaint($sender);
+     my $subject = "";
+     my($header, $mail_id, $recipient, $user_id);
+     my($received_date) = strftime("%04Y-%02m-%02d %02H:%02M:%02S",localtime);
+     if (!$oversized) {
+        my($fh) = $msginfo->mail_text;
+        $fh->seek(0,0) or die "Can't rewind mail file: $!";
+        my(@lines) = <$fh>;
+        $contents = $1 if join("", @lines) =~ /^(.*)$/si; # untaint
+        $contents =~ s/\0//g; # strip nulls
+        if (defined $encryption_key) {
+            $contents = maia_encrypt_text($encryption_key, $contents);
+        }
+        $contents = untaint($contents);
+     }
+     my($recipients) = $1 if join(" ", @{$msginfo->recips}) =~ /^(.*)$/si; # untaint
+     $recipients = untaint($recipients);
+     my $dbtype = maia_get_database_type($dbh);
+     my $htype = "";
+     my $htext = "";
+     foreach $header( @{$msginfo->orig_header} ) {
+        if ( $header =~ /^(\S+): *(.*)$/ ) {
+            $htype = $1;
+            $htext = $2;
+        } elsif ( $header =~ /^\s+(.*)$/ ) {
+            $htext = " " . $1;
+        }
+        $subject .= $htext if $htype =~ /^Subject$/i;
+     }
+     $subject = substr($subject, 0, 255) if length($subject) > 255;
+     $subject = untaint($subject);
+     $sender = substr($sender, 0, 255) if length($sender) > 255;
+ 
+     if (!$oversized) {
+         if ($dbtype =~ /^mysql$/si) { # MySQL
+ 
+             $insert = "INSERT INTO maia_mail (received_date, size, sender_email, envelope_to, subject, contents) VALUES (NOW(),?,?,?,?,?)";
+             $sth = $dbh->prepare($insert)
+                 or do_log(0, sprintf("Maia: [store_mail] Couldn't prepare query: %s", $dbh->errstr));
+             $sth->execute($size, $sender, $recipients, $subject, $contents)
+                 or do_log(0, sprintf("Maia: [store_mail] Couldn't execute query: %s", $dbh->errstr));
+             $select = "SELECT LAST_INSERT_ID()";
+             $sth = $dbh->prepare($select)
+                 or do_log(0, sprintf("Maia: [store_mail] Couldn't prepare query: %s", $dbh->errstr));
+             $sth->execute()
+                 or do_log(0, sprintf("Maia: [store_mail] Couldn't execute query: %s", $dbh->errstr));
+             if (@row = $sth->fetchrow_array()) {
+                 $mail_id = $1 if $row[0] =~ /^([1-9]+[0-9]*)$/si; # untaint
+                 $mail_id = untaint($mail_id);
+             } else {
+                 do_log(0, sprintf("Maia: [store_mail] Can't find new mail item from %s!", $sender));
+                 die;
+             }
+             $sth->finish;
+ 
+         } elsif ($dbtype =~ /^pg$/si) { # PostgreSQL
+ 
+             $select = "SELECT NEXTVAL('maia_mail_id_seq')";
+             $sth = $dbh->prepare($select)
+                 or do_log(0, sprintf("Maia: [store_mail] Couldn't prepare query: %s", $dbh->errstr));
+             $sth->execute()
+                 or do_log(0, sprintf("Maia: [store_mail] Couldn't execute query: %s", $dbh->errstr));
+             if (@row = $sth->fetchrow_array()) {
+                 $mail_id = $1 if $row[0] =~ /^([1-9]+[0-9]*)$/si; # untaint
+                 $mail_id = untaint($mail_id);
+             } else {
+                 do_log(0, sprintf("Maia: [store_mail] Can't find new mail item from %s!", $sender));
+                 die;
+             }
+             $sth->finish;
+             $insert = "INSERT INTO maia_mail (id, received_date, size, sender_email, envelope_to, subject, contents) VALUES (?,NOW(),?,?,?,?,?)";
+             $sth = $dbh->prepare($insert)
+                 or do_log(0, sprintf("Maia: [store_mail] Couldn't prepare query: %s", $dbh->errstr));
+             $sth->execute($mail_id, $size, $sender, $recipients, $subject, $contents)
+                 or do_log(0, sprintf("Maia: [store_mail] Couldn't execute query: %s", $dbh->errstr));
+         }
+ 
+         # create references for registered recipients of this mail item
+         for my $r (@{$msginfo->per_recip_data}) {
+             $recipient = $1 if $r->recip_addr =~ /^(.+\@.+)$/si; # untaint
+             $recipient = untaint($recipient);
+             $user_id = maia_get_recipient_id($dbh, $recipient, $system_default_user_is_local, @local_domain_tables);
+             if ($user_id > 0) {
+                 $user_id = $1 if $user_id =~ /^([1-9]+[0-9]*)$/si; # untaint
+                 $user_id = untaint($user_id);
+                 $select = "SELECT mail_id, recipient_id FROM maia_mail_recipients WHERE mail_id = ? AND recipient_id = ?";
+                 $sth = $dbh->prepare($select)
+                     or do_log(0, sprintf("Maia: [store_mail] Couldn't prepare query: %s", $dbh->errstr));
+                 $sth->execute($mail_id, $user_id)
+                     or do_log(0, sprintf("Maia: [store_mail] Couldn't execute query: %s", $dbh->errstr));
+                 if (!(@row = $sth->fetchrow_array())) {
+                     # generate a unique token for this item
+                     my $token = maia_token_generate();
+ 
+                     $insert = "INSERT INTO maia_mail_recipients (mail_id, recipient_id, type, token) VALUES (?,?,'X',?)";
+                     $sth2 = $dbh->prepare($insert)
+                         or do_log(0, sprintf("Maia: [store_mail] Couldn't prepare query: %s", $dbh->errstr));
+                     eval { $sth2->execute($mail_id, $user_id, $token) }; # trap an error, if there is a duplicate
+                     if ( $@ ) { 
+                       #in case of a token collision. Unlikely that it would fail twice.
+                       #I'm more likely to win the lottery without buying a ticket than
+                       #even one collision, much less two...
+                       do_log(0, sprintf("Maia: [store_mail] Couldn't execute query: %s Trying one more time.",
+                                        $dbh->errstr));
+                       $token = maia_token_generate();
+                       $sth2->execute($mail_id, $user_id, $token);
+                     }
+                 }
+                 $sth->finish;
+             }
+         }
+ 
+         do_log(3, sprintf("Maia: [store_mail] Stored mail item %ld (%ld bytes)", $mail_id, $size));
+ 
+     } else {  # oversized item, don't store it, but update stats
+ 
+         $mail_id = 0;
+         if ($enable_stats_tracking) {
+ 
+             my($select, $insert, $update, $sth, $sth2, @row, @row2);
+             my($recipient, $recipient_id);
+             for my $r (@{$msginfo->per_recip_data}) {
+                 $recipient = $1 if $r->recip_addr =~ /^(.+\@.+)$/si; # untaint
+                 $recipient = untaint($recipient);
+                 $recipient_id = maia_get_recipient_id($dbh, $recipient, $system_default_user_is_local, @local_domain_tables);
+                 if ($recipient_id > 0) {
+                     $recipient_id = $1 if $recipient_id =~ /^([1-9]+[0-9]*)$/si; # untaint
+                     $recipient_id = untaint($recipient_id);
+                     my($total_oversized_items, $total_oversized_size, $newest_oversized_date);
+                     my($oldest_oversized_date, $smallest_oversized_size, $largest_oversized_size);
+                     $select = "SELECT total_oversized_items, " .
+                                      "total_oversized_size, " .
+                                      "oldest_oversized_date, " .
+                                      "smallest_oversized_size, " .
+                                      "largest_oversized_size " .
+                               "FROM maia_stats WHERE user_id = ?";
+                     $sth = $dbh->prepare($select)
+                         or do_log(0, sprintf("Maia: [store_mail] Couldn't prepare query: %s", $dbh->errstr));
+                     $sth->execute($recipient_id)
+                         or do_log(0, sprintf("Maia: [store_mail] Couldn't execute query: %s", $dbh->errstr));
+                     if (@row = $sth->fetchrow_array()) {   # user already has a stats record, update it
+                         $total_oversized_items = $1 if ($row[0] + 1) =~ /^([0-9]*)$/si; # untaint
+                         $total_oversized_items = untaint($total_oversized_items);
+                         if ($total_oversized_items == 1) {
+                             $total_oversized_size = $size;
+                             $smallest_oversized_size = $size;
+                             $largest_oversized_size = $size;
+                             $oldest_oversized_date = $received_date;
+                             $newest_oversized_date = $received_date;
+                         } else {
+                             $total_oversized_size = $1 if ($row[1] + $size) =~ /^([0-9]*)$/si; # untaint
+                             $total_oversized_size = untaint($total_oversized_size);
+                             $newest_oversized_date = $1 if $received_date =~ /^(.*)$/si; # untaint
+                             $newest_oversized_date = untaint($newest_oversized_date);
+                             $oldest_oversized_date = $1 if $row[2] =~ /^(.*)$/si; # untaint
+                             $oldest_oversized_date = untaint($oldest_oversized_date);
+                             if ($oldest_oversized_date == "") {
+                                 $oldest_oversized_date = $received_date;
+                             }
+                             $smallest_oversized_size = $1 if $row[3] =~ /^([0-9]*)$/si; # untaint
+                             $smallest_oversized_size = untaint($smallest_oversized_size);
+                             if ($smallest_oversized_size > $size) {
+                                 $smallest_oversized_size = $size;
+                             }
+                             $largest_oversized_size = $1 if $row[4] =~ /^([0-9]*)$/si; # untaint
+                             $largest_oversized_size = untaint($largest_oversized_size);
+                             if ($largest_oversized_size < $size) {
+                                 $largest_oversized_size = $size;
+                             }
+                         }
+                         $update = "UPDATE maia_stats SET total_oversized_items = ?, " .
+                                                         "total_oversized_size = ?, " .
+                                                         "newest_oversized_date = ?, " .
+                                                         "oldest_oversized_date = ?, " .
+                                                         "smallest_oversized_size = ?, " .
+                                                         "largest_oversized_size = ? " .
+                                   "WHERE user_id = ?";
+                         $sth = $dbh->prepare($update)
+                             or do_log(0, sprintf("Maia: [store_mail] Couldn't prepare query: %s", $dbh->errstr));
+                         $sth->execute($total_oversized_items,
+                                       $total_oversized_size,
+                                       $newest_oversized_date,
+                                       $oldest_oversized_date,
+                                       $smallest_oversized_size,
+                                       $largest_oversized_size,
+                                       $recipient_id)
+                             or do_log(0, sprintf("Maia: [store_mail] Couldn't execute query: %s", $dbh->errstr));
+                     } else {   # user has no stats record, create one
+                         $total_oversized_size = $1 if $size =~ /^([0-9]*)$/si; # untaint
+                         $total_oversized_size = untaint($total_oversized_size);
+                         $smallest_oversized_size = $total_oversized_size;
+                         $largest_oversized_size = $total_oversized_size;
+                         $newest_oversized_date = $1 if $received_date =~ /^(.*)$/si; # untaint
+                         $newest_oversized_date = untaint($newest_oversized_date);
+                         $oldest_oversized_date = $newest_oversized_date;
+                         $insert = "INSERT INTO maia_stats (user_id, " .
+                                                           "total_oversized_items, " .
+                                                           "total_oversized_size, " .
+                                                           "newest_oversized_date, " .
+                                                           "oldest_oversized_date, " .
+                                                           "smallest_oversized_size, " .
+                                                           "largest_oversized_size) " .
+                                   "VALUES (?,1,?,?,?,?,?)";
+                         $sth = $dbh->prepare($insert)
+                             or do_log(0, sprintf("Maia: [store_mail] Couldn't prepare query: %s", $dbh->errstr));
+                         $sth->execute($recipient_id,
+                                       $total_oversized_size,
+                                       $newest_oversized_date,
+                                       $oldest_oversized_date,
+                                       $smallest_oversized_size,
+                                      $largest_oversized_size)
+                             or do_log(0, sprintf("Maia: [store_mail] Couldn't execute query: %s", $dbh->errstr));
+                     }
+                     $sth->finish;
+                 }
+ 
+             }
+ 
+         }
+ 
+     }
+     section_time("maia_store_mail");
+     return $mail_id;
+ }
+ 
+ 
+ # returns true (1) if the user wants all his ham to be discarded
+ sub maia_should_discard_ham($$) {
+     my($dbh, $user_id) = @_;
+     my($sth, @row, $select, $discard_ham);
+ 
+     $user_id = $1 if $user_id =~ /^([1-9]+[0-9]*)$/si; # untaint
+     $user_id = untaint($user_id);
+     $select = "SELECT discard_ham FROM maia_users WHERE id = ?";
+     $sth = $dbh->prepare($select)
+         or do_log(0, sprintf("Maia: [get_discard_ham_status] Couldn't prepare query: %s", $dbh->errstr));
+     $sth->execute($user_id)
+         or do_log(0, sprintf("Maia: [get_discard_ham_status] Couldn't execute query: %s", $dbh->errstr));
+     if (@row = $sth->fetchrow_array()) {
+         $discard_ham = 1 * ($row[0] =~ /^Y$/i);
+     } else {
+         $discard_ham = 0;
+     }
+     $sth->finish;
+ 
+     return $discard_ham;
+ }
+ 
+ 
+ # Removes a recipient's reference to a mail item, if mail of a
+ # particular type is to be discarded.
+ sub maia_discard_if_requested($$$$$) {
+     my($dbh, $mail_id, $user_id, $recipient_addr, $type) = @_;
+     my($sth, @row, $select, $policy_id, $discard);
+ 
+     $mail_id = $1 if $mail_id =~ /^([1-9]+[0-9]*)$/si; # untaint
+     $mail_id = untaint($mail_id);
+     $user_id = $1 if $user_id =~ /^([1-9]+[0-9]*)$/si; # untaint
+     $user_id = untaint($user_id);
+     if ($recipient_addr =~ /^(.+@.+\..+)$/si) {
+         $recipient_addr = $1; # untaint
+         $recipient_addr = untaint($recipient_addr);
+         $select = "SELECT policy_id FROM users WHERE email = ?";
+         $sth = $dbh->prepare($select)
+             or do_log(0, sprintf("Maia: [discard_if_requested] Couldn't prepare query: %s", $dbh->errstr));
+         $sth->execute($recipient_addr)
+             or do_log(0, sprintf("Maia: [discard_if_requested] Couldn't execute query: %s", $dbh->errstr));
+         if (@row = $sth->fetchrow_array()) {
+             $policy_id = $1 if $row[0] =~ /^([1-9]+[0-9]*)$/si; # untaint
+             $policy_id = untaint($policy_id);
+         } else {
+             my $default = $1 if $recipient_addr =~ /^.+(@.+\..+)$/; # fall back to the domain default
+             $sth->execute($default)
+                 or do_log(0, sprintf("Maia: [discard_if_requested] Couldn't execute query: %s", $dbh->errstr));
+             if (@row = $sth->fetchrow_array()) {
+                 $policy_id = $1 if $row[0] =~ /^([1-9]+[0-9]*)$/si; # untaint
+                 $policy_id = untaint($policy_id);
+             } else {
+                 $default = "@."; # fall back to the system default
+                 $sth->execute($default)
+                     or do_log(0, sprintf("Maia: [discard_if_requested] Couldn't execute query: %s", $dbh->errstr));
+                 if (@row = $sth->fetchrow_array()) {
+                     $policy_id = $1 if $row[0] =~ /^([1-9]+[0-9]*)$/si; # untaint
+                     $policy_id = untaint($policy_id);
+                 } else {
+                     $policy_id = 0;
+                 }
+             }
+         }
+         $sth->finish;
+     } else {
+         $policy_id = 0;
+     }
+ 
+     if ($policy_id > 0) {
+         if ($type =~ /^V$/si) {
+             $select = "SELECT discard_viruses FROM policy WHERE id = ?";
+         } elsif ($type =~ /^S$/si) {
+             $select = "SELECT discard_spam FROM policy WHERE id = ?";
+         } elsif ($type =~ /^F$/si) {
+             $select = "SELECT discard_banned_files FROM policy WHERE id = ?";
+         } elsif ($type =~ /^B$/si) {
+             $select = "SELECT discard_bad_headers FROM policy WHERE id = ?";
+         }
+         $sth = $dbh->prepare($select)
+             or do_log(0, sprintf("Maia: [discard_if_requested] Couldn't prepare query: %s", $dbh->errstr));
+         $sth->execute($policy_id)
+             or do_log(0, sprintf("Maia: [discard_if_requested] Couldn't execute query: %s", $dbh->errstr));
+         if (@row = $sth->fetchrow_array()) {
+             $discard = ($row[0] =~ /^Y$/si);
+         }
+         $sth->finish;
+ 
+         if ($discard) {
+             do_log(3, sprintf("Maia: [discard_if_requested] Removing reference to mail item %ld for recipient %ld as requested",
+                    $mail_id, $user_id));
+             maia_delete_mail_recipient_reference($dbh, $mail_id, $user_id);
+         }
+     }
+ }
+ 
+ 
+ # returns the Maia user ID corresponding to a recipient e-mail address
+ sub maia_get_recipient_id($$$@) {
+     my($dbh, $recipient, $system_default_user_is_local, @local_domain_tables) = @_;
+     my($user_id, $sth, @row, $select);
+     my($user, $domain);
+ 
+     if (!$system_default_user_is_local || maia_recipient_is_local($dbh, $recipient, \@local_domain_tables)) {
+ 
+         # Look for an explicit user@domain match first
+         $user = $1 if $recipient =~ /^(.+\@.+)$/si; # untaint
+         $user = untaint($user);
+         $select = "SELECT maia_user_id FROM users WHERE email = ?";
+         $sth = $dbh->prepare($select)
+             or do_log(0, sprintf("Maia: [get_recipient_id] Couldn't prepare query: %s", $dbh->errstr));
+         $sth->execute($user)
+             or do_log(0, sprintf("Maia: [get_recipient_id] Couldn't execute query: %s", $dbh->errstr));
+         if (@row = $sth->fetchrow_array()) {
+             $user_id = $row[0];
+         } else {
+             $user_id = 0;
+         }
+         $sth->finish;
+ 
+         # If that failed, try the domain default (@domain)
+         if (!$user_id) {
+             $domain = $1 if $recipient =~ /^.+(\@.+)$/si; # untaint;
+             $domain = untaint($domain);
+             $select = "SELECT maia_user_id FROM users WHERE email = ?";
+             $sth = $dbh->prepare($select)
+                 or do_log(0, sprintf("Maia: [get_recipient_id] Couldn't prepare query: %s", $dbh->errstr));
+             $sth->execute($domain)
+                 or do_log(0, sprintf("Maia: [get_recipient_id] Couldn't execute query: %s", $dbh->errstr));
+             if (@row = $sth->fetchrow_array()) {
+                 $user_id = $row[0];
+             } else {
+                 $user_id = 0;
+             }
+             $sth->finish;
+         }
+ 
+         # If that failed, try the system default (@.)
+         if (!$user_id) {
+             $select = "SELECT maia_user_id FROM users WHERE email = '@.'";
+            $sth = $dbh->prepare($select)
+                 or do_log(0, sprintf("Maia: [get_recipient_id] Couldn't prepare query: %s", $dbh->errstr));
+             $sth->execute()
+                 or do_log(0, sprintf("Maia: [get_recipient_id] Couldn't execute query: %s", $dbh->errstr));
+             if (@row = $sth->fetchrow_array()) {
+                 $user_id = $row[0];
+             } else {
+                 $user_id = 0;
+             }
+             $sth->finish;
+         }
+ 
+         do_log(3, sprintf("Maia: [get_recipient_id] Recipient %s (id = %ld)", $recipient, $user_id));
+ 
+     } else {
+ 
+         $user_id = 0;
+         do_log(3, sprintf("Maia: [get_recipient_id] Receipient %s is non-local", $recipient));
+ 
+     }
+ 
+     return $user_id;
+ }
+ 
+ 
+ # Records occurrences of viruses in the viruses table and updates virus stats
+ sub maia_record_viruses($$@) {
+     my($dbh, $mail_id, @viruses) = @_;
+     my($select, $insert, $update, $sth, $sth2, @row);
+     my($virus_name, $virus_id, $virus_count);
+     my $dbtype = maia_get_database_type($dbh);
+ 
+     $mail_id = $1 if $mail_id =~ /^([1-9]+[0-9]*)$/si; # untaint
+     $mail_id = untaint($mail_id);
+     for my $v (@viruses) {
+         $virus_id = 0;
+         $virus_name = $1 if $v =~ /^(.*)$/si; # untaint
+         $virus_name = untaint($virus_name);
+ 
+         # first, look in the maia_viruses table
+         $select = "SELECT id, count FROM maia_viruses WHERE virus_name LIKE ?";
+         $sth = $dbh->prepare($select)
+             or do_log(0, sprintf("Maia: [record_viruses] Couldn't prepare query: %s", $dbh->errstr));
+         $sth->execute($virus_name)
+             or do_log(0, sprintf("Maia: [record_viruses] Couldn't execute query: %s", $dbh->errstr));
+         if (@row = $sth->fetchrow_array()) {
+             $virus_id = $1 if $row[0] =~ /^([1-9]+[0-9]*)$/si; # untaint
+             $virus_count = $1 if $row[1] =~ /^([0-9]*)$/si; # untaint
+             do_log(3, sprintf("Maia: [record_viruses] Found virus %s (id = %ld)", $virus_name, $virus_id));
+ 
+         # not found?  try the maia_virus_aliases table
+         } else {
+             $sth->finish;
+             $select = "SELECT maia_viruses.id, maia_viruses.count " .
+                       "FROM maia_viruses, maia_virus_aliases " .
+                       "WHERE maia_viruses.id = maia_virus_aliases.virus_id " .
+                       "AND maia_virus_aliases.virus_alias LIKE ?";
+             $sth = $dbh->prepare($select)
+                 or do_log(0, sprintf("Maia: [record_viruses] Couldn't prepare query: %s", $dbh->errstr));
+             $sth->execute($virus_name)
+                 or do_log(0, sprintf("Maia: [record_viruses] Couldn't execute query: %s", $dbh->errstr));
+             if (@row = $sth->fetchrow_array()) {
+                 $virus_id = $1 if $row[0] =~ /^([1-9]+[0-9]*)$/si; # untaint
+                 $virus_count = $1 if $row[1] =~ /^([0-9]*)$/si; # untaint
+                 do_log(3, sprintf("Maia: [record_viruses] Found aliased virus %s (id = %ld)", $virus_name, $virus_id));
+             }
+         }
+         $sth->finish;
+         $virus_id = untaint($virus_id);
+         $virus_count = untaint($virus_count);
+ 
+         # still not found?  create a new entry in the maia_viruses table
+         if ($virus_id == 0) {
+             if ($dbtype =~ /^mysql$/si) { # MySQL
+ 
+                 $insert = "INSERT INTO maia_viruses (virus_name, count) VALUES (?, 1)";
+                 $sth = $dbh->prepare($insert)
+                     or do_log(0, sprintf("Maia: [record_viruses] Couldn't prepare query: %s", $dbh->errstr));
+                 $sth->execute($virus_name)
+                     or do_log(0, sprintf("Maia: [record_viruses] Couldn't execute query: %s", $dbh->errstr));
+                 $select = "SELECT LAST_INSERT_ID()";
+                 $sth = $dbh->prepare($select)
+                     or do_log(0, sprintf("Maia: [record_viruses] Couldn't prepare query: %s", $dbh->errstr));
+                 $sth->execute()
+                     or do_log(0, sprintf("Maia: [record_viruses] Couldn't execute query: %s", $dbh->errstr));
+                 if (@row = $sth->fetchrow_array()) {
+                     $virus_id = $1 if $row[0] =~ /^([1-9]+[0-9]*)$/si; # untaint
+                     $virus_id = untaint($virus_id);
+                 } else {
+                     do_log(0, sprintf("Maia: [record_viruses] Couldn't locate record for %s!", $virus_name));
+                     die;
+                 }
+                 $sth->finish;
+ 
+             } elsif ($dbtype =~ /^pg$/si) { # PostgreSQL
+ 
+                 $select = "SELECT NEXTVAL('maia_viruses_id_seq')";
+                 $sth = $dbh->prepare($select)
+                     or do_log(0, sprintf("Maia: [record_viruses] Couldn't prepare query: %s", $dbh->errstr));
+                 $sth->execute()
+                     or do_log(0, sprintf("Maia: [record_viruses] Couldn't execute query: %s", $dbh->errstr));
+                 if (@row = $sth->fetchrow_array()) {
+                     $virus_id = $1 if $row[0] =~ /^([1-9]+[0-9]*)$/si; # untaint
+                     $virus_id = untaint($virus_id);
+                 } else {
+                     do_log(0, sprintf("Maia: [record_viruses] Couldn't locate record for %s!", $virus_name));
+                     die;
+                 }
+                 $sth->finish;
+                 $insert = "INSERT INTO maia_viruses (id, virus_name, count) VALUES (?, ?, 1)";
+                 $sth = $dbh->prepare($insert)
+                     or do_log(0, sprintf("Maia: [record_viruses] Couldn't prepare query: %s", $dbh->errstr));
+                 $sth->execute($virus_id, $virus_name)
+                     or do_log(0, sprintf("Maia: [record_viruses] Couldn't execute query: %s", $dbh->errstr));
+ 
+             }
+             do_log(3, sprintf("Maia: [record_viruses] Adding new virus %s (id = %ld)", $virus_name, $virus_id));
+ 
+         # found, increment the count for this virus
+         } else {
+             $update = "UPDATE maia_viruses SET count = ? WHERE id = ?";
+             $sth = $dbh->prepare($update)
+                 or do_log(0, sprintf("Maia: [record_viruses] Couldn't prepare query: %s", $dbh->errstr));
+             $sth->execute($virus_count + 1, $virus_id)
+                 or do_log(0, sprintf("Maia: [record_viruses] Couldn't execute query: %s", $dbh->errstr));
+         }
+ 
+         # create a reference to this virus from the mail item itself
+         $select = "SELECT mail_id, virus_id FROM maia_viruses_detected WHERE mail_id = ? AND virus_id = ?";
+         $sth = $dbh->prepare($select)
+             or do_log(0, sprintf("Maia: [record_viruses] Couldn't prepare query: %s", $dbh->errstr));
+         $sth->execute($mail_id, $virus_id)
+             or do_log(0, sprintf("Maia: [record_viruses] Couldn't execute query: %s", $dbh->errstr));
+         if (!(@row = $sth->fetchrow_array())) {
+             $insert = "INSERT INTO maia_viruses_detected (mail_id, virus_id) VALUES (?,?)";
+             $sth2 = $dbh->prepare($insert)
+                 or do_log(0, sprintf("Maia: [record_viruses] Couldn't prepare query: %s", $dbh->errstr));
+             $sth2->execute($mail_id, $virus_id)
+                 or do_log(0, sprintf("Maia: [record_viruses] Couldn't execute query: %s", $dbh->errstr));
+             do_log(3, sprintf("Maia: [record_viruses] Linking virus %ld to mail item %ld", $virus_id, $mail_id));
+         }
+         $sth->finish;
+     }
+     section_time("maia_record_viruses");
+ }
+ 
+ 
+ # Records the triggering of a SpamAssassin rule
+ sub maia_record_tests($$$$) {
+     my($dbh, $mail_id, $spam_status, $spam_level) = @_;
+     my($select, $insert, $update, $sth, $sth2, @row);
+     my($test_name, $test_id, $test_count, $test_score, $mail_score, $base_score);
+ 
+     $mail_id = $1 if $mail_id =~ /^([1-9]+[0-9]*)$/si; # untaint
+     $mail_id = untaint($mail_id);
+     $spam_level = $1 if $spam_level =~ /^(.+)$/si; # untaint
+     $spam_level = untaint($spam_level);
+     $mail_score = 0.0;
+     if ($spam_level =~ /([\-]{0,1}[0-9]+[\.]{0,1}[0-9]*)/si) {
+         $mail_score = $1;
+     }
+     $mail_score = untaint($mail_score);
+     my $test_list = $1 if $spam_status =~ /tests=(.*)/si;
+     $test_list =~ s/[\s\t\n]//g;
+     my @tests = split ",", $test_list;
+     for my $t (@tests) {
+         $test_id = 0;
+         $test_score = 0.0;
+         if ($t =~ /^(\w+)\=(\-?\d+\.?\d*)$/) {
+             $test_name = $1;
+             $test_score = $2;
+             $test_name = untaint($test_name);
+             $test_score = untaint($test_score);
+         }
+ 
+         # look up the test by name in the maia_sa_rules table
+         $select = "SELECT id, rule_count, rule_score_3 FROM maia_sa_rules WHERE rule_name LIKE ?";
+         $sth = $dbh->prepare($select)
+             or do_log(0, sprintf("Maia: [record_tests] Couldn't prepare query: %s", $dbh->errstr));
+         $sth->execute($test_name)
+             or do_log(0, sprintf("Maia: [record_tests] Couldn't execute query: %s", $dbh->errstr));
+         if (@row = $sth->fetchrow_array()) {
+             $test_id = $1 if $row[0] =~ /^([1-9]+[0-9]*)$/si; # untaint
+             $test_id = untaint($test_id);
+             $test_count = $1 if $row[1] =~ /^([0-9]*)$/si; # untaint
+             $test_count = untaint($test_count);
+             $base_score = $1 if $row[2] =~ /^(\-?\d+\.?\d*)$/si; # untaint
+             $base_score = untaint($base_score);
+             do_log(3, sprintf("Maia: [record_tests] Triggered SpamAssassin rule %s (id = %ld, score = %.3f)",
+                    $test_name, $test_id, $test_score));
+         }
+         $sth->finish;
+ 
+         # found, increment the count for this test
+         if ($test_id > 0) {
+             if ($test_score ne $base_score) {
+                 $update = "UPDATE maia_sa_rules SET rule_count = ?, rule_score_3 = ? WHERE id = ?";
+                 $sth = $dbh->prepare($update)
+                     or do_log(0, sprintf("Maia: [record_tests] Couldn't prepare query: %s", $dbh->errstr));
+                 $sth->execute($test_count + 1, $test_score, $test_id)
+                     or do_log(0, sprintf("Maia: [record_tests] Couldn't execute query: %s", $dbh->errstr));
+             } else {
+                 $update = "UPDATE maia_sa_rules SET rule_count = ? WHERE id = ?";
+                 $sth = $dbh->prepare($update)
+                     or do_log(0, sprintf("Maia: [record_tests] Couldn't prepare query: %s", $dbh->errstr));
+                 $sth->execute($test_count + 1, $test_id)
+                     or do_log(0, sprintf("Maia: [record_tests] Couldn't execute query: %s", $dbh->errstr));
+             }
+         }
+ 
+         # create a reference to this test from the mail item itself
+         $select = "SELECT mail_id, rule_id FROM maia_sa_rules_triggered WHERE mail_id = ? AND rule_id = ?";
+         $sth = $dbh->prepare($select)
+             or do_log(0, sprintf("Maia: [record_tests] Couldn't prepare query: %s", $dbh->errstr));
+         $sth->execute($mail_id, $test_id)
+             or do_log(0, sprintf("Maia: [record_tests] Couldn't execute query: %s", $dbh->errstr));
+         if ($test_score && $test_id && !(@row = $sth->fetchrow_array())) {
+             $insert = "INSERT INTO maia_sa_rules_triggered (mail_id, rule_id, rule_score) VALUES (?,?,?)";
+             $sth2 = $dbh->prepare($insert)
+                 or do_log(0, sprintf("Maia: [record_tests] Couldn't prepare query: %s", $dbh->errstr));
+             $sth2->execute($mail_id, $test_id, $test_score)
+                 or do_log(0, sprintf("Maia: [record_tests] Couldn't execute query: %s", $dbh->errstr));
+             do_log(3, sprintf("Maia: [record_tests] Linking SpamAssassin test %ld to mail item %ld", $test_id, $mail_id));
+         }
+         $sth->finish;
+     }
+ 
+     # update the mail item's final score
+     $update = "UPDATE maia_mail SET score = ? WHERE id = ?";
+     $sth = $dbh->prepare($update)
+         or do_log(0, sprintf("Maia: [record_tests] Couldn't prepare query: %s", $dbh->errstr));
+     $sth->execute($mail_score, $mail_id)
+         or do_log(0, sprintf("Maia: [record_tests] Couldn't execute query: %s", $dbh->errstr));
+ 
+     do_log(3, sprintf("Maia: [record_tests] Assigning mail item %ld a final score of %0.3f",
+                       $mail_id, $mail_score));
+     section_time("maia_record_tests");
+ }
+ 
+ 
+ # Records the detection of one or more banned file attachments
+ sub maia_record_banned_files($$@) {
+     my($dbh, $mail_id, @attachments) = @_;
+     my($insert, $select, $sth, $sth2, @row, $file_name, $file_type);
+     my(%seen, $attachment, @unique_attachments);
+ 
+     $mail_id = $1 if $mail_id =~ /^([1-9]+[0-9]*)$/si; # untaint
+     $mail_id = untaint($mail_id);
+     %seen = ();
+     foreach $attachment (@attachments) {
+         push(@unique_attachments, $attachment) unless $seen{$attachment}++;
+     }
+     for my $f (@unique_attachments) {
+         if ($f =~ /^.+?N=(\S+).*$/si) {
+             $file_name = $1;
+         } else {
+             $file_name = "unknown";
+         }
+         $file_name = untaint($file_name);
+         if ($f =~ /^.+?T=([^, ]+),*.+$/si) {
+             $file_type = $1;
+         } else {
+             $file_type = "unknown";
+         }
+         $file_type = untaint($file_type);
+ 
+         # create a reference to this file from the mail item itself
+         $select = "SELECT mail_id, file_name FROM maia_banned_attachments_found WHERE mail_id = ? AND file_name = ?";
+         $sth = $dbh->prepare($select)
+             or do_log(0, sprintf("Maia: [record_banned_files] Couldn't prepare query: %s", $dbh->errstr));
+         $sth->execute($mail_id, $file_name)
+             or do_log(0, sprintf("Maia: [record_banned_files] Couldn't execute query: %s", $dbh->errstr));
+         if (!(@row = $sth->fetchrow_array())) {
+             $insert = "INSERT INTO maia_banned_attachments_found (mail_id, file_name, file_type) VALUES (?,?,?)";
+             $sth2 = $dbh->prepare($insert)
+                 or do_log(0, sprintf("Maia: [record_banned_files] Couldn't prepare query: %s", $dbh->errstr));
+             $sth2->execute($mail_id, $file_name, $file_type)
+                 or do_log(0, sprintf("Maia: [record_banned_files] Couldn't execute query: %s", $dbh->errstr));
+             do_log(3, sprintf("Maia: [record_banned_file] Linking banned file %s to mail item %ld", $file_name, $mail_id));
+         }
+         $sth->finish;
+     }
+     section_time("maia_record_banned_files");
+ }
+ 
+ 
+ # Deletes a mail item and all references to it
+ sub maia_delete_mail($$) {
+     my($dbh, $mail_id) = @_;
+     my($delete, $sth);
+ 
+     $mail_id = $1 if $mail_id =~ /^([1-9]+[0-9]*)$/si; # untaint
+     $mail_id = untaint($mail_id);
+ 
+     if ($mail_id) {
+         do_log(3, sprintf("Maia: [delete_mail] Removing mail item %ld", $mail_id));
+ 
+         # Remove the mail item from maia_mail
+         $delete = "DELETE FROM maia_mail WHERE id = ?";
+         $sth = $dbh->prepare($delete)
+             or do_log(0, sprintf("Maia: [delete_mail] Couldn't prepare query: %s", $dbh->errstr));
+         $sth->execute($mail_id)
+             or do_log(0, sprintf("Maia: [delete_mail] Couldn't execute query: %s", $dbh->errstr));
+ 
+         # Remove any references from maia_viruses_detected
+         $delete = "DELETE FROM maia_viruses_detected WHERE mail_id = ?";
+         $sth = $dbh->prepare($delete)
+             or do_log(0, sprintf("Maia: [delete_mail] Couldn't prepare query: %s", $dbh->errstr));
+         $sth->execute($mail_id)
+             or do_log(0, sprintf("Maia: [delete_mail] Couldn't execute query: %s", $dbh->errstr));
+ 
+         # Remove any references from maia_sa_rules_triggered
+         $delete = "DELETE FROM maia_sa_rules_triggered WHERE mail_id = ?";
+         $sth = $dbh->prepare($delete)
+             or do_log(0, sprintf("Maia: [delete_mail] Couldn't prepare query: %s", $dbh->errstr));
+         $sth->execute($mail_id)
+             or do_log(0, sprintf("Maia: [delete_mail] Couldn't execute query: %s", $dbh->errstr));
+ 
+         # Remove any references from maia_banned_attachments_found
+         $delete = "DELETE FROM maia_banned_attachments_found WHERE mail_id = ?";
+         $sth = $dbh->prepare($delete)
+             or do_log(0, sprintf("Maia: [delete_mail] Couldn't prepare query: %s", $dbh->errstr));
+         $sth->execute($mail_id)
+             or do_log(0, sprintf("Maia: [delete_mail] Couldn't execute query: %s", $dbh->errstr));
+     }
+     section_time("maia_delete_mail");
+ }
+ 
+ 
+ # Removes a single recipient's reference to a single mail item
+ sub maia_delete_mail_recipient_reference($$$) {
+     my($dbh, $mail_id, $user_id) = @_;
+     my($delete, $sth);
+ 
+     $mail_id = $1 if $mail_id =~ /^([1-9]+[0-9]*)$/si; # untaint
+     $mail_id = untaint($mail_id);
+     $user_id = $1 if $user_id =~ /^([1-9]+[0-9]*)$/si; # untaint
+     $user_id = untaint($user_id);
+     $delete = "DELETE FROM maia_mail_recipients WHERE mail_id = ? AND recipient_id = ?";
+     $sth = $dbh->prepare($delete)
+         or do_log(0, sprintf("Maia: [delete_mail_recipient_reference] Couldn't prepare query: %s", $dbh->errstr));
+     $sth->execute($mail_id, $user_id)
+         or do_log(0, sprintf("Maia: [delete_mail_recipient_reference] Couldn't execute query: %s", $dbh->errstr));
+     section_time("maia_delete_mail_recipient_reference");
+ }
+ 
+ 
+ # Removes mail items without recipient references
+ sub maia_cleanup($$) {
+     my($dbh, $mail_id) = @_;
+     my($select, $sth, @row);
+ 
+     $mail_id = $1 if $mail_id =~ /^([1-9]+[0-9]*)$/si; # untaint
+     $mail_id = untaint($mail_id);
+ 
+     if ($mail_id) {
+         $select = "SELECT recipient_id FROM maia_mail_recipients WHERE mail_id = ?";
+         $sth = $dbh->prepare($select)
+             or do_log(0, sprintf("Maia: [cleanup] Couldn't prepare query: %s", $dbh->errstr));
+         $sth->execute($mail_id)
+             or do_log(0, sprintf("Maia: [cleanup] Couldn't execute query: %s", $dbh->errstr));
+         if (!(@row = $sth->fetchrow_array())) {
+             do_log(3, sprintf("Maia: [cleanup] Unwanted mail item %ld (no registered recipients)", $mail_id));
+             maia_delete_mail($dbh, $mail_id);
+         }
+         $sth->finish;
+     }
+     section_time("maia_cleanup");
+ }
+ 
+ 
+ # sets a recipient's mail status for a given e-mail to:
+ #   Suspected (S)pam
+ #   Suspected (H)am
+ #   (V)irus
+ #   (B)ad header
+ #   banned (F)ile
+ #   b(L)acklisted sender
+ #   (W)hitelisted sender
+ sub maia_set_mail_status($$$$$$$) {
+     my($dbh, $mail_id, $user_id, $enable_stats_tracking,
+        $enable_false_negative_management, $enable_spamtraps, $status) = @_;
+     my($update, $select, $insert, $delete, $sth, @row, $status_text);
+     my $is_a_spamtrap = 0;
+ 
+     $status = $1 if $status =~ /^([SVHBFLW])$/si; # untaint
+     $status = untaint($status);
+     $mail_id = $1 if $mail_id =~ /^([1-9]+[0-9]*)$/si; # untaint
+     $mail_id = untaint($mail_id);
+     $user_id = $1 if $user_id =~ /^([1-9]+[0-9]*)$/si; # untaint
+     $user_id = untaint($user_id);
+ 
+     if ($enable_spamtraps) {
+ 
+         # Is this recipient a spam-trap account?
+         $select = "SELECT spamtrap FROM maia_users WHERE id = ?";
+         $sth = $dbh->prepare($select)
+             or do_log(0, sprintf("Maia: [set_mail_status] Couldn't prepare query: %s", $dbh->errstr));
+         $sth->execute($user_id)
+             or do_log(0, sprintf("Maia: [set_mail_status] Couldn't execute query: %s", $dbh->errstr));
+         if (@row = $sth->fetchrow_array()) {
+             $is_a_spamtrap = ($row[0] =~ /^Y$/si);
+         }
+         $sth->finish;
+ 
+         # If it is, then *everything* it receives is treated
+         # as (C)onfirmed Spam!
+         if ($is_a_spamtrap) {
+             $status = "C";
+         }
+ 
+     }
+ 
+     if ($status =~ /^L$/si) { # blacklisted sender
+ 
+         do_log(3, sprintf("Maia: [set_mail_status] Blacklisted sender's mail item (id = %ld) ignored by recipient %ld",
+                           $mail_id, $user_id));
+         $delete = "DELETE FROM maia_mail_recipients WHERE mail_id = ? AND recipient_id = ?";
+         $sth = $dbh->prepare($delete)
+             or do_log(0, sprintf("Maia: [set_mail_status] Couldn't prepare query: %s", $dbh->errstr));
+         $sth->execute($mail_id, $user_id)
+             or do_log(0, sprintf("Maia: [set_mail_status] Couldn't execute query: %s", $dbh->errstr));
+ 
+     } elsif ($status =~ /^W$/si) { # whitelisted sender
+ 
+         do_log(3, sprintf("Maia: [set_mail_status] Sender of mail item (id = %ld) is whitelisted by recipient %ld",
+                           $mail_id, $user_id));
+         $delete = "DELETE FROM maia_mail_recipients WHERE mail_id = ? AND recipient_id = ?";
+         $sth = $dbh->prepare($delete)
+             or do_log(0, sprintf("Maia: [set_mail_status] Couldn't prepare query: %s", $dbh->errstr));
+         $sth->execute($mail_id, $user_id)
+             or do_log(0, sprintf("Maia: [set_mail_status] Couldn't execute query: %s", $dbh->errstr));
+ 
+     } else {
+ 
+         # If we're not tracking false negatives, then
+         # Suspected Ham => Confirmed Ham
+         if (!$enable_false_negative_management) {
+             if ($status =~ /^H$/si) {
+                 $status = "G";
+             }
+         }
+ 
+         $update = "UPDATE maia_mail_recipients SET type = ? WHERE mail_id = ? AND recipient_id = ?";
+         $sth = $dbh->prepare($update)
+             or do_log(0, sprintf("Maia: [set_mail_status] Couldn't prepare query: %s", $dbh->errstr));
+         $sth->execute($status, $mail_id, $user_id)
+             or do_log(0, sprintf("Maia: [set_mail_status] Couldn't execute query: %s", $dbh->errstr));
+         if ($status =~ /^H$/si) {
+             $status_text = "PROBABLE HAM";
+         } elsif ($status =~ /^G$/si) {
+             $status_text = "CONFIRMED HAM";
+         } elsif ($status =~ /^S$/si) {
+             $status_text = "SUSPECTED SPAM";
+         } elsif ($status =~ /^C$/si) {
+             $status_text = "CONFIRMED SPAM";
+         } elsif ($status =~ /^V$/si) {
+             $status_text = "VIRUS-INFECTED";
+         } elsif ($status =~ /^B$/si) {
+             $status_text = "INVALID MAIL HEADER";
+         } elsif ($status =~ /^F$/si) {
+             $status_text = "BANNED FILE ATTACHMENT(S)";
+         } else {
+             $status_text = "UNKNOWN (" . $status . ")";
+         }
+         do_log(3, sprintf("Maia: [set_mail_status] Recording mail item %ld as %s for recipient %ld",
+                           $mail_id, $status_text, $user_id));
+     }
+ 
+     # Only update the stats tables if stats-tracking is enabled
+     if ($enable_stats_tracking) {
+ 
+         # Fetch some information about this mail item
+         my($received_date, $size, $score);
+         $select = "SELECT received_date, size, score FROM maia_mail WHERE id = ?";
+         $sth = $dbh->prepare($select)
+             or do_log(0, sprintf("Maia: [set_mail_status] Couldn't prepare query: %s", $dbh->errstr));
+         $sth->execute($mail_id)
+             or do_log(0, sprintf("Maia: [set_mail_status] Couldn't execute query: %s", $dbh->errstr));
+         if (@row = $sth->fetchrow_array()) {
+             $received_date = $1 if $row[0] =~ /^(.*)$/si; # untaint
+             $received_date = untaint($received_date);
+             $size = $1 if $row[1] =~ /^([0-9]+)$/si; # untaint
+             $size = untaint($size);
+             $score = $1 if $row[2] =~ /^([0-9\-\.]+)$/si; # untaint
+             $score = untaint($score);
+         }
+         $sth->finish;
+ 
+         # Bad Header found
+         if ($status =~ /^B$/si) {
+ 
+             my($total_bad_header_items, $total_bad_header_size, $newest_bad_header_date);
+             my($oldest_bad_header_date, $smallest_bad_header_size, $largest_bad_header_size);
+             $select = "SELECT total_bad_header_items, " .
+                              "total_bad_header_size, " .
+                              "oldest_bad_header_date, " .
+                              "smallest_bad_header_size, " .
+                              "largest_bad_header_size " .
+                       "FROM maia_stats WHERE user_id = ?";
+             $sth = $dbh->prepare($select)
+                 or do_log(0, sprintf("Maia: [set_mail_status] Couldn't prepare query: %s", $dbh->errstr));
+             $sth->execute($user_id)
+                 or do_log(0, sprintf("Maia: [set_mail_status] Couldn't execute query: %s", $dbh->errstr));
+             if (@row = $sth->fetchrow_array()) {   # user already has a stats record, update it
+                 $total_bad_header_items = $1 if ($row[0] + 1) =~ /^([0-9]*)$/si; # untaint
+                 $total_bad_header_items = untaint($total_bad_header_items);
+                 if ($total_bad_header_items == 1) {
+                     $total_bad_header_size = $size;
+                     $smallest_bad_header_size = $size;
+                     $largest_bad_header_size = $size;
+                     $oldest_bad_header_date = $received_date;
+                     $newest_bad_header_date = $received_date;
+                 } else {
+                     $total_bad_header_size = $1 if ($row[1] + $size) =~ /^([0-9]*)$/si; # untaint
+                     $total_bad_header_size = untaint($total_bad_header_size);
+                     $newest_bad_header_date = $1 if $received_date =~ /^(.*)$/si; # untaint
+                     $newest_bad_header_date = untaint($newest_bad_header_date);
+                     $oldest_bad_header_date = $1 if $row[2] =~ /^(.*)$/si; # untaint
+                     $oldest_bad_header_date = untaint($oldest_bad_header_date);
+                     if ($oldest_bad_header_date == "") {
+                         $oldest_bad_header_date = $received_date;
+                     }
+                     $smallest_bad_header_size = $1 if $row[3] =~ /^([0-9]*)$/si; # untaint
+                     $smallest_bad_header_size = untaint($smallest_bad_header_size);
+                     if ($smallest_bad_header_size > $size) {
+                         $smallest_bad_header_size = $size;
+                     }
+                     $largest_bad_header_size = $1 if $row[4] =~ /^([0-9]*)$/si; # untaint
+                     $largest_bad_header_size = untaint($largest_bad_header_size);
+                     if ($largest_bad_header_size < $size) {
+                         $largest_bad_header_size = $size;
+                     }
+                 }
+                 $update = "UPDATE maia_stats SET total_bad_header_items = ?, " .
+                                                 "total_bad_header_size = ?, " .
+                                                 "newest_bad_header_date = ?, " .
+                                                 "oldest_bad_header_date = ?, " .
+                                                 "smallest_bad_header_size = ?, " .
+                                                 "largest_bad_header_size = ? " .
+                           "WHERE user_id = ?";
+                 $sth = $dbh->prepare($update)
+                     or do_log(0, sprintf("Maia: [set_mail_status] Couldn't prepare query: %s", $dbh->errstr));
+                 $sth->execute($total_bad_header_items,
+                               $total_bad_header_size,
+                               $newest_bad_header_date,
+                               $oldest_bad_header_date,
+                               $smallest_bad_header_size,
+                               $largest_bad_header_size,
+                               $user_id)
+                     or do_log(0, sprintf("Maia: [set_mail_status] Couldn't execute query: %s", $dbh->errstr));
+             } else {   # user has no stats record, create one
+                 $total_bad_header_size = $1 if $size =~ /^([0-9]*)$/si; # untaint
+                 $total_bad_header_size = untaint($total_bad_header_size);
+                 $smallest_bad_header_size = $total_bad_header_size;
+                 $largest_bad_header_size = $total_bad_header_size;
+                 $newest_bad_header_date = $1 if $received_date =~ /^(.*)$/si; # untaint
+                 $newest_bad_header_date = untaint($newest_bad_header_date);
+                 $oldest_bad_header_date = $newest_bad_header_date;
+                 $insert = "INSERT INTO maia_stats (user_id, " .
+                                                   "total_bad_header_items, " .
+                                                   "total_bad_header_size, " .
+                                                   "newest_bad_header_date, " .
+                                                   "oldest_bad_header_date, " .
+                                                   "smallest_bad_header_size, " .
+                                                   "largest_bad_header_size) " .
+                           "VALUES (?,1,?,?,?,?,?)";
+                 $sth = $dbh->prepare($insert)
+                     or do_log(0, sprintf("Maia: [set_mail_status] Couldn't prepare query: %s", $dbh->errstr));
+                 $sth->execute($user_id,
+                               $total_bad_header_size,
+                               $newest_bad_header_date,
+                               $oldest_bad_header_date,
+                               $smallest_bad_header_size,
+                               $largest_bad_header_size)
+                     or do_log(0, sprintf("Maia: [set_mail_status] Couldn't execute query: %s", $dbh->errstr));
+             }
+             $sth->finish;
+ 
+         # Banned File attachment found
+         } elsif ($status =~ /^F$/si) {
+ 
+             my($total_banned_file_items, $total_banned_file_size, $newest_banned_file_date);
+             my($oldest_banned_file_date, $smallest_banned_file_size, $largest_banned_file_size);
+             $select = "SELECT total_banned_file_items, " .
+                              "total_banned_file_size, " .
+                              "oldest_banned_file_date, " .
+                              "smallest_banned_file_size, " .
+                              "largest_banned_file_size " .
+                       "FROM maia_stats WHERE user_id = ?";
+             $sth = $dbh->prepare($select)
+                 or do_log(0, sprintf("Maia: [set_mail_status] Couldn't prepare query: %s", $dbh->errstr));
+             $sth->execute($user_id)
+                 or do_log(0, sprintf("Maia: [set_mail_status] Couldn't execute query: %s", $dbh->errstr));
+             if (@row = $sth->fetchrow_array()) {   # user already has a stats record, update it
+                 $total_banned_file_items = $1 if ($row[0] + 1) =~ /^([0-9]*)$/si; # untaint
+                 $total_banned_file_items = untaint($total_banned_file_items);
+                 if ($total_banned_file_items == 1) {
+                     $total_banned_file_size = $size;
+                     $smallest_banned_file_size = $size;
+                     $largest_banned_file_size = $size;
+                     $oldest_banned_file_date = $received_date;
+                     $newest_banned_file_date = $received_date;
+                 } else {
+                     $total_banned_file_size = $1 if ($row[1] + $size) =~ /^([0-9]*)$/si; # untaint
+                     $total_banned_file_size = untaint($total_banned_file_size);
+                     $newest_banned_file_date = $1 if $received_date =~ /^(.*)$/si; # untaint
+                     $newest_banned_file_date = untaint($newest_banned_file_date);
+                     $oldest_banned_file_date = $1 if $row[2] =~ /^(.*)$/si; # untaint
+                     $oldest_banned_file_date = untaint($oldest_banned_file_date);
+                     if ($oldest_banned_file_date == "") {
+                         $oldest_banned_file_date = $received_date;
+                     }
+                     $smallest_banned_file_size = $1 if $row[3] =~ /^([0-9]*)$/si; # untaint
+                     $smallest_banned_file_size = untaint($smallest_banned_file_size);
+                     if ($smallest_banned_file_size > $size) {
+                         $smallest_banned_file_size = $size;
+                     }
+                     $largest_banned_file_size = $1 if $row[4] =~ /^([0-9]*)$/si; # untaint
+                     $largest_banned_file_size = untaint($largest_banned_file_size);
+                     if ($largest_banned_file_size < $size) {
+                         $largest_banned_file_size = $size;
+                     }
+                 }
+                 $update = "UPDATE maia_stats SET total_banned_file_items = ?, " .
+                                                 "total_banned_file_size = ?, " .
+                                                 "newest_banned_file_date = ?, " .
+                                                 "oldest_banned_file_date = ?, " .
+                                                 "smallest_banned_file_size = ?, " .
+                                                 "largest_banned_file_size = ? " .
+                           "WHERE user_id = ?";
+                 $sth = $dbh->prepare($update)
+                     or do_log(0, sprintf("Maia: [set_mail_status] Couldn't prepare query: %s", $dbh->errstr));
+                 $sth->execute($total_banned_file_items,
+                               $total_banned_file_size,
+                               $newest_banned_file_date,
+                               $oldest_banned_file_date,
+                               $smallest_banned_file_size,
+                               $largest_banned_file_size,
+                               $user_id)
+                     or do_log(0, sprintf("Maia: [set_mail_status] Couldn't execute query: %s", $dbh->errstr));
+             } else {   # user has no stats record, create one
+                 $total_banned_file_size = $1 if $size =~ /^([0-9]*)$/si; # untaint
+                 $total_banned_file_size = untaint($total_banned_file_size);
+                 $smallest_banned_file_size = $total_banned_file_size;
+                 $largest_banned_file_size = $total_banned_file_size;
+                 $newest_banned_file_date = $1 if $received_date =~ /^(.*)$/si; # untaint
+                 $newest_banned_file_date = untaint($newest_banned_file_date);
+                 $oldest_banned_file_date = $newest_banned_file_date;
+                 $insert = "INSERT INTO maia_stats (user_id, " .
+                                                   "total_banned_file_items, " .
+                                                   "total_banned_file_size, " .
+                                                   "newest_banned_file_date, " .
+                                                   "oldest_banned_file_date, " .
+                                                   "smallest_banned_file_size, " .
+                                                   "largest_banned_file_size) " .
+                           "VALUES (?,1,?,?,?,?,?)";
+                 $sth = $dbh->prepare($insert)
+                     or do_log(0, sprintf("Maia: [set_mail_status] Couldn't prepare query: %s", $dbh->errstr));
+                 $sth->execute($user_id,
+                               $total_banned_file_size,
+                               $newest_banned_file_date,
+                               $oldest_banned_file_date,
+                               $smallest_banned_file_size,
+                               $largest_banned_file_size)
+                     or do_log(0, sprintf("Maia: [set_mail_status] Couldn't execute query: %s", $dbh->errstr));
+             }
+             $sth->finish;
+ 
+         # Virus(es) found
+         } elsif ($status =~ /^V$/si) {
+ 
+             my($total_virus_items, $total_virus_size, $newest_virus_date);
+             my($oldest_virus_date, $smallest_virus_size, $largest_virus_size);
+             $select = "SELECT total_virus_items, " .
+                              "total_virus_size, " .
+                              "oldest_virus_date, " .
+                              "smallest_virus_size, " .
+                              "largest_virus_size " .
+                       "FROM maia_stats WHERE user_id = ?";
+             $sth = $dbh->prepare($select)
+                 or do_log(0, sprintf("Maia: [set_mail_status] Couldn't prepare query: %s", $dbh->errstr));
+             $sth->execute($user_id)
+                 or do_log(0, sprintf("Maia: [set_mail_status] Couldn't execute query: %s", $dbh->errstr));
+             if (@row = $sth->fetchrow_array()) {   # user already has a stats record, update it
+                 $total_virus_items = $1 if ($row[0] + 1) =~ /^([0-9]*)$/si; # untaint
+                 $total_virus_items = untaint($total_virus_items);
+                 if ($total_virus_items == 1) {
+                     $total_virus_size = $size;
+                     $smallest_virus_size = $size;
+                     $largest_virus_size = $size;
+                     $oldest_virus_date = $received_date;
+                     $newest_virus_date = $received_date;
+                 } else {
+                     $total_virus_size = $1 if ($row[1] + $size) =~ /^([0-9]*)$/si; # untaint
+                     $total_virus_size = untaint($total_virus_size);
+                     $newest_virus_date = $1 if $received_date =~ /^(.*)$/si; # untaint
+                     $newest_virus_date = untaint($newest_virus_date);
+                     $oldest_virus_date = $1 if $row[2] =~ /^(.*)$/si; # untaint
+                     $oldest_virus_date = untaint($oldest_virus_date);
+                     if ($oldest_virus_date == "") {
+                         $oldest_virus_date = $received_date;
+                     }
+                     $smallest_virus_size = $1 if $row[3] =~ /^([0-9]*)$/si; # untaint
+                     $smallest_virus_size = untaint($smallest_virus_size);
+                     if ($smallest_virus_size > $size) {
+                         $smallest_virus_size = $size;
+                     }
+                     $largest_virus_size = $1 if $row[4] =~ /^([0-9]*)$/si; # untaint
+                     $largest_virus_size = untaint($largest_virus_size);
+                     if ($largest_virus_size < $size) {
+                         $largest_virus_size = $size;
+                     }
+                 }
+                 $update = "UPDATE maia_stats SET total_virus_items = ?, " .
+                                                 "total_virus_size = ?, " .
+                                                 "newest_virus_date = ?, " .
+                                                 "oldest_virus_date = ?, " .
+                                                 "smallest_virus_size = ?, " .
+                                                 "largest_virus_size = ? " .
+                           "WHERE user_id = ?";
+                 $sth = $dbh->prepare($update)
+                     or do_log(0, sprintf("Maia: [set_mail_status] Couldn't prepare query: %s", $dbh->errstr));
+                 $sth->execute($total_virus_items,
+                               $total_virus_size,
+                               $newest_virus_date,
+                               $oldest_virus_date,
+                               $smallest_virus_size,
+                               $largest_virus_size,
+                               $user_id)
+                     or do_log(0, sprintf("Maia: [set_mail_status] Couldn't execute query: %s", $dbh->errstr));
+             } else {   # user has no stats record, create one
+                 $total_virus_size = $1 if $size =~ /^([0-9]*)$/si; # untaint
+                 $total_virus_size = untaint($total_virus_size);
+                 $smallest_virus_size = $total_virus_size;
+                 $largest_virus_size = $total_virus_size;
+                 $newest_virus_date = $1 if $received_date =~ /^(.*)$/si; # untaint
+                 $newest_virus_date = untaint($newest_virus_date);
+                 $oldest_virus_date = $newest_virus_date;
+                 $insert = "INSERT INTO maia_stats (user_id, " .
+                                                   "total_virus_items, " .
+                                                   "total_virus_size, " .
+                                                   "newest_virus_date, " .
+                                                   "oldest_virus_date, " .
+                                                   "smallest_virus_size, " .
+                                                   "largest_virus_size) " .
+                           "VALUES (?,1,?,?,?,?,?)";
+                 $sth = $dbh->prepare($insert)
+                     or do_log(0, sprintf("Maia: [set_mail_status] Couldn't prepare query: %s", $dbh->errstr));
+                 $sth->execute($user_id,
+                               $total_virus_size,
+                               $newest_virus_date,
+                               $oldest_virus_date,
+                               $smallest_virus_size,
+                               $largest_virus_size)
+                     or do_log(0, sprintf("Maia: [set_mail_status] Couldn't execute query: %s", $dbh->errstr));
+             }
+             $sth->finish;
+ 
+         # Suspected spam
+         } elsif ($status =~ /^S$/si) {
+ 
+             my($total_suspected_spam_items, $total_suspected_spam_size, $newest_suspected_spam_date);
+             my($oldest_suspected_spam_date, $smallest_suspected_spam_size, $largest_suspected_spam_size);
+             my($total_suspected_spam_score, $lowest_suspected_spam_score, $highest_suspected_spam_score);
+             $select = "SELECT total_suspected_spam_items, " .
+                              "total_suspected_spam_size, " .
+                              "oldest_suspected_spam_date, " .
+                              "smallest_suspected_spam_size, " .
+                              "largest_suspected_spam_size, " .
+                              "total_suspected_spam_score, " .
+                              "lowest_suspected_spam_score, " .
+                              "highest_suspected_spam_score " .
+                       "FROM maia_stats WHERE user_id = ?";
+             $sth = $dbh->prepare($select)
+                 or do_log(0, sprintf("Maia: [set_mail_status] Couldn't prepare query: %s", $dbh->errstr));
+             $sth->execute($user_id)
+                 or do_log(0, sprintf("Maia: [set_mail_status] Couldn't execute query: %s", $dbh->errstr));
+             if (@row = $sth->fetchrow_array()) {   # user already has a stats record, update it
+                 $total_suspected_spam_items = $1 if ($row[0] + 1) =~ /^([0-9]*)$/si; # untaint
+                 $total_suspected_spam_items = untaint($total_suspected_spam_items);
+                 if ($total_suspected_spam_items == 1) {
+                     $total_suspected_spam_size = $size;
+                     $smallest_suspected_spam_size = $size;
+                     $largest_suspected_spam_size = $size;
+                     $total_suspected_spam_score = $score;
+                     $lowest_suspected_spam_score = $score;
+                     $highest_suspected_spam_score = $score;
+                     $oldest_suspected_spam_date = $received_date;
+                     $newest_suspected_spam_date = $received_date;
+                 } else {
+                     $total_suspected_spam_size = $1 if ($row[1] + $size) =~ /^([0-9]*)$/si; # untaint
+                     $total_suspected_spam_size = untaint($total_suspected_spam_size);
+                     $newest_suspected_spam_date = $1 if $received_date =~ /^(.*)$/si; # untaint
+                     $newest_suspected_spam_date = untaint($newest_suspected_spam_date);
+                     $oldest_suspected_spam_date = $1 if $row[2] =~ /^(.*)$/si; # untaint
+                     $oldest_suspected_spam_date = untaint($oldest_suspected_spam_date);
+                     if ($oldest_suspected_spam_date == "") {
+                         $oldest_suspected_spam_date = $received_date;
+                     }
+                     $smallest_suspected_spam_size = $1 if $row[3] =~ /^([0-9]*)$/si; # untaint
+                     $smallest_suspected_spam_size = untaint($smallest_suspected_spam_size);
+                     if ($smallest_suspected_spam_size > $size) {
+                         $smallest_suspected_spam_size = $size;
+                     }
+                     $largest_suspected_spam_size = $1 if $row[4] =~ /^([0-9]*)$/si; # untaint
+                     $largest_suspected_spam_size = untaint($largest_suspected_spam_size);
+                     if ($largest_suspected_spam_size < $size) {
+                         $largest_suspected_spam_size = $size;
+                     }
+ 
+                     $total_suspected_spam_score = $1 if ($row[5] + $score) =~ /^([0-9\-\.]*)$/si; # untaint
+                     $total_suspected_spam_score = untaint($total_suspected_spam_score);
+                     $lowest_suspected_spam_score = $1 if $row[6] =~ /^([0-9\-\.]*)$/si; # untaint
+                     $lowest_suspected_spam_score = untaint($lowest_suspected_spam_score);
+                     if ($lowest_suspected_spam_score > $score) {
+                         $lowest_suspected_spam_score = $score;
+                     }
+                     $highest_suspected_spam_score = $1 if $row[7] =~ /^([0-9\-\.]*)$/si; # untaint
+                     $highest_suspected_spam_score = untaint($highest_suspected_spam_score);
+                     if ($highest_suspected_spam_score < $score) {
+                         $highest_suspected_spam_score = $score;
+                     }
+                 }
+                 $update = "UPDATE maia_stats SET total_suspected_spam_items = ?, " .
+                                                 "total_suspected_spam_size = ?, " .
+                                                 "newest_suspected_spam_date = ?, " .
+                                                 "oldest_suspected_spam_date = ?, " .
+                                                 "smallest_suspected_spam_size = ?, " .
+                                                 "largest_suspected_spam_size = ?, " .
+                                                 "total_suspected_spam_score = ?, " .
+                                                 "lowest_suspected_spam_score = ?, " .
+                                                 "highest_suspected_spam_score = ? " .
+                           "WHERE user_id = ?";
+                 $sth = $dbh->prepare($update)
+                     or do_log(0, sprintf("Maia: [set_mail_status] Couldn't prepare query: %s", $dbh->errstr));
+                 $sth->execute($total_suspected_spam_items,
+                               $total_suspected_spam_size,
+                               $newest_suspected_spam_date,
+                               $oldest_suspected_spam_date,
+                               $smallest_suspected_spam_size,
+                               $largest_suspected_spam_size,
+                               $total_suspected_spam_score,
+                               $lowest_suspected_spam_score,
+                               $highest_suspected_spam_score,
+                               $user_id)
+                     or do_log(0, sprintf("Maia: [set_mail_status] Couldn't execute query: %s", $dbh->errstr));
+             } else {   # user has no stats record, create one
+                 $total_suspected_spam_size = $1 if $size =~ /^([0-9]*)$/si; # untaint
+                 $total_suspected_spam_size = untaint($total_suspected_spam_size);
+                 $smallest_suspected_spam_size = $total_suspected_spam_size;
+                 $largest_suspected_spam_size = $total_suspected_spam_size;
+                 $newest_suspected_spam_date = $1 if $received_date =~ /^(.*)$/si; # untaint
+                 $newest_suspected_spam_date = untaint($newest_suspected_spam_date);
+                 $oldest_suspected_spam_date = $newest_suspected_spam_date;
+                 $insert = "INSERT INTO maia_stats (user_id, " .
+                                                   "total_suspected_spam_items, " .
+                                                   "total_suspected_spam_size, " .
+                                                   "newest_suspected_spam_date, " .
+                                                   "oldest_suspected_spam_date, " .
+                                                   "smallest_suspected_spam_size, " .
+                                                   "largest_suspected_spam_size, " .
+                                                   "total_suspected_spam_score, " .
+                                                   "lowest_suspected_spam_score, " .
+                                                   "highest_suspected_spam_score) " .
+                           "VALUES (?,1,?,?,?,?,?,?,?,?)";
+                 $sth = $dbh->prepare($insert)
+                     or do_log(0, sprintf("Maia: [set_mail_status] Couldn't prepare query: %s", $dbh->errstr));
+                 $sth->execute($user_id,
+                               $total_suspected_spam_size,
+                               $newest_suspected_spam_date,
+                               $oldest_suspected_spam_date,
+                               $smallest_suspected_spam_size,
+                               $largest_suspected_spam_size,
+                               $score,
+                               $score,
+                               $score)
+                     or do_log(0, sprintf("Maia: [set_mail_status] Couldn't execute query: %s", $dbh->errstr));
+             }
+             $sth->finish;
+ 
+         # Confirmed Spam (e.g. in a spam-trap)
+         } elsif ($status =~ /^C$/si) {
+ 
+             if ($score eq undef) {
+                 $score = 0.0;
+             }
+             my($total_spam_items, $total_spam_size, $newest_spam_date);
+             my($oldest_spam_date, $smallest_spam_size, $largest_spam_size);
+             my($total_spam_score, $lowest_spam_score, $highest_spam_score);
+             $select = "SELECT total_spam_items, " .
+                              "total_spam_size, " .
+                              "oldest_spam_date, " .
+                              "smallest_spam_size, " .
+                              "largest_spam_size, " .
+                              "total_spam_score, " .
+                              "lowest_spam_score, " .
+                              "highest_spam_score " .
+                       "FROM maia_stats WHERE user_id = ?";
+             $sth = $dbh->prepare($select)
+                 or do_log(0, sprintf("Maia: [set_mail_status] Couldn't prepare query: %s", $dbh->errstr));
+             $sth->execute($user_id)
+                 or do_log(0, sprintf("Maia: [set_mail_status] Couldn't execute query: %s", $dbh->errstr));
+             if (@row = $sth->fetchrow_array()) {   # user already has a stats record, update it
+                 $total_spam_items = $1 if ($row[0] + 1) =~ /^([0-9]*)$/si; # untaint
+                 $total_spam_items = untaint($total_spam_items);
+                 if ($total_spam_items == 1) {
+                     $total_spam_size = $size;
+                     $smallest_spam_size = $size;
+                     $largest_spam_size = $size;
+                     $total_spam_score = $score;
+                     $lowest_spam_score = $score;
+                     $highest_spam_score = $score;
+                     $oldest_spam_date = $received_date;
+                     $newest_spam_date = $received_date;
+                 } else {
+                     $total_spam_size = $1 if ($row[1] + $size) =~ /^([0-9]*)$/si; # untaint
+                     $total_spam_size = untaint($total_spam_size);
+                     $newest_spam_date = $1 if $received_date =~ /^(.*)$/si; # untaint
+                     $newest_spam_date = untaint($newest_spam_date);
+                     $oldest_spam_date = $1 if $row[2] =~ /^(.*)$/si; # untaint
+                     $oldest_spam_date = untaint($oldest_spam_date);
+                     if ($oldest_spam_date == "") {
+                         $oldest_spam_date = $received_date;
+                     }
+                     $smallest_spam_size = $1 if $row[3] =~ /^([0-9]*)$/si; # untaint
+                     $smallest_spam_size = untaint($smallest_spam_size);
+                     if ($smallest_spam_size > $size) {
+                         $smallest_spam_size = $size;
+                     }
+                     $largest_spam_size = $1 if $row[4] =~ /^([0-9]*)$/si; # untaint
+                     $largest_spam_size = untaint($largest_spam_size);
+                     if ($largest_spam_size < $size) {
+                         $largest_spam_size = $size;
+                     }
+ 
+                     $total_spam_score = $1 if ($row[5] + $score) =~ /^([0-9\-\.]*)$/si; # untaint
+                     $total_spam_score = untaint($total_spam_score);
+                     $lowest_spam_score = $1 if $row[6] =~ /^([0-9\-\.]*)$/si; # untaint
+                     $lowest_spam_score = untaint($lowest_spam_score);
+                     if ($lowest_spam_score > $score) {
+                         $lowest_spam_score = $score;
+                     }
+                     $highest_spam_score = $1 if $row[7] =~ /^([0-9\-\.]*)$/si; # untaint
+                     $highest_spam_score = untaint($highest_spam_score);
+                     if ($highest_spam_score < $score) {
+                         $highest_spam_score = $score;
+                     }
+                 }
+                 $update = "UPDATE maia_stats SET total_spam_items = ?, " .
+                                                 "total_spam_size = ?, " .
+                                                 "newest_spam_date = ?, " .
+                                                 "oldest_spam_date = ?, " .
+                                                 "smallest_spam_size = ?, " .
+                                                 "largest_spam_size = ?, " .
+                                                 "total_spam_score = ?, " .
+                                                 "lowest_spam_score = ?, " .
+                                                 "highest_spam_score = ? " .
+                           "WHERE user_id = ?";
+                 $sth = $dbh->prepare($update)
+                     or do_log(0, sprintf("Maia: [set_mail_status] Couldn't prepare query: %s", $dbh->errstr));
+                 $sth->execute($total_spam_items,
+                               $total_spam_size,
+                               $newest_spam_date,
+                               $oldest_spam_date,
+                               $smallest_spam_size,
+                               $largest_spam_size,
+                               $total_spam_score,
+                               $lowest_spam_score,
+                               $highest_spam_score,
+                               $user_id)
+                     or do_log(0, sprintf("Maia: [set_mail_status] Couldn't execute query: %s", $dbh->errstr));
+             } else {   # user has no stats record, create one
+                 $total_spam_size = $1 if $size =~ /^([0-9]*)$/si; # untaint
+                 $total_spam_size = untaint($total_spam_size);
+                 $smallest_spam_size = $total_spam_size;
+                 $largest_spam_size = $total_spam_size;
+                 $newest_spam_date = $1 if $received_date =~ /^(.*)$/si; # untaint
+                 $newest_spam_date = untaint($newest_spam_date);
+                 $oldest_spam_date = $newest_spam_date;
+                 $insert = "INSERT INTO maia_stats (user_id, " .
+                                                   "total_spam_items, " .
+                                                   "total_spam_size, " .
+                                                   "newest_spam_date, " .
+                                                   "oldest_spam_date, " .
+                                                   "smallest_spam_size, " .
+                                                   "largest_spam_size, " .
+                                                   "total_spam_score, " .
+                                                   "lowest_spam_score, " .
+                                                   "highest_spam_score) " .
+                           "VALUES (?,1,?,?,?,?,?,?,?,?)";
+                 $sth = $dbh->prepare($insert)
+                     or do_log(0, sprintf("Maia: [set_mail_status] Couldn't prepare query: %s", $dbh->errstr));
+                 $sth->execute($user_id,
+                               $total_spam_size,
+                               $newest_spam_date,
+                               $oldest_spam_date,
+                               $smallest_spam_size,
+                               $largest_spam_size,
+                               $score,
+                               $score,
+                               $score)
+                     or do_log(0, sprintf("Maia: [set_mail_status] Couldn't execute query: %s", $dbh->errstr));
+             }
+             $sth->finish;
+ 
+         # Suspected Ham
+         } elsif ($status =~ /^H$/si) {
+ 
+             my($total_suspected_ham_items, $total_suspected_ham_size, $newest_suspected_ham_date);
+             my($oldest_suspected_ham_date, $smallest_suspected_ham_size, $largest_suspected_ham_size);
+             my($total_suspected_ham_score, $lowest_suspected_ham_score, $highest_suspected_ham_score);
+             $select = "SELECT total_suspected_ham_items, " .
+                              "total_suspected_ham_size, " .
+                              "oldest_suspected_ham_date, " .
+                              "smallest_suspected_ham_size, " .
+                              "largest_suspected_ham_size, " .
+                              "total_suspected_ham_score, " .
+                              "lowest_suspected_ham_score, " .
+                              "highest_suspected_ham_score " .
+                       "FROM maia_stats WHERE user_id = ?";
+             $sth = $dbh->prepare($select)
+                 or do_log(0, sprintf("Maia: [set_mail_status] Couldn't prepare query: %s", $dbh->errstr));
+             $sth->execute($user_id)
+                 or do_log(0, sprintf("Maia: [set_mail_status] Couldn't execute query: %s", $dbh->errstr));
+             if (@row = $sth->fetchrow_array()) {   # user already has a stats record, update it
+                 $total_suspected_ham_items = $1 if ($row[0] + 1) =~ /^([0-9]*)$/si; # untaint
+                 $total_suspected_ham_items = untaint($total_suspected_ham_items);
+                 if ($total_suspected_ham_items == 1) {
+                     $total_suspected_ham_size = $size;
+                     $smallest_suspected_ham_size = $size;
+                     $largest_suspected_ham_size = $size;
+                     $total_suspected_ham_score = $score;
+                     $lowest_suspected_ham_score = $score;
+                     $highest_suspected_ham_score = $score;
+                     $oldest_suspected_ham_date = $received_date;
+                     $newest_suspected_ham_date = $received_date;
+                 } else {
+                     $total_suspected_ham_size = $1 if ($row[1] + $size) =~ /^([0-9]*)$/si; # untaint
+                     $total_suspected_ham_size = untaint($total_suspected_ham_size);
+                     $newest_suspected_ham_date = $1 if $received_date =~ /^(.*)$/si; # untaint
+                     $newest_suspected_ham_date = untaint($newest_suspected_ham_date);
+                     $oldest_suspected_ham_date = $1 if $row[2] =~ /^(.*)$/si; # untaint
+                     $oldest_suspected_ham_date = untaint($oldest_suspected_ham_date);
+                     if ($oldest_suspected_ham_date == "") {
+                         $oldest_suspected_ham_date = $received_date;
+                     }
+                     $smallest_suspected_ham_size = $1 if $row[3] =~ /^([0-9]*)$/si; # untaint
+                     $smallest_suspected_ham_size = untaint($smallest_suspected_ham_size);
+                     if ($smallest_suspected_ham_size > $size) {
+                         $smallest_suspected_ham_size = $size;
+                     }
+                     $largest_suspected_ham_size = $1 if $row[4] =~ /^([0-9]*)$/si; # untaint
+                     $largest_suspected_ham_size = untaint($largest_suspected_ham_size);
+                     if ($largest_suspected_ham_size < $size) {
+                         $largest_suspected_ham_size = $size;
+                     }
+                     $total_suspected_ham_score = $1 if $row[5] =~ /^([0-9\-\.]*)$/si; # untaint
+                     $total_suspected_ham_score = untaint($total_suspected_ham_score);
+                     $total_suspected_ham_score += $score;
+                     $lowest_suspected_ham_score = $1 if $row[6] =~ /^([0-9\-\.]*)$/si; # untaint
+                     $lowest_suspected_ham_score = untaint($lowest_suspected_ham_score);
+                     if ($lowest_suspected_ham_score > $score) {
+                         $lowest_suspected_ham_score = $score;
+                     }
+                     $highest_suspected_ham_score = $1 if $row[7] =~ /^([0-9\-\.]*)$/si; # untaint
+                     $highest_suspected_ham_score = untaint($highest_suspected_ham_score);
+                     if ($highest_suspected_ham_score < $score) {
+                         $highest_suspected_ham_score = $score;
+                     }
+                 }
+                 $update = "UPDATE maia_stats SET total_suspected_ham_items = ?, " .
+                                                 "total_suspected_ham_size = ?, " .
+                                                 "newest_suspected_ham_date = ?, " .
+                                                 "oldest_suspected_ham_date = ?, " .
+                                                 "smallest_suspected_ham_size = ?, " .
+                                                 "largest_suspected_ham_size = ?, " .
+                                                 "total_suspected_ham_score = ?, " .
+                                                 "lowest_suspected_ham_score = ?, " .
+                                                 "highest_suspected_ham_score = ? " .
+                           "WHERE user_id = ?";
+                 $sth = $dbh->prepare($update)
+                     or do_log(0, sprintf("Maia: [set_mail_status] Couldn't prepare query: %s", $dbh->errstr));
+                 $sth->execute($total_suspected_ham_items,
+                               $total_suspected_ham_size,
+                               $newest_suspected_ham_date,
+                               $oldest_suspected_ham_date,
+                               $smallest_suspected_ham_size,
+                               $largest_suspected_ham_size,
+                               $total_suspected_ham_score,
+                               $lowest_suspected_ham_score,
+                               $highest_suspected_ham_score,
+                               $user_id)
+                     or do_log(0, sprintf("Maia: [set_mail_status] Couldn't execute query: %s", $dbh->errstr));
+             } else {   # user has no stats record, create one
+                 $total_suspected_ham_size = $1 if $size =~ /^([0-9]*)$/si; # untaint
+                 $total_suspected_ham_size = untaint($total_suspected_ham_size);
+                 $smallest_suspected_ham_size = $total_suspected_ham_size;
+                 $largest_suspected_ham_size = $total_suspected_ham_size;
+                 $newest_suspected_ham_date = $1 if $received_date =~ /^(.*)$/si; # untaint
+                 $newest_suspected_ham_date = untaint($newest_suspected_ham_date);
+                 $oldest_suspected_ham_date = $newest_suspected_ham_date;
+                 $insert = "INSERT INTO maia_stats (user_id, " .
+                                                   "total_suspected_ham_items, " .
+                                                   "total_suspected_ham_size, " .
+                                                   "newest_suspected_ham_date, " .
+                                                   "oldest_suspected_ham_date, " .
+                                                   "smallest_suspected_ham_size, " .
+                                                   "largest_suspected_ham_size, " .
+                                                   "total_suspected_ham_score, " .
+                                                   "lowest_suspected_ham_score, " .
+                                                   "highest_suspected_ham_score) " .
+                           "VALUES (?,1,?,?,?,?,?,?,?,?)";
+                 $sth = $dbh->prepare($insert)
+                     or do_log(0, sprintf("Maia: [set_mail_status] Couldn't prepare query: %s", $dbh->errstr));
+                 $sth->execute($user_id,
+                               $total_suspected_ham_size,
+                               $newest_suspected_ham_date,
+                               $oldest_suspected_ham_date,
+                               $smallest_suspected_ham_size,
+                               $largest_suspected_ham_size,
+                               $score,
+                               $score,
+                               $score)
+                     or do_log(0, sprintf("Maia: [set_mail_status] Couldn't execute query: %s", $dbh->errstr));
+             }
+             $sth->finish;
+ 
+         # Confirmed Ham (e.g. false negative tracking is disabled)
+         } elsif ($status =~ /^G$/si) {
+ 
+             my($total_ham_items, $total_ham_size, $newest_ham_date);
+             my($oldest_ham_date, $smallest_ham_size, $largest_ham_size);
+             my($total_ham_score, $lowest_ham_score, $highest_ham_score);
+             $select = "SELECT total_ham_items, " .
+                              "total_ham_size, " .
+                              "oldest_ham_date, " .
+                              "smallest_ham_size, " .
+                              "largest_ham_size, " .
+                              "total_ham_score, " .
+                              "lowest_ham_score, " .
+                              "highest_ham_score " .
+                       "FROM maia_stats WHERE user_id = ?";
+             $sth = $dbh->prepare($select)
+                 or do_log(0, sprintf("Maia: [set_mail_status] Couldn't prepare query: %s", $dbh->errstr));
+             $sth->execute($user_id)
+                 or do_log(0, sprintf("Maia: [set_mail_status] Couldn't execute query: %s", $dbh->errstr));
+             if (@row = $sth->fetchrow_array()) {   # user already has a stats record, update it
+                 $total_ham_items = $1 if ($row[0] + 1) =~ /^([0-9]*)$/si; # untaint
+                 $total_ham_items = untaint($total_ham_items);
+                 if ($total_ham_items == 1) {
+                     $total_ham_size = $size;
+                     $smallest_ham_size = $size;
+                     $largest_ham_size = $size;
+                     $total_ham_score = $score;
+                     $lowest_ham_score = $score;
+                     $highest_ham_score = $score;
+                     $oldest_ham_date = $received_date;
+                     $newest_ham_date = $received_date;
+                 } else {
+                     $total_ham_size = $1 if ($row[1] + $size) =~ /^([0-9]*)$/si; # untaint
+                     $total_ham_size = untaint($total_ham_size);
+                     $newest_ham_date = $1 if $received_date =~ /^(.*)$/si; # untaint
+                     $newest_ham_date = untaint($newest_ham_date);
+                     $oldest_ham_date = $1 if $row[2] =~ /^(.*)$/si; # untaint
+                     $oldest_ham_date = untaint($oldest_ham_date);
+                     if ($oldest_ham_date == "") {
+                         $oldest_ham_date = $received_date;
+                     }
+                     $smallest_ham_size = $1 if $row[3] =~ /^([0-9]*)$/si; # untaint
+                     $smallest_ham_size = untaint($smallest_ham_size);
+                     if ($smallest_ham_size > $size) {
+                         $smallest_ham_size = $size;
+                     }
+                     $largest_ham_size = $1 if $row[4] =~ /^([0-9]*)$/si; # untaint
+                     $largest_ham_size = untaint($largest_ham_size);
+                     if ($largest_ham_size < $size) {
+                         $largest_ham_size = $size;
+                     }
+                     $total_ham_score = $1 if $row[5] =~ /^([0-9\-\.]*)$/si; # untaint
+                     $total_ham_score = untaint($total_ham_score);
+                     $total_ham_score += $score;
+                     $lowest_ham_score = $1 if $row[6] =~ /^([0-9\-\.]*)$/si; # untaint
+                     $lowest_ham_score = untaint($lowest_ham_score);
+                     if ($lowest_ham_score > $score) {
+                         $lowest_ham_score = $score;
+                     }
+                     $highest_ham_score = $1 if $row[7] =~ /^([0-9\-\.]*)$/si; # untaint
+                     $highest_ham_score = untaint($highest_ham_score);
+                     if ($highest_ham_score < $score) {
+                         $highest_ham_score = $score;
+                     }
+                 }
+                 $update = "UPDATE maia_stats SET total_ham_items = ?, " .
+                                                 "total_ham_size = ?, " .
+                                                 "newest_ham_date = ?, " .
+                                                 "oldest_ham_date = ?, " .
+                                                 "smallest_ham_size = ?, " .
+                                                 "largest_ham_size = ?, " .
+                                                 "total_ham_score = ?, " .
+                                                 "lowest_ham_score = ?, " .
+                                                 "highest_ham_score = ? " .
+                           "WHERE user_id = ?";
+                 $sth = $dbh->prepare($update)
+                     or do_log(0, sprintf("Maia: [set_mail_status] Couldn't prepare query: %s", $dbh->errstr));
+                 $sth->execute($total_ham_items,
+                               $total_ham_size,
+                               $newest_ham_date,
+                               $oldest_ham_date,
+                               $smallest_ham_size,
+                               $largest_ham_size,
+                               $total_ham_score,
+                               $lowest_ham_score,
+                               $highest_ham_score,
+                               $user_id)
+                     or do_log(0, sprintf("Maia: [set_mail_status] Couldn't execute query: %s", $dbh->errstr));
+             } else {   # user has no stats record, create one
+                 $total_ham_size = $1 if $size =~ /^([0-9]*)$/si; # untaint
+                 $total_ham_size = untaint($total_ham_size);
+                 $smallest_ham_size = $total_ham_size;
+                 $largest_ham_size = $total_ham_size;
+                 $newest_ham_date = $1 if $received_date =~ /^(.*)$/si; # untaint
+                 $newest_ham_date = untaint($newest_ham_date);
+                 $oldest_ham_date = $newest_ham_date;
+                 $insert = "INSERT INTO maia_stats (user_id, " .
+                                                   "total_ham_items, " .
+                                                   "total_ham_size, " .
+                                                   "newest_ham_date, " .
+                                                   "oldest_ham_date, " .
+                                                   "smallest_ham_size, " .
+                                                   "largest_ham_size, " .
+                                                   "total_ham_score, " .
+                                                   "lowest_ham_score, " .
+                                                   "highest_ham_score) " .
+                           "VALUES (?,1,?,?,?,?,?,?,?,?)";
+                 $sth = $dbh->prepare($insert)
+                     or do_log(0, sprintf("Maia: [set_mail_status] Couldn't prepare query: %s", $dbh->errstr));
+                 $sth->execute($user_id,
+                               $total_ham_size,
+                               $newest_ham_date,
+                               $oldest_ham_date,
+                               $smallest_ham_size,
+                               $largest_ham_size,
+                               $score,
+                               $score,
+                               $score)
+                     or do_log(0, sprintf("Maia: [set_mail_status] Couldn't execute query: %s", $dbh->errstr));
+             }
+             $sth->finish;
+ 
+         # Whitelisted sender
+         } elsif ($status =~ /^W$/si) {
+ 
+             my($total_wl_items, $total_wl_size, $newest_wl_date);
+             my($oldest_wl_date, $smallest_wl_size, $largest_wl_size);
+             $select = "SELECT total_wl_items, " .
+                              "total_wl_size, " .
+                              "oldest_wl_date, " .
+                              "smallest_wl_size, " .
+                              "largest_wl_size " .
+                       "FROM maia_stats WHERE user_id = ?";
+             $sth = $dbh->prepare($select)
+                 or do_log(0, sprintf("Maia: [set_mail_status] Couldn't prepare query: %s", $dbh->errstr));
+             $sth->execute($user_id)
+                 or do_log(0, sprintf("Maia: [set_mail_status] Couldn't execute query: %s", $dbh->errstr));
+             if (@row = $sth->fetchrow_array()) {   # user already has a stats record, update it
+                 $total_wl_items = $1 if ($row[0] + 1) =~ /^([0-9]*)$/si; # untaint
+                 $total_wl_items = untaint($total_wl_items);
+                 if ($total_wl_items == 1) {
+                     $total_wl_size = $size;
+                     $smallest_wl_size = $size;
+                     $largest_wl_size = $size;
+                     $oldest_wl_date = $received_date;
+                     $newest_wl_date = $received_date;
+                 } else {
+                     $total_wl_size = $1 if ($row[1] + $size) =~ /^([0-9]*)$/si; # untaint
+                     $total_wl_size = untaint($total_wl_size);
+                     $newest_wl_date = $1 if $received_date =~ /^(.*)$/si; # untaint
+                     $newest_wl_date = untaint($newest_wl_date);
+                     $oldest_wl_date = $1 if $row[2] =~ /^(.*)$/si; # untaint
+                     $oldest_wl_date = untaint($oldest_wl_date);
+                     if ($oldest_wl_date == "") {
+                         $oldest_wl_date = $received_date;
+                     }
+                     $smallest_wl_size = $1 if $row[3] =~ /^([0-9]*)$/si; # untaint
+                     $smallest_wl_size = untaint($smallest_wl_size);
+                     if ($smallest_wl_size > $size) {
+                         $smallest_wl_size = $size;
+                     }
+                     $largest_wl_size = $1 if $row[4] =~ /^([0-9]*)$/si; # untaint
+                     $largest_wl_size = untaint($largest_wl_size);
+                     if ($largest_wl_size < $size) {
+                         $largest_wl_size = $size;
+                     }
+                 }
+                 $update = "UPDATE maia_stats SET total_wl_items = ?, " .
+                                                 "total_wl_size = ?, " .
+                                                 "newest_wl_date = ?, " .
+                                                 "oldest_wl_date = ?, " .
+                                                 "smallest_wl_size = ?, " .
+                                                 "largest_wl_size = ? " .
+                           "WHERE user_id = ?";
+                 $sth = $dbh->prepare($update)
+                     or do_log(0, sprintf("Maia: [set_mail_status] Couldn't prepare query: %s", $dbh->errstr));
+                 $sth->execute($total_wl_items,
+                               $total_wl_size,
+                               $newest_wl_date,
+                               $oldest_wl_date,
+                               $smallest_wl_size,
+                               $largest_wl_size,
+                               $user_id)
+                     or do_log(0, sprintf("Maia: [set_mail_status] Couldn't execute query: %s", $dbh->errstr));
+             } else {   # user has no stats record, create one
+                 $total_wl_size = $1 if $size =~ /^([0-9]*)$/si; # untaint
+                 $total_wl_size = untaint($total_wl_size);
+                 $smallest_wl_size = $total_wl_size;
+                 $largest_wl_size = $total_wl_size;
+                 $newest_wl_date = $1 if $received_date =~ /^(.*)$/si; # untaint
+                 $newest_wl_date = untaint($newest_wl_date);
+                 $oldest_wl_date = $newest_wl_date;
+                 $insert = "INSERT INTO maia_stats (user_id, " .
+                                                   "total_wl_items, " .
+                                                   "total_wl_size, " .
+                                                   "newest_wl_date, " .
+                                                   "oldest_wl_date, " .
+                                                   "smallest_wl_size, " .
+                                                   "largest_wl_size) " .
+                           "VALUES (?,1,?,?,?,?,?)";
+                 $sth = $dbh->prepare($insert)
+                     or do_log(0, sprintf("Maia: [set_mail_status] Couldn't prepare query: %s", $dbh->errstr));
+                 $sth->execute($user_id,
+                               $total_wl_size,
+                               $newest_wl_date,
+                               $oldest_wl_date,
+                               $smallest_wl_size,
+                               $largest_wl_size)
+                     or do_log(0, sprintf("Maia: [set_mail_status] Couldn't execute query: %s", $dbh->errstr));
+             }
+             $sth->finish;
+ 
+         # Blacklisted sender
+         } elsif ($status =~ /^L$/si) {
+ 
+             my($total_bl_items, $total_bl_size, $newest_bl_date);
+             my($oldest_bl_date, $smallest_bl_size, $largest_bl_size);
+             $select = "SELECT total_bl_items, " .
+                              "total_bl_size, " .
+                              "oldest_bl_date, " .
+                              "smallest_bl_size, " .
+                              "largest_bl_size " .
+                       "FROM maia_stats WHERE user_id = ?";
+             $sth = $dbh->prepare($select)
+                 or do_log(0, sprintf("Maia: [set_mail_status] Couldn't prepare query: %s", $dbh->errstr));
+             $sth->execute($user_id)
+                 or do_log(0, sprintf("Maia: [set_mail_status] Couldn't execute query: %s", $dbh->errstr));
+             if (@row = $sth->fetchrow_array()) {   # user already has a stats record, update it
+                 $total_bl_items = $1 if ($row[0] + 1) =~ /^([0-9]*)$/si; # untaint
+                 $total_bl_items = untaint($total_bl_items);
+                 if ($total_bl_items == 1) {
+                     $total_bl_size = $size;
+                     $smallest_bl_size = $size;
+                     $largest_bl_size = $size;
+                     $oldest_bl_date = $received_date;
+                     $newest_bl_date = $received_date;
+                 } else {
+                     $total_bl_size = $1 if ($row[1] + $size) =~ /^([0-9]*)$/si; # untaint
+                     $total_bl_size = untaint($total_bl_size);
+                     $newest_bl_date = $1 if $received_date =~ /^(.*)$/si; # untaint
+                     $newest_bl_date = untaint($newest_bl_date);
+                     $oldest_bl_date = $1 if $row[2] =~ /^(.*)$/si; # untaint
+                     $oldest_bl_date = untaint($oldest_bl_date);
+                     if ($oldest_bl_date == "") {
+                         $oldest_bl_date = $received_date;
+                     }
+                     $smallest_bl_size = $1 if $row[3] =~ /^([0-9]*)$/si; # untaint
+                     $smallest_bl_size = untaint($smallest_bl_size);
+                     if ($smallest_bl_size > $size) {
+                         $smallest_bl_size = $size;
+                     }
+                     $largest_bl_size = $1 if $row[4] =~ /^([0-9]*)$/si; # untaint
+                     $largest_bl_size = untaint($largest_bl_size);
+                     if ($largest_bl_size < $size) {
+                         $largest_bl_size = $size;
+                     }
+                 }
+                 $update = "UPDATE maia_stats SET total_bl_items = ?, " .
+                                                 "total_bl_size = ?, " .
+                                                 "newest_bl_date = ?, " .
+                                                 "oldest_bl_date = ?, " .
+                                                 "smallest_bl_size = ?, " .
+                                                 "largest_bl_size = ? " .
+                           "WHERE user_id = ?";
+                 $sth = $dbh->prepare($update)
+                     or do_log(0, sprintf("Maia: [set_mail_status] Couldn't prepare query: %s", $dbh->errstr));
+                 $sth->execute($total_bl_items,
+                               $total_bl_size,
+                               $newest_bl_date,
+                               $oldest_bl_date,
+                               $smallest_bl_size,
+                               $largest_bl_size,
+                               $user_id)
+                     or do_log(0, sprintf("Maia: [set_mail_status] Couldn't execute query: %s", $dbh->errstr));
+             } else {   # user has no stats record, create one
+                 $total_bl_size = $1 if $size =~ /^([0-9]*)$/si; # untaint
+                 $total_bl_size = untaint($total_bl_size);
+                 $smallest_bl_size = $total_bl_size;
+                 $largest_bl_size = $total_bl_size;
+                 $newest_bl_date = $1 if $received_date =~ /^(.*)$/si; # untaint
+                 $newest_bl_date = untaint($newest_bl_date);
+                 $oldest_bl_date = $newest_bl_date;
+                 $insert = "INSERT INTO maia_stats (user_id, " .
+                                                   "total_bl_items, " .
+                                                   "total_bl_size, " .
+                                                   "newest_bl_date, " .
+                                                   "oldest_bl_date, " .
+                                                   "smallest_bl_size, " .
+                                                   "largest_bl_size) " .
+                           "VALUES (?,1,?,?,?,?,?)";
+                 $sth = $dbh->prepare($insert)
+                    or do_log(0, sprintf("Maia: [set_mail_status] Couldn't prepare query: %s", $dbh->errstr));
+                 $sth->execute($user_id,
+                               $total_bl_size,
+                               $newest_bl_date,
+                               $oldest_bl_date,
+                               $smallest_bl_size,
+                               $largest_bl_size)
+                     or do_log(0, sprintf("Maia: [set_mail_status] Couldn't execute query: %s", $dbh->errstr));
+             }
+             $sth->finish;
+ 
+         }
+     }
+     section_time("maia_set_mail_status");
+ }
+ 
+ 
+ 1;
+ 
+ #
  package Amavis::Expand;
  use strict;
***************
*** 5355,5359 ****
  
  BEGIN {
!   import Amavis::Conf qw(:platform :sa :confvars c cr ca);
    import Amavis::Util qw(untaint min max ll do_log sanitize_str debug_oneshot
                           am_id snmp_counters_init snmp_count prolong_timer);
--- 8149,8153 ----
  
  BEGIN {
!   import Amavis::Conf qw(:platform :sa :confvars :legacy_confvars c cr ca);
    import Amavis::Util qw(untaint min max ll do_log sanitize_str debug_oneshot
                           am_id snmp_counters_init snmp_count prolong_timer);
***************
*** 5374,5377 ****
--- 8168,8189 ----
    import Amavis::In::Connection;
    import Amavis::In::Message;
+   import Amavis::Maia qw(maia_connect
+                          maia_disconnect
+                          maia_read_system_config
+                          maia_autocreate_users
+                          maia_store_mail
+                          maia_get_recipient_id
+                          maia_set_mail_status
+                          maia_record_viruses
+                          maia_record_tests
+                          maia_record_banned_files
+                          maia_delete_mail
+                          maia_get_database_type
+                          maia_get_mysql_size_limit
+                          maia_should_discard_ham
+                          maia_delete_mail_recipient_reference
+                          maia_discard_if_requested
+                          maia_recipient_is_local
+                          maia_cleanup);
  }
  
***************
*** 5391,5395 ****
  
  use vars qw(%modules_basic);
! use vars qw($spam_level $spam_status $spam_report);
  use vars qw($user_id_sql $wb_listed_sql $implicit_maps_inserted);
  use vars qw($db_env $snmp_db);
--- 8203,8207 ----
  
  use vars qw(%modules_basic);
! use vars qw($spam_level $spam_status $spam_report $autolearn_status);
  use vars qw($user_id_sql $wb_listed_sql $implicit_maps_inserted);
  use vars qw($db_env $snmp_db);
***************
*** 5507,5516 ****
  
      h => $myhostname, # dns name of this host, or configurable name
!     l => sub {my($ip) = $MSGINFO->client_addr; my($val);
!               $val = $ip ne '' ? lookup_ip_acl($ip,@{ca('mynetworks_maps')})
!                                : lookup(0,$MSGINFO->sender_source,
!                                         @{ca('local_domains_maps')});
!               $val ? 1 : undef}, # sender's client IP (if known) from @mynetworks
!                                  # (if IP is known), or sender domain is local
      s => sub {qquote_rfc2821_local($MSGINFO->sender)}, # original envelope sender in <>
      S => sub { # unmangled sender or sender address to be notified, or empty...
--- 8319,8329 ----
  
      h => $myhostname, # dns name of this host, or configurable name
!     l => sub {undef}, # sender is local (disabled)
! #    l => sub {my($ip) = $MSGINFO->client_addr; my($val);
! #              $val = $ip ne '' ? lookup_ip_acl($ip,@{ca('mynetworks_maps')})
! #                               : lookup(0,$MSGINFO->sender_source,
! #                                        @{ca('local_domains_maps')});
! #              $val ? 1 : undef}, # sender's client IP (if known) from @mynetworks
! #                                 # (if IP is known), or sender domain is local
      s => sub {qquote_rfc2821_local($MSGINFO->sender)}, # original envelope sender in <>
      S => sub { # unmangled sender or sender address to be notified, or empty...
***************
*** 5546,5551 ****
      v => sub {[split(/[ \t]*\r?\n/,$av_output)]},   # anti-virus scanner output
      V => sub {my(%seen); [grep {!$seen{$_}++} @virusname]}, #unique virus names
!     F => sub {@banned_filename<=1 ? \@banned_filename
!                 : [$banned_filename[0], '...'] },   # list of banned file names
      X => sub {\@bad_headers},        # list of header syntax violations
      W => sub {\@detecting_scanners}, # list of av scanners detecting a virus
--- 8359,8373 ----
      v => sub {[split(/[ \t]*\r?\n/,$av_output)]},   # anti-virus scanner output
      V => sub {my(%seen); [grep {!$seen{$_}++} @virusname]}, #unique virus names
!     F => sub {my $temp_banned_filename;
!               $temp_banned_filename = $banned_filename[0];
!               $temp_banned_filename =~ /^.+?N=(\S+).*$/si;
!               if (@banned_filename == 0) {
!                   return \@banned_filename;
!               } elsif (@banned_filename == 1) {
!                   return $1;
!               } else {
!                   return [$1, '...']; # list of banned file names
!               }
!              },
      X => sub {\@bad_headers},        # list of header syntax violations
      W => sub {\@detecting_scanners}, # list of av scanners detecting a virus
***************
*** 5748,5751 ****
--- 8570,8574 ----
        do_log(2, Amavis::Timing::report());  # report elapsed times
      }
+     srand(time ^ $$);
    };
    if ($@ ne '') {
***************
*** 6118,6121 ****
--- 8941,8945 ----
    @virusname = (); @banned_filename = (); @bad_headers = ();
    $spam_level = undef; $spam_status = undef; $spam_report = undef;
+   $autolearn_status = undef;
  
    # comment out to retain SQL cache entries for the whole child lifetime:
***************
*** 6162,6166 ****
--- 8986,9024 ----
                         # really delivered.
    my($which_section);
+   my($dbh, $mail_id);
    eval {
+     $dbh = maia_connect();
+     my($enable_false_negative_management,
+        $enable_virus_checking,
+        $enable_spam_checking,
+        $enable_bad_header_checking,
+        $enable_banned_files_checking,
+        $enable_user_autocreation,
+        $enable_stats_tracking,
+        $enable_spamtraps,
+        $size_limit,
+        $oversize_policy,
+        $internal_auth,
+        $system_default_user_is_local) = maia_read_system_config($dbh);
+ 
+     my(@local_lookups) = ($local_domains_ldap, \%local_domains,
+ 	                  \@local_domains_acl, $local_domains_re);
+ 
+     my(@no_autocreate_lookups) = (\%no_autocreate_domains,
+ 	                          \@no_autocreate_domains_acl,
+ 	                          $no_autocreate_domains_re);
+ 
+     # size check
+     if (maia_get_database_type($dbh) =~ /^mysql$/si) {
+         my $mysql_size_limit = maia_get_mysql_size_limit($dbh);
+         if ($size_limit > $mysql_size_limit) {
+             do_log(0, sprintf("Maia: [check_mail] WARNING: Size limit (%ld) > max_allowed_packet (%ld); effective size limit is %ld bytes",
+                    $size_limit, $mysql_size_limit, $mysql_size_limit - 1024));
+             $size_limit = $mysql_size_limit - 1024; # allow a small padding margin
+         }
+     }
+     my($oversized) = $mail_size > $size_limit;
+     do_log(3, "Maia: [check_mail] Oversized item, skipping all tests") if $oversized;
+ 
      snmp_count('InMsgs');
      snmp_count('InMsgsNullRPath')  if $msginfo->sender eq '';
***************
*** 6254,6373 ****
      }  # if defined $cache_entry
  
!     my($will_do_virus_scanning) =   # virus scanning will be needed?
!        !$virus_presence_checked && $extra_code_antivirus &&
!        grep {!lookup(0,$_, @{ca('bypass_virus_checks_maps')})} @recips;
! 
!     my($will_do_banned_checking) =  # banned name checking will be needed?
!        !$banned_filename_checked &&
!        (@{ca('banned_filename_maps')} || cr('banned_namepath_re')) &&
!        grep {!lookup(0,$_, @{ca('bypass_banned_checks_maps')})} @recips;
  
      # will do decoding parts as deeply as possible?  only if needed
      my($will_do_parts_decoding) =
!        !c('bypass_decode_parts') &&
         ($will_do_virus_scanning || $will_do_banned_checking);
  
-     $which_section = "mime_decode-1";
-     my($ent); ($ent,$mime_err) = mime_decode($fh, $tempdir, $parts_root);
-     $msginfo->mime_entity($ent);
-     prolong_timer($which_section);
- 
      if ($will_do_parts_decoding) {
!       # decoding parts can take a lot of time!
!       snmp_count('OpsDec');
!       ($hold,$any_undecipherable) =
!         Amavis::Unpackers::decompose_mail($tempdir,$file_generator_object);
!     }
!     if (grep {!lookup(0,$_,@{ca('bypass_header_checks_maps')})} @recips) {
!       push(@bad_headers, "MIME error: ".$mime_err)  if $mime_err ne '';
!       push(@bad_headers, check_header_validity($conn,$msginfo));
!     }
!     if ($will_do_banned_checking) {      # check for banned file contents
!       $which_section = "check-banned";
!       my($banned_part_descr_ref, $banned_matching_keys_ref, $banned_rhs_ref) =
!         check_for_banned_names($parts_root);
!       for my $j (0..$#{$banned_part_descr_ref}) {
!         if ($banned_rhs_ref->[$j] =~ /^DISCARD/) {
!           $banned_dsn_suppress = 1;
!           do_log(4,sprintf('BANNED:%s: %s', $banned_rhs_ref->[$j],
!                            $banned_part_descr_ref->[$j]));
          }
!       }
!       push(@banned_filename, @$banned_part_descr_ref);
      }
      $cache_entry->{'FB'} = \@banned_filename;
      $cache_entry->{'FS'} = $banned_dsn_suppress;
  
!     if ($virus_presence_checked) {
!       do_log(5, "virus_presence cached, skipping virus_scan");
!     } elsif (!$extra_code_antivirus) {
!       do_log(5, "no anti-virus code loaded, skipping virus_scan");
!     } elsif (!grep {!lookup(0,$_,@{ca('bypass_virus_checks_maps')})} @recips) {
!       do_log(5, "bypassing of virus checks requested");
!     } elsif ($hold ne '') {  # protect virus scanner from mail bombs
!       do_log(0, "NOTICE: Virus scanning skipped: $hold");
!       $will_do_virus_scanning = 0;
!     } else {
!       if (!$will_do_virus_scanning)
!         { do_log(-1, "NOTICE: will_do_virus_scanning is false???") }
!       if (!defined($msginfo->mime_entity)) {
!         $which_section = "mime_decode-3";
!         my($ent); ($ent,$mime_err) = mime_decode($fh, $tempdir, $parts_root);
!         $msginfo->mime_entity($ent);
!         prolong_timer($which_section);
!       }
!       # special case to make available a complete mail file for inspection
!       if ($mime_err ne '' ||
!           lookup(0,'MAIL',@keep_decoded_original_maps) ||
!           $any_undecipherable && lookup(0,'MAIL-UNDECIPHERABLE',
!                                         @keep_decoded_original_maps)) {
!         # keep the original email.txt by making a hard link to it in ./parts/
!         $which_section = "linking-to-MAIL";
!         my($newpart_obj) = Amavis::Unpackers::Part->new("$tempdir/parts",
!                                                         $parts_root);
!         my($newpart) = $newpart_obj->full_name;
!         do_log(2, "providing full original message to scanners as $newpart".
!            (!$any_undecipherable ?'' :", $any_undecipherable undecipherable").
!            ($mime_err eq '' ? '' : ", MIME error: $mime_err") );
!         link($msginfo->mail_text_fn, $newpart)
!           or die sprintf("Can't create hard link %s to %s: %s",
!                          $newpart, $msginfo->mail_text_fn, $!);
!         $newpart_obj->type_short('MAIL');
!         $newpart_obj->type_declared('message/rfc822');
!       }
!       $which_section = "virus_scan";
!       # some virus scanners behave badly if interrupted,
!       # so for now just turn off the timer
!       my($remaining_time) = alarm(0);  # check time left, stop timer
!       my($av_ret);
!       eval {
!         my($vn, $ds);
!         ($av_ret, $av_output, $vn, $ds) =
!           Amavis::AV::virus_scan($tempdir, $child_task_count==1, $parts_root);
!         @virusname = @$vn; @detecting_scanners = @$ds;  # copy
!       };
!       prolong_timer($which_section, $remaining_time);   # restart timer
!       if ($@ ne '') {
!         chomp($@);
!         if ($@ eq "timed out") {
!           @virusname = (); $av_ret = 0;  # assume not a virus!
!           do_log(-1, "virus_scan TIMED OUT, ASSUME NOT A VIRUS !!!");
!         } else {
!           $hold = "virus_scan: $@";  # request HOLD
!           $av_ret = 0;               # pretend it was ok (msg should be held)
!           die "$hold\n";             # die, TEMPFAIL is preferred to HOLD
!         }
!       }
!       snmp_count('OpsVirusCheck');
!       defined($av_ret) or die "All virus scanners failed!";
!       @$cache_entry{'Vt','VO','VN','VD'} =
!         ($now, $av_output, \@virusname, \@detecting_scanners);
!       $virus_presence_checked = 1;
!       if (defined $snmp_db && @virusname) {
!         $which_section = "read_counters";
!         $virus_dejavu = 1  if !grep {$_==0}  # none with counter zero or undef
!                 @{$snmp_db->read_counters(map {"virus.byname.$_"} @virusname)};
!         section_time($which_section);
!       }
      }
  
--- 9112,9248 ----
      }  # if defined $cache_entry
  
!     # need to do banned files check?
!     my($will_do_banned_checking) = $enable_banned_files_checking && !$oversized;
!     if (!$oversized && $enable_banned_files_checking) {
!         $will_do_banned_checking =  # banned name checking will be needed?
!            !$banned_filename_checked &&
!            (@{ca('banned_filename_maps')} || cr('banned_namepath_re')) &&
!            grep {!lookup(0,$_, @{ca('bypass_banned_checks_maps')})} @recips;
!     }
! 
!     # need to do virus scanning?
!     my($will_do_virus_scanning) = $enable_virus_checking && !$oversized;
!     if (!$oversized && $enable_virus_checking) {
!         my($will_do_virus_scanning) =   # virus scanning will be needed?
!            !$virus_presence_checked && $extra_code_antivirus &&
!            grep {!lookup(0,$_, @{ca('bypass_virus_checks_maps')})} @recips;
!     }
  
      # will do decoding parts as deeply as possible?  only if needed
      my($will_do_parts_decoding) =
!        !c('bypass_decode_parts') && !$oversized &&
         ($will_do_virus_scanning || $will_do_banned_checking);
  
      if ($will_do_parts_decoding) {
!        $which_section = "mime_decode-1";
!        my($ent); ($ent,$mime_err) = mime_decode($fh, $tempdir, $parts_root);
!        $msginfo->mime_entity($ent);
!        prolong_timer($which_section);
! 
!        # decoding parts can take a lot of time!
!        snmp_count('OpsDec');
!        ($hold,$any_undecipherable) =
!          Amavis::Unpackers::decompose_mail($tempdir,$file_generator_object);
!     }
! 
!     # need to do bad header check?
!     if (!$oversized && $enable_bad_header_checking) {
!         if (grep {!lookup(0,$_,@{ca('bypass_header_checks_maps')})} @recips) {
!           push(@bad_headers, "MIME error: ".$mime_err)  if $mime_err ne '';
!           push(@bad_headers, check_header_validity($conn,$msginfo));
          }
!     }
! 
!     # do banned file checking if necessary
!     if (!$oversized && $enable_banned_files_checking && $will_do_banned_checking) {      # check for banned file contents
!        $which_section = "check-banned";
!        my($banned_part_descr_ref, $banned_matching_keys_ref, $banned_rhs_ref) =
!            check_for_banned_names($parts_root);
!        for my $j (0..$#{$banned_part_descr_ref}) {
!            if ($banned_rhs_ref->[$j] =~ /^DISCARD/) {
!                $banned_dsn_suppress = 1;
!                do_log(4,sprintf('BANNED:%s: %s', $banned_rhs_ref->[$j],
!                       $banned_part_descr_ref->[$j]));
!            }
!        }
!        push(@banned_filename, @$banned_part_descr_ref);
      }
      $cache_entry->{'FB'} = \@banned_filename;
      $cache_entry->{'FS'} = $banned_dsn_suppress;
  
!     # do virus check if necessary
!     if (!$oversized && $enable_virus_checking) {
!        if ($virus_presence_checked) {
!          do_log(5, "virus_presence cached, skipping virus_scan");
!        } elsif (!$extra_code_antivirus) {
!          do_log(5, "no anti-virus code loaded, skipping virus_scan");
!        } elsif (!grep {!lookup(0,$_,@{ca('bypass_virus_checks_maps')})} @recips) {
!          do_log(5, "bypassing of virus checks requested");
!        } elsif ($hold ne '') {  # protect virus scanner from mail bombs
!          do_log(0, "NOTICE: Virus scanning skipped: $hold");
!          $will_do_virus_scanning = 0;
!        } else {
!          if (!$will_do_virus_scanning)
!            { do_log(-1, "NOTICE: will_do_virus_scanning is false???") }
!          if (!defined($msginfo->mime_entity)) {
!            $which_section = "mime_decode-3";
!            my($ent); ($ent,$mime_err) = mime_decode($fh, $tempdir, $parts_root);
!            $msginfo->mime_entity($ent);
!            prolong_timer($which_section);
!          }
!          # special case to make available a complete mail file for inspection
!          if ($mime_err ne '' ||
!              lookup(0,'MAIL',@keep_decoded_original_maps) ||
!              $any_undecipherable && lookup(0,'MAIL-UNDECIPHERABLE',
!                                            @keep_decoded_original_maps)) {
!            # keep the original email.txt by making a hard link to it in ./parts/
!            $which_section = "linking-to-MAIL";
!            my($newpart_obj) = Amavis::Unpackers::Part->new("$tempdir/parts",
!                                                            $parts_root);
!            my($newpart) = $newpart_obj->full_name;
!            do_log(2, "providing full original message to scanners as $newpart".
!               (!$any_undecipherable ?'' :", $any_undecipherable undecipherable").
!               ($mime_err eq '' ? '' : ", MIME error: $mime_err") );
!            link($msginfo->mail_text_fn, $newpart)
!              or die sprintf("Can't create hard link %s to %s: %s",
!                             $newpart, $msginfo->mail_text_fn, $!);
!            $newpart_obj->type_short('MAIL');
!            $newpart_obj->type_declared('message/rfc822');
!          }
!          $which_section = "virus_scan";
!          # some virus scanners behave badly if interrupted,
!          # so for now just turn off the timer
!          my($remaining_time) = alarm(0);  # check time left, stop timer
!          my($av_ret);
!          eval {
!            my($vn, $ds);
!            ($av_ret, $av_output, $vn, $ds) =
!              Amavis::AV::virus_scan($tempdir, $child_task_count==1, $parts_root);
!            @virusname = @$vn; @detecting_scanners = @$ds;  # copy
!          };
!          prolong_timer($which_section, $remaining_time);   # restart timer
!          if ($@ ne '') {
!            chomp($@);
!            if ($@ eq "timed out") {
!              @virusname = (); $av_ret = 0;  # assume not a virus!
!              do_log(-1, "virus_scan TIMED OUT, ASSUME NOT A VIRUS !!!");
!            } else {
!              $hold = "virus_scan: $@";  # request HOLD
!              $av_ret = 0;               # pretend it was ok (msg should be held)
!              die "$hold\n";             # die, TEMPFAIL is preferred to HOLD
!            }
!          }
!          snmp_count('OpsVirusCheck');
!          defined($av_ret) or die "All virus scanners failed!";
!          @$cache_entry{'Vt','VO','VN','VD'} =
!            ($now, $av_output, \@virusname, \@detecting_scanners);
!          $virus_presence_checked = 1;
!          if (defined $snmp_db && @virusname) {
!            $which_section = "read_counters";
!            $virus_dejavu = 1  if !grep {$_==0}  # none with counter zero or undef
!                    @{$snmp_db->read_counters(map {"virus.byname.$_"} @virusname)};
!            section_time($which_section);
!          }
!        }
      }
  
***************
*** 6382,6411 ****
      $msginfo->sender_source($sender_source);    # save it
  
!     # consider doing spam scanning
!     if (!$extra_code_antispam) {
!       do_log(5, "no anti-spam code loaded, skipping spam_scan");
!     } elsif (@virusname || @banned_filename) {
!       do_log(5, "infected or banned contents, skipping spam_scan");
!     } elsif (!grep {!lookup(0,$_,@{ca('bypass_spam_checks_maps')})} @recips) {
!       do_log(5, "bypassing of spam checks requested");
!     } else {
!       $which_section = "spam-wb-list";
!       my($any_wbl, $all_wbl) = Amavis::SpamControl::white_black_list(
!                      $conn, $msginfo, $sql_wblist, $user_id_sql, $ldap_policy);
!       section_time($which_section);
!       if ($all_wbl) {
!         do_log(5, "sender white/blacklisted, skipping spam_scan");
!       } elsif ($spam_presence_checked) {
!         do_log(5, "spam_presence cached, skipping spam_scan");
!       } else {
!         $which_section = "spam_scan";
!         ($spam_level, $spam_status, $spam_report) =
!           Amavis::SpamControl::spam_scan($conn, $msginfo);
!         prolong_timer($which_section);
!         snmp_count('OpsSpamCheck');
!         @$cache_entry{'St','SL','SS','SR'} =
!           ($now, $spam_level, $spam_status, $spam_report);
!         $spam_presence_checked = 1;
!       }
      }
  
--- 9257,9288 ----
      $msginfo->sender_source($sender_source);    # save it
  
!     # spam check if necessary
!     if (!$oversized && $enable_spam_checking) {
!        if (!$extra_code_antispam) {
!          do_log(5, "no anti-spam code loaded, skipping spam_scan");
!        } elsif (@virusname || @banned_filename) {
!          do_log(5, "infected or banned contents, skipping spam_scan");
!        } elsif (!grep {!lookup(0,$_,@{ca('bypass_spam_checks_maps')})} @recips) {
!          do_log(5, "bypassing of spam checks requested");
!        } else {
!          $which_section = "spam-wb-list";
!          my($any_wbl, $all_wbl) = Amavis::SpamControl::white_black_list(
!                         $conn, $msginfo, $sql_wblist, $user_id_sql, $ldap_policy, $dbh);
!          section_time($which_section);
!          if ($all_wbl) {
!            do_log(5, "sender white/blacklisted, skipping spam_scan");
!          } elsif ($spam_presence_checked) {
!            do_log(5, "spam_presence cached, skipping spam_scan");
!          } else {
!            $which_section = "spam_scan";
!            ($spam_level, $spam_status, $spam_report, $autolearn_status) =
!              Amavis::SpamControl::spam_scan($conn, $msginfo);
!            prolong_timer($which_section);
!            snmp_count('OpsSpamCheck');
!            @$cache_entry{'St','SL','SS','SR'} =
!              ($now, $spam_level, $spam_status, $spam_report);
!            $spam_presence_checked = 1;
!          }
!        }
      }
  
***************
*** 6420,6428 ****
      snmp_count("virus.byname.$_")  for @virusname;
  
      # SECOND: now that we know what we got, decide what to do with it
  
      my($considered_spam_by_some_recips,$considered_oversize_by_some_recips);
  
!     if (@virusname || @banned_filename) {  # virus or banned filename found
        # bad_headers do not enter this section, although code is ready for them;
        # we'll handle bad headers later, if mail turns out not to be spam
--- 9297,9319 ----
      snmp_count("virus.byname.$_")  for @virusname;
  
+     if ($enable_user_autocreation && !@virusname) {
+         maia_autocreate_users($dbh, $msginfo, $internal_auth,
+                               \@local_lookups, \@no_autocreate_lookups);
+     }
+ 
+     # write mail to maia_mail table
+     $mail_id = maia_store_mail($dbh, $msginfo, $oversized, $enable_stats_tracking,
+                                $system_default_user_is_local,
+     		               $local_domains_ldap, \%local_domains,
+                                \@local_domains_acl, $local_domains_re);
+ 
      # SECOND: now that we know what we got, decide what to do with it
  
      my($considered_spam_by_some_recips,$considered_oversize_by_some_recips);
+     my($maia_user_id, $mail_type);
  
!     if (!$oversized &&
!         (($enable_virus_checking && @virusname) ||
!          ($enable_banned_files_checking && @banned_filename))) { # virus or banned filename found
        # bad_headers do not enter this section, although code is ready for them;
        # we'll handle bad headers later, if mail turns out not to be spam
***************
*** 6434,6444 ****
        for my $r (@{$msginfo->per_recip_data}) {
          next  if $r->recip_done;           # already dealt with
          if ($final_destiny == D_PASS) {
            # recipient wants this message, malicious or not
!         } elsif ((!@virusname ||           # not a virus or we want it
                    lookup(0,$r->recip_addr, @{ca('virus_lovers_maps')})) &&
!                  (!@banned_filename ||     # not banned or we want it
                    lookup(0,$r->recip_addr, @{ca('banned_files_lovers_maps')})) &&
!                  (!@bad_headers ||         # not bad header or we want it
                    lookup(0,$r->recip_addr, @{ca('bad_header_lovers_maps')})) )
          {
--- 9325,9365 ----
        for my $r (@{$msginfo->per_recip_data}) {
          next  if $r->recip_done;           # already dealt with
+ 
+         $maia_user_id = maia_get_recipient_id($dbh, $r->recip_addr,
+ 	                                      $system_default_user_is_local,
+ 	                                      $local_domains_ldap, \%local_domains,
+                                               \@local_domains_acl, $local_domains_re);
+ 	if ($maia_user_id > 0) {
+ 	    if ($enable_virus_checking && @virusname) {
+ 	        if ($enable_stats_tracking) {
+ 		    maia_record_viruses($dbh, $mail_id, @virusname);
+ 		}
+ 		$mail_type = "V";
+ 		maia_set_mail_status($dbh, $mail_id, $maia_user_id,
+                                      $enable_stats_tracking,
+ 		                     $enable_false_negative_management,
+                                      $enable_spamtraps, $mail_type);
+ 	    } elsif ($enable_banned_files_checking && @banned_filename) {
+ 	        if ($enable_stats_tracking) {
+ 	            maia_record_banned_files($dbh, $mail_id, @banned_filename);
+ 	        }
+ 	        $mail_type = "F";
+ 	        maia_set_mail_status($dbh, $mail_id, $maia_user_id,
+                                      $enable_stats_tracking,
+ 		                     $enable_false_negative_management,
+                                      $enable_spamtraps, $mail_type);
+             }
+ 	}
+ 
          if ($final_destiny == D_PASS) {
            # recipient wants this message, malicious or not
!         } elsif ((!$enable_virus_checking ||
!                   !@virusname ||           # not a virus or we want it
                    lookup(0,$r->recip_addr, @{ca('virus_lovers_maps')})) &&
!                  (!$enable_banned_files_checking ||
!                   !@banned_filename ||     # not banned or we want it
                    lookup(0,$r->recip_addr, @{ca('banned_files_lovers_maps')})) &&
!                  (!$enable_bad_header_checking ||
!                   !@bad_headers ||         # not bad header or we want it
                    lookup(0,$r->recip_addr, @{ca('bad_header_lovers_maps')})) )
          {
***************
*** 6447,6455 ****
            $r->recip_destiny($final_destiny);
            my($reason);
!           if (@virusname)
              { $reason = "VIRUS: "  . join(", ", @virusname) }
!           elsif (@banned_filename)
              { $reason = "BANNED: " . join(", ", @banned_filename) }
!           elsif (@bad_headers)
              { $reason = "BAD_HEADER: " . join(", ", @bad_headers) }
            $reason = substr($reason,0,100)."..."  if length($reason) > 100+3;
--- 9368,9376 ----
            $r->recip_destiny($final_destiny);
            my($reason);
!           if ($enable_virus_checking && @virusname)
              { $reason = "VIRUS: "  . join(", ", @virusname) }
!           elsif ($enable_banned_files_checking && @banned_filename)
              { $reason = "BANNED: " . join(", ", @banned_filename) }
!           elsif ($enable_bad_header_checking && @bad_headers)
              { $reason = "BAD_HEADER: " . join(", ", @bad_headers) }
            $reason = substr($reason,0,100)."..."  if length($reason) > 100+3;
***************
*** 6459,6462 ****
--- 9380,9387 ----
                                     ", id=$am_id - $reason");
            $r->recip_done(1);
+           if ($maia_user_id > 0) {
+ 	      maia_discard_if_requested($dbh, $mail_id, $maia_user_id, 
+                                         $r->recip_addr, $mail_type);
+           }
          }
        }
***************
*** 6464,6470 ****
        ensure_mime_entity($msginfo, $fh, $tempdir, \@virusname, $parts_root);
        # send notifications, quarantine it
!       do_virus($conn, $msginfo, $virus_dejavu);
  
!     } else {                      # perhaps some recips consider it spam?
          # spaminess is an individual matter, we must compare spam level
          # with each recipient setting, there is no global criterium
--- 9389,9395 ----
        ensure_mime_entity($msginfo, $fh, $tempdir, \@virusname, $parts_root);
        # send notifications, quarantine it
!       do_virus($dbh, $conn, $msginfo, $virus_dejavu, \@local_lookups);
  
!     } elsif (!$oversized && $enable_spam_checking) { # perhaps some recips consider it spam?
          # spaminess is an individual matter, we must compare spam level
          # with each recipient setting, there is no global criterium
***************
*** 6474,6477 ****
--- 9399,9419 ----
        for my $r (@{$msginfo->per_recip_data}) {
          next  if $r->recip_done;  # already dealt with
+ 
+         $maia_user_id = maia_get_recipient_id($dbh, $r->recip_addr,
+ 	                                      $system_default_user_is_local,
+ 	                                      $local_domains_ldap, \%local_domains,
+                                               \@local_domains_acl, $local_domains_re);
+ 	if ($maia_user_id > 0) {
+ 
+ 	    # Sender is whitelisted
+ 	    if ($r->recip_whitelisted_sender) {
+ 	        $mail_type = "W";
+ 	        maia_set_mail_status($dbh, $mail_id, $maia_user_id,
+                                      $enable_stats_tracking,
+ 		                     $enable_false_negative_management,
+                                      $enable_spamtraps, $mail_type);
+ 	    }
+ 	}
+ 
          my($kill_level);
          $kill_level = lookup(0,$r->recip_addr, @{ca('spam_kill_level_maps')});
***************
*** 6485,6488 ****
--- 9427,9451 ----
          # message is at or above kill level, or sender is blacklisted
          $considered_spam_by_some_recips = 1;
+ 
+         if ($maia_user_id > 0) {
+ 	    if ($r->recip_blacklisted_sender) {
+ 	        $mail_type = "L";
+ 	        maia_set_mail_status($dbh, $mail_id, $maia_user_id,
+                                      $enable_stats_tracking,
+ 		                     $enable_false_negative_management,
+                                      $enable_spamtraps, $mail_type);
+ 	    } else {
+ 	        if ($enable_stats_tracking) {
+ 	            maia_record_tests($dbh, $mail_id, $spam_status, 
+                                       $spam_level);
+ 		}
+ 	        $mail_type = "S";
+ 	        maia_set_mail_status($dbh, $mail_id, $maia_user_id,
+                                      $enable_stats_tracking,
+ 	                             $enable_false_negative_management,
+                                      $enable_spamtraps, $mail_type);
+             }
+ 	}
+ 
          if ($final_destiny == D_PASS ||
              lookup(0,$r->recip_addr, @{ca('spam_lovers_maps')})) {
***************
*** 6505,6508 ****
--- 9468,9475 ----
                              ) . ", id=$am_id");
            $r->recip_done(1);
+           if ($maia_user_id > 0) {
+ 	      maia_discard_if_requested($dbh, $mail_id, $maia_user_id, 
+                                         $r->recip_addr, $mail_type);
+           }
          }
        }
***************
*** 6510,6519 ****
          $which_section = "spam quar+notif";
          ensure_mime_entity($msginfo, $fh, $tempdir, \@virusname, $parts_root);
!         do_spam($conn, $msginfo);
          section_time('post-do_spam');
        }
      }
  
!     if (@bad_headers) {  # invalid mail headers
        $which_section = "deal_with_bad_headers";
        ensure_mime_entity($msginfo, $fh, $tempdir, \@virusname, $parts_root);
--- 9477,9486 ----
          $which_section = "spam quar+notif";
          ensure_mime_entity($msginfo, $fh, $tempdir, \@virusname, $parts_root);
!         do_spam($conn, $msginfo, $mail_id);
          section_time('post-do_spam');
        }
      }
  
!     if (!$oversized && $enable_bad_header_checking && @bad_headers) {  # invalid mail headers
        $which_section = "deal_with_bad_headers";
        ensure_mime_entity($msginfo, $fh, $tempdir, \@virusname, $parts_root);
***************
*** 6530,6533 ****
--- 9497,9514 ----
          for my $r (@{$msginfo->per_recip_data}) {
            next  if $r->recip_done;  # already dealt with
+ 
+           $maia_user_id = maia_get_recipient_id($dbh, $r->recip_addr,
+                                                 $system_default_user_is_local,
+ 	                                        $local_domains_ldap, \%local_domains,
+                                                 \@local_domains_acl,
+                                                 $local_domains_re);
+           if ($maia_user_id > 0) {
+ 	      $mail_type = "B";
+ 	      maia_set_mail_status($dbh, $mail_id, $maia_user_id,
+                                    $enable_stats_tracking,
+                                    $enable_false_negative_management,
+                                    $enable_spamtraps, $mail_type);
+           }
+ 
            if ($final_destiny == D_PASS ||
                lookup(0,$r->recip_addr, @{ca('bad_header_lovers_maps')}))
***************
*** 6542,6545 ****
--- 9523,9530 ----
                        ) . ", id=$am_id - $reason");
              $r->recip_done(1);
+             if ($maia_user_id > 0) {
+                 maia_discard_if_requested($dbh, $mail_id, $maia_user_id, 
+                                           $r->recip_addr, $mail_type);
+             }
              $any_badh++;
            }
***************
*** 6547,6551 ****
          if ($any_badh) {  # we use the same code as for viruses or banned
                            # but only if it wasn't already handled as spam
!           do_virus($conn, $msginfo, 0);  # send notifications, quarantine it
          }
        }
--- 9532,9536 ----
          if ($any_badh) {  # we use the same code as for viruses or banned
                            # but only if it wasn't already handled as spam
!           do_virus($dbh, $conn, $msginfo, 0, \@local_lookups);  # send notifications, quarantine it
          }
        }
***************
*** 6612,6615 ****
--- 9597,9673 ----
      # THIRD: now that we know what to do with it, do it!
  
+     if (!$oversized) {
+ 
+         # any recipient not marked as 'done' will receive the mail as 'H'am
+         for my $r (@{$msginfo->per_recip_data}) {
+             next if $r->recip_done;
+             $maia_user_id = maia_get_recipient_id($dbh, $r->recip_addr,
+                                                   $system_default_user_is_local,
+                                                   $local_domains_ldap, 
+                                                   \%local_domains,
+                                                   \@local_domains_acl,
+                                                   $local_domains_re);
+             if ($maia_user_id > 0) {
+ 
+                 if ($enable_stats_tracking) {
+                     maia_record_tests($dbh, $mail_id, $spam_status, 
+                                       $spam_level);
+                 }
+ 
+                 # Score is >= spam level, but < kill level
+ 	        if (!$r->recip_blacklisted_sender &&
+ 	            defined $spam_level && $spam_level >=
+                     lookup(0,$r->recip_addr, @{ca('spam_tag2_level_maps')}) &&
+                     $spam_level < lookup(0,$r->recip_addr, @{ca('spam_kill_level_maps')})) {
+  	            maia_set_mail_status($dbh, $mail_id, $maia_user_id,
+                                          $enable_stats_tracking,
+                                          $enable_false_negative_management,
+                                          $enable_spamtraps, "S");
+ 
+                 } else {
+ 
+                     if ($enable_false_negative_management && 
+                         maia_should_discard_ham($dbh, $maia_user_id)) {
+ 
+                         # User has requested that no ham be cached for him
+                         do_log(3, sprintf("Maia: [check_mail] Not caching ham at the request of user %ld", $maia_user_id));
+                         maia_delete_mail_recipient_reference($dbh, $mail_id,
+                                                              $maia_user_id);
+ 
+                     } else {
+ 
+                         maia_set_mail_status($dbh, $mail_id, $maia_user_id,
+                                              $enable_stats_tracking,
+ 		                             $enable_false_negative_management,
+                                              $enable_spamtraps, "H");
+ 		    }
+ 
+ 		}
+             }
+         }
+ 
+     } else {
+ 
+         if ($oversize_policy =~ /^P$/) {
+ 
+             # Let the mail through: D_PASS
+             do_log(3, "Maia: [check_mail] Delivering oversized mail");
+ 
+         } else {
+ 
+             # Bounce the mail for all recipients: D_BOUNCE
+             do_log(3, "Maia: [check_mail] Bouncing oversized mail");
+ 
+             for my $r (@{$msginfo->per_recip_data}) {
+                 $r->recip_destiny(D_BOUNCE);
+                 $r->recip_smtp_response("534 5.3.4 Message larger than " .
+                                         $size_limit . " bytes rejected" .
+                                         ", id=$am_id");
+                 $r->recip_done(1);
+             }
+         }
+ 
+     }
+ 
      my($which_content_counter) =
          @virusname       ? 'ContentVirusMsgs'
***************
*** 6635,6639 ****
        my($recip_cl);  # ref to a list of similar recip objects
        ($hdr_edits, $recip_cl, $done_all) =
!         add_forwarding_header_edits_per_recip(
            $conn, $msginfo, $hdr_edits, $hold, $any_undecipherable,
            $virus_presence_checked, $spam_presence_checked, undef, undef);
--- 9693,9697 ----
        my($recip_cl);  # ref to a list of similar recip objects
        ($hdr_edits, $recip_cl, $done_all) =
!         add_forwarding_header_edits_per_recip($dbh, \@local_lookups,
            $conn, $msginfo, $hdr_edits, $hold, $any_undecipherable,
            $virus_presence_checked, $spam_presence_checked, undef, undef);
***************
*** 6683,6687 ****
          my($recip_cl);  # ref to a list of similar recip objects
          ($r_hdr_edits, $recip_cl, $done_all) =
!           add_forwarding_header_edits_per_recip(
              $conn, $msginfo, $r_hdr_edits, $hold, $any_undecipherable,
              $virus_presence_checked, $spam_presence_checked,
--- 9741,9745 ----
          my($recip_cl);  # ref to a list of similar recip objects
          ($r_hdr_edits, $recip_cl, $done_all) =
!           add_forwarding_header_edits_per_recip($dbh, \@local_lookups,
              $conn, $msginfo, $r_hdr_edits, $hold, $any_undecipherable,
              $virus_presence_checked, $spam_presence_checked,
***************
*** 6893,6897 ****
--- 9951,9959 ----
        $r->recip_smtp_response($smtp_resp); $r->recip_done(1);
      }
+     maia_delete_mail($dbh, $mail_id);
+   } else {
+     maia_cleanup($dbh, $mail_id);
    }
+   maia_disconnect($dbh);
  # if ($hold ne '') {
  #   do_log(-1, "NOTICE: Evidence is to be preserved: $hold");
***************
*** 6987,6992 ****
  # delivered to them in one SMTP transaction).
  #
! sub add_forwarding_header_edits_per_recip($$$$$$$$$) {
!   my($conn, $msginfo, $hdr_edits, $hold, $any_undecipherable,
       $virus_presence_checked, $spam_presence_checked,
       $mail_defanged, $filter) = @_;
--- 10049,10054 ----
  # delivered to them in one SMTP transaction).
  #
! sub add_forwarding_header_edits_per_recip($$$$$$$$$$$) {
!   my($dbh, $local_lookups, $conn, $msginfo, $hdr_edits, $hold, $any_undecipherable,
       $virus_presence_checked, $spam_presence_checked,
       $mail_defanged, $filter) = @_;
***************
*** 7001,7005 ****
         $do_tag_virus_checked,$do_tag_virus,$do_tag_banned,$do_tag_badh,
         $do_tag,$do_tag2,$do_subj,$do_subj_u,$subject_tag,$subject_tag2);
!     $is_local = lookup(0,$recip, @{ca('local_domains_maps')});
      $do_tag_badh  = @bad_headers &&
                      !lookup(0,$recip,@{ca('bypass_header_checks_maps')});
--- 10063,10067 ----
         $do_tag_virus_checked,$do_tag_virus,$do_tag_banned,$do_tag_badh,
         $do_tag,$do_tag2,$do_subj,$do_subj_u,$subject_tag,$subject_tag2);
!     $is_local = maia_recipient_is_local($dbh, $recip, $local_lookups);
      $do_tag_badh  = @bad_headers &&
                      !lookup(0,$recip,@{ca('bypass_header_checks_maps')});
***************
*** 7238,7243 ****
  
  # If virus/banned/bad-header found - quarantine it and send notifications
! sub do_virus($$$) {
!   my($conn, $msginfo, $virus_dejavu) = @_;
    my($q_method, $quarantine_to_maps_ref,
       $bypass_checks_maps_ref, $admin_maps_ref) =
--- 10300,10305 ----
  
  # If virus/banned/bad-header found - quarantine it and send notifications
! sub do_virus($$$$$) {
!   my($dbh, $conn, $msginfo, $virus_dejavu, $local_lookups) = @_;
    my($q_method, $quarantine_to_maps_ref,
       $bypass_checks_maps_ref, $admin_maps_ref) =
***************
*** 7276,7280 ****
      $q = $rec  if $q ne '' && $q_method =~ /^bsmtp:/i;  # orig.recip when BSMTP
      ($a) = lookup(0,$rec,@$admin_maps_ref)  if $admin_maps_ref;
!     push(@q_addr, $q)  if $q ne '' && !grep {$_ eq $q} @q_addr;
      push(@a_addr, $a)  if $a ne '' && !grep {$_ eq $a} @a_addr;
      if ($newvirus_admin_maps_ref) {
--- 10338,10342 ----
      $q = $rec  if $q ne '' && $q_method =~ /^bsmtp:/i;  # orig.recip when BSMTP
      ($a) = lookup(0,$rec,@$admin_maps_ref)  if $admin_maps_ref;
! #    push(@q_addr, $q)  if $q ne '' && !grep {$_ eq $q} @q_addr;
      push(@a_addr, $a)  if $a ne '' && !grep {$_ eq $a} @a_addr;
      if ($newvirus_admin_maps_ref) {
***************
*** 7353,7357 ****
            scalar(lookup(0,$_,@{ca('warnbadhrecip_maps')}))
        : 0  }
!       grep { c('warn_offsite') || lookup(0,$_,@{ca('local_domains_maps')}) }
             @{$msginfo->recips};
      if (!@recips_to_notify) {
--- 10415,10419 ----
            scalar(lookup(0,$_,@{ca('warnbadhrecip_maps')}))
        : 0  }
!       grep { c('warn_offsite') || maia_recipient_is_local($dbh, $_, $local_lookups) }
             @{$msginfo->recips};
      if (!@recips_to_notify) {
***************
*** 7392,7405 ****
  #
  # If Spam found - quarantine it and log report
! sub do_spam($$) {
!   my($conn, $msginfo) = @_;
    # suggest a name to be used as 'X-Quarantine-Id:' or file name
    my($q_method) = c('spam_quarantine_method');
!   $VIRUSFILE = $q_method =~ /^(?:local|bsmtp):(.*)\z/si ? $1 : "spam-%b-%i-%n";
!   $VIRUSFILE =~ s{%(.)}
!     {  $1 eq 'b' ? $msginfo->body_digest
!      : $1 eq 'i' ? strftime("%Y%m%d-%H%M%S",localtime($msginfo->rx_time))
!      : $1 eq 'n' ? am_id()
!      : $1 eq '%' ? '%' : '%'.$1 }egs;
    # use the smallest value as the level reported in quarantined headers!
    my($tag_level) =
--- 10454,10468 ----
  #
  # If Spam found - quarantine it and log report
! sub do_spam($$$) {
!   my($conn, $msginfo, $mail_id) = @_;
    # suggest a name to be used as 'X-Quarantine-Id:' or file name
    my($q_method) = c('spam_quarantine_method');
! #  $VIRUSFILE = $q_method =~ /^(?:local|bsmtp):(.*)\z/si ? $1 : "spam-%b-%i-%n";
! #  $VIRUSFILE =~ s{%(.)}
! #    {  $1 eq 'b' ? $msginfo->body_digest
! #     : $1 eq 'i' ? strftime("%Y%m%d-%H%M%S",localtime($msginfo->rx_time))
! #     : $1 eq 'n' ? am_id()
! #     : $1 eq '%' ? '%' : '%'.$1 }egs;
!   $VIRUSFILE = sprintf("spam-%ld", $mail_id);
    # use the smallest value as the level reported in quarantined headers!
    my($tag_level) =
***************
*** 7427,7434 ****
    my(@q_addr,@a_addr);  # quarantine address(es) and administrators
    my($sqbsm) = ca('spam_quarantine_bysender_to_maps');
!   if (@$sqbsm) {   # by-sender quarantine
!     my($a);  $a = lookup(0,$msginfo->sender, @$sqbsm);
!     push(@q_addr, $a)  if $a ne '';
!   }
    # get per-recipient quarantine address(es) and admins
    for my $r (@{$msginfo->per_recip_data}) {
--- 10490,10497 ----
    my(@q_addr,@a_addr);  # quarantine address(es) and administrators
    my($sqbsm) = ca('spam_quarantine_bysender_to_maps');
! #  if (@$sqbsm) {   # by-sender quarantine
! #    my($a);  $a = lookup(0,$msginfo->sender, @$sqbsm);
! #    push(@q_addr, $a)  if $a ne '';
! #  }
    # get per-recipient quarantine address(es) and admins
    for my $r (@{$msginfo->per_recip_data}) {
***************
*** 7438,7442 ****
      $q = $rec  if $q ne '' && $q_method =~ /^bsmtp:/i;  # orig.recip when BSMTP
      my($a) = lookup(0,$rec, @{ca('spam_admin_maps')});
!     push(@q_addr, $q)  if $q ne '' && !grep {$_ eq $q} @q_addr;
      push(@a_addr, $a)  if $a ne '' && !grep {$_ eq $a} @a_addr;
    }
--- 10501,10505 ----
      $q = $rec  if $q ne '' && $q_method =~ /^bsmtp:/i;  # orig.recip when BSMTP
      my($a) = lookup(0,$rec, @{ca('spam_admin_maps')});
! #    push(@q_addr, $q)  if $q ne '' && !grep {$_ eq $q} @q_addr;
      push(@a_addr, $a)  if $a ne '' && !grep {$_ eq $a} @a_addr;
    }
***************
*** 7456,7463 ****
    }
    $s = $full_spam_status; $s =~ s/\n[ \t]/ /g;
!   do_log(2,sprintf("SPAM, <%s> -> %s, %s%s", $msginfo->sender_source,
!                    join(',', qquote_rfc2821_local(@{$msginfo->recips})),  $s,
!                    !@q_addr ? '' : sprintf(", quarantine %s (%s)",
!                                            $VIRUSFILE, join(',', @q_addr)) ));
    if (!@a_addr) {
      do_log(4, "Skip spam admin notification, no administrators");
--- 10519,10537 ----
    }
    $s = $full_spam_status; $s =~ s/\n[ \t]/ /g;
! #  do_log(2,sprintf("SPAM, <%s> -> %s, %s%s", $msginfo->sender_source,
! #                   join(',', qquote_rfc2821_local(@{$msginfo->recips})),  $s,
! #                   !@q_addr ? '' : sprintf(", quarantine %s (%s)",
! #                                           $VIRUSFILE, join(',', @q_addr)) ));
! 
!   if (defined $spam_level && $spam_level >= $kill_level) {
!       do_log(1, sprintf("SPAM, <%s> -> %s, %s, quarantine %s (maia-spam-quarantine)",
!                         $msginfo->sender_source,
!                         join(',', qquote_rfc2821_local(@{$msginfo->recips})),
!                         $s, $VIRUSFILE));
!   } else {
!       do_log(1, sprintf("SPAM, <%s> -> %s, %s", $msginfo->sender_source,
!                         join(',', qquote_rfc2821_local(@{$msginfo->recips})), $s));
!   }
! 
    if (!@a_addr) {
      do_log(4, "Skip spam admin notification, no administrators");
***************
*** 7657,7661 ****
  
        DBD::mysql Sys::Hostname::Long
!       Mail::SPF::Query Razor2::Client Net::CIDR::Lite
        Net::DNS::RR::SOA Net::DNS::RR::NS Net::DNS::RR::MX
        Net::DNS::RR::A Net::DNS::RR::AAAA Net::DNS::RR::PTR
--- 10731,10735 ----
  
        DBD::mysql Sys::Hostname::Long
!       Mail::SPF::Query Razor2::Client::Agent Net::CIDR::Lite
        Net::DNS::RR::SOA Net::DNS::RR::NS Net::DNS::RR::MX
        Net::DNS::RR::A Net::DNS::RR::AAAA Net::DNS::RR::PTR
***************
*** 7665,7671 ****
      # ??? Mail::SpamAssassin::Plugin::Razor2
    }
!   # *** note that $sa_version could be 3.0.1, which is not really numeric!
!   if ($extra_code_antispam && defined $sa_version && $sa_version < 3) {
!     push(@modules, qw(
        Mail::SpamAssassin::UnixLocker Mail::SpamAssassin::BayesStoreDBM
        Mail::SpamAssassin::SpamCopURI
--- 10739,10745 ----
      # ??? Mail::SpamAssassin::Plugin::Razor2
    }
!   if ($extra_code_antispam && defined $sa_version) {
!     # *** note that $sa_version could be 3.0.1, which is not really numeric!
!     if ($sa_version=~/^(\d+(?:\.\d+)?)/ && $1 < 3) { push(@modules, qw(
        Mail::SpamAssassin::UnixLocker Mail::SpamAssassin::BayesStoreDBM
        Mail::SpamAssassin::SpamCopURI
***************
*** 7678,7682 ****
        URI::tn3270 URI::urn URI::urn::isbn URI::urn::oid
        URI::file URI::file::Base URI::file::Unix URI::file::Win32
!     ));
    }
    my($missing);
--- 10752,10777 ----
        URI::tn3270 URI::urn URI::urn::isbn URI::urn::oid
        URI::file URI::file::Base URI::file::Unix URI::file::Win32
!       ));
!     } elsif ($sa_version=~/^(\d+(?:\.\d+)?)/ && $1 >= 3.1) { push(@modules, qw(
!       Mail::SpamAssassin::BayesStore::MySQL
!       Mail::SpamAssassin::Plugin::AutoLearnThreshold
!       Mail::SpamAssassin::Plugin::ReplaceTags
!       Mail::SpamAssassin::Plugin::MIMEHeader
!       Mail::SpamAssassin::Plugin::AWL Mail::SpamAssassin::Plugin::DCC
!       Mail::SpamAssassin::Plugin::Pyzor Mail::SpamAssassin::Plugin::Razor2
!       Mail::SpamAssassin::Plugin::SpamCop
!       Mail::SpamAssassin::Plugin::WhiteListSubject
!       Mail::SpamAssassin::Plugin::DomainKeys
!       Mail::DomainKeys::Header Mail::DomainKeys::Message
!       Mail::DomainKeys::Policy Mail::DomainKeys::Signature
!       Mail::DomainKeys::Key Mail::DomainKeys::Key::Public
!       Crypt::OpenSSL::RSA
!       IP::Country::Fast
!       Mail::Address
!       Net::CIDR::Lite
!       ));
!       # BayesStore::PgSQL BayesStore::SDBM
!       # Plugin::AntiVirus Plugin::DomainKeys Plugin::NetCache Plugin::TextCat
!     }
    }
    my($missing);
***************
*** 7687,7691 ****
    # load optional modules SAVI and Mail::ClamAV if available and requested
    if ($extra_code_antivirus) {
!     my($savi_obj, $savi_module_ok, $clamav_module_ok);
      for my $entry (@{ca('av_scanners')}, @{ca('av_scanners_backup')}) {
        if (ref($entry) ne 'ARRAY') {  # none
--- 10782,10786 ----
    # load optional modules SAVI and Mail::ClamAV if available and requested
    if ($extra_code_antivirus) {
!     my($clamav_module_ok);
      for my $entry (@{ca('av_scanners')}, @{ca('av_scanners_backup')}) {
        if (ref($entry) ne 'ARRAY') {  # none
***************
*** 7693,7710 ****
                 $entry->[1] eq \&sophos_savi ||
                 $entry->[0] eq 'Sophos SAVI') {
!         if (!defined($savi_module_ok)) {
!           $savi_module_ok = eval { require SAVI };
!           $savi_module_ok = 0  if !defined $savi_module_ok;
! #
! # if the Amavis::AV::sophos_savi_init() in the following line _is_
! # called from here, SAVI-Perl will only initialize once during startup;
! # otherwise (if left uninitialized here) each child process will do the
! # SAVI-Perl initialization at its birth, which costs some time, but avoids
! # the need to restart amavisd when IDE database changes:
! ###       $savi_obj = Amavis::AV::sophos_savi_init(@$entry) if $savi_module_ok;
! 
!         }
!         if (!$savi_module_ok) { $entry->[1] = undef }  # disable entry
!         else { $entry->[2] = $savi_obj  if defined $savi_obj }  # save as args
        } elsif ($entry->[1] eq \&ask_clamav ||
                 $entry->[0] =~ /^Mail::ClamAV/) {
--- 10788,10794 ----
                 $entry->[1] eq \&sophos_savi ||
                 $entry->[0] eq 'Sophos SAVI') {
!         if (defined(eval { require SAVI }) && SAVI->VERSION(0.30) &&
!             Amavis::AV::sophos_savi_init(@$entry)) {}  # ok, loaded
!         else { $entry->[1] = undef }  # disable entry
        } elsif ($entry->[1] eq \&ask_clamav ||
                 $entry->[0] =~ /^Mail::ClamAV/) {
***************
*** 7848,7852 ****
  if (c('protocol') eq 'COURIER') {
    die "In::Courier code not available";
! } elsif (c('protocol') eq 'AM.PDP' || $unix_socketname ne '') {
    eval $extra_code_in_amcl or die "Problem in the In::AMCL code: $@";
    $extra_code_in_amcl = 1;    # release memory occupied by the source code
--- 10932,10936 ----
  if (c('protocol') eq 'COURIER') {
    die "In::Courier code not available";
! } elsif (c('protocol') eq 'AM.PDP') {
    eval $extra_code_in_amcl or die "Problem in the In::AMCL code: $@";
    $extra_code_in_amcl = 1;    # release memory occupied by the source code
***************
*** 7959,7963 ****
  
      # listen on the following sockets (one or more):
!     port => [ ($unix_socketname eq '' ? () : "$unix_socketname|unix"), # helper
                map { "$_/tcp" }             # accept SMTP on this port(s)
                    (ref $inet_socket_port ? @$inet_socket_port
--- 11043,11047 ----
  
      # listen on the following sockets (one or more):
!     port => [ (()), # DGM removed $unix_socketname as Maia cannot work in milter environment
                map { "$_/tcp" }             # accept SMTP on this port(s)
                    (ref $inet_socket_port ? @$inet_socket_port
***************
*** 7978,7981 ****
--- 11062,11066 ----
      chroot     => $daemon_chroot_dir ne '' ? $daemon_chroot_dir : undef,
      no_close_by_child => 1,
+     no_client_stdout => 1,
  
      # controls log level for Net::Server internal log messages:
***************
*** 8054,8057 ****
--- 11139,11143 ----
                 ['sysObjectID', 'OID', '1.3.6.1.4.1.15312.2.1'],
                   # iso.org.dod.internet.private.enterprise.ijs.amavisd-new.snmp
+                  # (the ijs OID will be replaced with Renaissoft's OID in v1.0.3)
                 ['sysUpTime',   'INT', int(time)],
                   # later it must be converted to timeticks (10ms since start)
***************
*** 8526,8530 ****
      do_log(4, "connect_to_sql: trying '$dsn'");
      $dbh = DBI->connect($dsn, $username, $password,
!                         {PrintError => 0, RaiseError => 0, Taint => 1} );
      if ($dbh) { do_log(3,"connect_to_sql: '$dsn' succeeded"); last }
      do_log(-1,"connect_to_sql: unable to connect to DSN '$dsn': ".$DBI::errstr);
--- 11612,11616 ----
      do_log(4, "connect_to_sql: trying '$dsn'");
      $dbh = DBI->connect($dsn, $username, $password,
!                         {PrintError => 0, RaiseError => 0, Taint => 0, AutoCommit => 1} );
      if ($dbh) { do_log(3,"connect_to_sql: '$dsn' succeeded"); last }
      do_log(-1,"connect_to_sql: unable to connect to DSN '$dsn': ".$DBI::errstr);
***************
*** 9431,9435 ****
  
  BEGIN {
!   import Amavis::Conf qw(:platform :confvars c cr ca);
    import Amavis::Util qw(ll do_log am_id new_am_id snmp_counters_init
                           prolong_timer debug_oneshot sanitize_str
--- 12517,12521 ----
  
  BEGIN {
!   import Amavis::Conf qw(:platform :confvars :dynamic_confvars c cr ca);
    import Amavis::Util qw(ll do_log am_id new_am_id snmp_counters_init
                           prolong_timer debug_oneshot sanitize_str
***************
*** 9699,9704 ****
        };
        /^HELP\z/ && do {
!         $self->smtp_resp(1,"214 2.0.0 See amavisd-new home page at:\n".
!                            "http://www.ijs.si/software/amavisd/");
          last;
        };
--- 12785,12790 ----
        };
        /^HELP\z/ && do {
!         $self->smtp_resp(1,"214 2.0.0 See Maia Mailguard home page at:\n".
!                            "http://www.maiamailguard.com/");
          last;
        };
***************
*** 9858,9862 ****
            $addr = ($addr =~ /^<(.*)>\z/s) ? $1 : $addr;
            $self->smtp_resp(0,"250 2.1.0 Sender $addr OK");
!           $sender = unquote_rfc2821_local($addr);
            debug_oneshot(lookup(0,$sender,@{ca('debug_sender_maps')}) ? 1 : 0,
                          $self->{proto} . "< $cmd");
--- 12944,12952 ----
            $addr = ($addr =~ /^<(.*)>\z/s) ? $1 : $addr;
            $self->smtp_resp(0,"250 2.1.0 Sender $addr OK");
!           if ($localpart_is_case_sensitive) {
!               $sender = unquote_rfc2821_local($addr);
!           } else {
!               $sender = lc(unquote_rfc2821_local($addr));
!           }
            debug_oneshot(lookup(0,$sender,@{ca('debug_sender_maps')}) ? 1 : 0,
                          $self->{proto} . "< $cmd");
***************
*** 9894,9898 ****
            my($addr,$opt) = ($1, $2);
            $addr = ($addr =~ /^<(.*)>\z/s) ? $1 : $addr;
!           my($addr_unq) = unquote_rfc2821_local($addr);
            my($recip_size_limit); my($mslm) = ca('message_size_limit_maps');
            $recip_size_limit = lookup(0,$addr_unq, @$mslm)  if @$mslm;
--- 12984,12993 ----
            my($addr,$opt) = ($1, $2);
            $addr = ($addr =~ /^<(.*)>\z/s) ? $1 : $addr;
!           my($addr_unq);
!           if ($localpart_is_case_sensitive) {
!               $addr_unq = unquote_rfc2821_local($addr);
!           } else {
!               $addr_unq = lc(unquote_rfc2821_local($addr));
!           }
            my($recip_size_limit); my($mslm) = ca('message_size_limit_maps');
            $recip_size_limit = lookup(0,$addr_unq, @$mslm)  if @$mslm;
***************
*** 10099,10102 ****
--- 13194,13202 ----
          do_log(2, Amavis::Timing::report());
          Amavis::Timing::init(); snmp_counters_init();
+         if ($Amavis::child_task_count >= $Amavis::max_requests) {
+           do_log(1, "Requesting process rundown after $Amavis::child_task_count ".
+ 	            "tasks (and $Amavis::child_invocation_count sessions)");
+           $terminating = 1;
+         }
          last;
        };  # DATA
***************
*** 10758,10761 ****
--- 13858,13862 ----
    import Amavis::Timing qw(section_time);
    import Amavis::Lookup qw(lookup);
+   import Amavis::Maia qw(maia_wblist_lookup);
  }
  
***************
*** 10790,10793 ****
--- 13891,13895 ----
      $spamassassin_obj->set_persistent_address_list_factory($addrlstfactory);
    }
+   $spamassassin_obj->{bayes_scanner} = new Mail::SpamAssassin::Bayes ($spamassassin_obj);
    $spamassassin_obj->compile_now;     # ensure all modules etc. are preloaded
    alarm(0);              # seems like SA forgets to clear alarm in some cases
***************
*** 10800,10805 ****
  # properties of each recipient object.
  #
! sub white_black_list($$$$$) {
!   my($conn,$msginfo,$sql_wblist,$user_id_sql,$ldap_policy) = @_;
    my($any_w)=0; my($any_b)=0; my($all)=1; my($wr,$br);
    my($sender) = $msginfo->sender;
--- 13902,13907 ----
  # properties of each recipient object.
  #
! sub white_black_list($$$$$$) {
!   my($conn,$msginfo,$sql_wblist,$user_id_sql,$ldap_policy,$dbh) = @_;
    my($any_w)=0; my($any_b)=0; my($all)=1; my($wr,$br);
    my($sender) = $msginfo->sender;
***************
*** 10814,10819 ****
      for my $ind (0..$#{$user_id_ref}) {  # for ALL SQL sets matching the recip
        my($user_id) = $user_id_ref->[$ind];  my($mkey);
!       ($wb,$mkey) = lookup(0,$sender,
!                 Amavis::Lookup::SQLfield->new($sql_wblist,'wb','S',$user_id) );
        do_log(4,"wbl: (SQL) recip <$recip>, rid=$user_id, got: \"$wb\"");
        if (!defined($wb)) {  # NULL field or no match: remains undefined
--- 13916,13920 ----
      for my $ind (0..$#{$user_id_ref}) {  # for ALL SQL sets matching the recip
        my($user_id) = $user_id_ref->[$ind];  my($mkey);
!       ($wb,$mkey) = maia_wblist_lookup($dbh, $user_id, $sender);
        do_log(4,"wbl: (SQL) recip <$recip>, rid=$user_id, got: \"$wb\"");
        if (!defined($wb)) {  # NULL field or no match: remains undefined
***************
*** 10873,10877 ****
        # NOTE on the specifics of $per_recip_blacklist_sender_lookup_tables :
        # the $r_ref below is supposed to be a ref to a single lookup table
!       # for compatibility with pre-2.0 versions of amavisd-new;
        # Note that this is different from @score_sender_maps, which is
        # supposed to contain a ref to a _list_ of lookup tables as a result
--- 13974,13978 ----
        # NOTE on the specifics of $per_recip_blacklist_sender_lookup_tables :
        # the $r_ref below is supposed to be a ref to a single lookup table
!       # for compatibility with pre-1.0 versions of amavisd-maia;
        # Note that this is different from @score_sender_maps, which is
        # supposed to contain a ref to a _list_ of lookup tables as a result
***************
*** 10949,10953 ****
  sub spam_scan($$) {
    my($conn,$msginfo) = @_;
!   my($spam_level, $spam_status, $spam_report); my(@lines);
    my($hdr_edits) = $msginfo->header_edits;
    if (!$hdr_edits) {
--- 14050,14055 ----
  sub spam_scan($$) {
    my($conn,$msginfo) = @_;
!   my($spam_level, $spam_status, $spam_report, $autolearn_status);
!   my(@lines);
    my($hdr_edits) = $msginfo->header_edits;
    if (!$hdr_edits) {
***************
*** 11061,11067 ****
          $spam_level  = $per_msg_status->get_hits;
          $sa_required = $per_msg_status->get_required_hits; # not used
!         $sa_tests    = $per_msg_status->get_names_of_tests_hit;
          $spam_report = $per_msg_status->get_report;  # taints $1 and $2 !
  
        # example of how to gather aditional information from SA:
        # my($trusted) = $per_msg_status->_get_tag('RELAYSTRUSTED');
--- 14163,14172 ----
          $spam_level  = $per_msg_status->get_hits;
          $sa_required = $per_msg_status->get_required_hits; # not used
!         $sa_tests    = $per_msg_status->get_tag('TESTSSCORES',',');
          $spam_report = $per_msg_status->get_report;  # taints $1 and $2 !
  
+         # 'ham', 'spam', 'no', 'disabled', 'failed', 'unavailable'
+         $autolearn_status = $per_msg_status->get_autolearn_status;
+ 
        # example of how to gather aditional information from SA:
        # my($trusted) = $per_msg_status->_get_tag('RELAYSTRUSTED');
***************
*** 11113,11117 ****
    }
    do_log(3,"spam_scan: hits=$spam_level $spam_status");
!   ($spam_level, $spam_status, $spam_report);
  }
  
--- 14218,14222 ----
    }
    do_log(3,"spam_scan: hits=$spam_level $spam_status");
!   ($spam_level, $spam_status, $spam_report, $autolearn_status);
  }
  
***************
*** 12350,12354 ****
  #
  # =============================================================================
! # This text section governs how a main per-message amavisd-new log entry
  # is formed. An empty text will prevent a log entry, multi-line text will
  # produce several log entries, one for each nonempty line.
--- 15455,15459 ----
  #
  # =============================================================================
! # This text section governs how a main per-message amavisd-maia log entry
  # is formed. An empty text will prevent a log entry, multi-line text will
  # produce several log entries, one for each nonempty line.
***************
*** 12389,12393 ****
  #
  # =============================================================================
! # This text section governs how a main per-recipient amavisd-new log entry
  # is formed. An empty text will prevent a log entry, multi-line text will
  # produce several log entries, one for each nonempty line.
--- 15494,15498 ----
  #
  # =============================================================================
! # This text section governs how a main per-recipient amavisd-maia log entry
  # is formed. An empty text will prevent a log entry, multi-line text will
  # produce several log entries, one for each nonempty line.
***************
*** 12429,12433 ****
  [%X\n]
  ]\
! This nondelivery report was generated by the amavisd-new program
  at host %h. Our internal reference code for your message
  is %n.
--- 15534,15538 ----
  [%X\n]
  ]\
! This nondelivery report was generated by the Maia Mailguard program
  at host %h. Our internal reference code for your message
  is %n.
