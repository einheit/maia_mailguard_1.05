#!/usr/bin/perl

# $Id: expire-quarantine-cache.pl 1528 2011-05-31 10:09:15Z rjl $

########################################################################
# MAIA MAILGUARD LICENSE v.1.0
#
# Copyright 2004 by Robert LeBlanc <rjl@renaissoft.com>
#                   David Morton   <mortonda@dgrmm.net>
# All rights reserved.
#
# PREAMBLE
#
# This License is designed for users of Maia Mailguard
# ("the Software") who wish to support the Maia Mailguard project by
# leaving "Maia Mailguard" branding information in the HTML output
# of the pages generated by the Software, and providing links back
# to the Maia Mailguard home page.  Users who wish to remove this
# branding information should contact the copyright owner to obtain
# a Rebranding License.
#
# DEFINITION OF TERMS
#
# The "Software" refers to Maia Mailguard, including all of the
# associated PHP, Perl, and SQL scripts, documentation files, graphic
# icons and logo images.
#
# GRANT OF LICENSE
#
# Redistribution and use in source and binary forms, with or without
# modification, are permitted provided that the following conditions
# are met:
#
# 1. Redistributions of source code must retain the above copyright
#    notice, this list of conditions and the following disclaimer.
#
# 2. Redistributions in binary form must reproduce the above copyright
#    notice, this list of conditions and the following disclaimer in the
#    documentation and/or other materials provided with the distribution.
#
# 3. The end-user documentation included with the redistribution, if
#    any, must include the following acknowledgment:
#
#    "This product includes software developed by Robert LeBlanc
#    <rjl@renaissoft.com>."
#
#    Alternately, this acknowledgment may appear in the software itself,
#    if and wherever such third-party acknowledgments normally appear.
#
# 4. At least one of the following branding conventions must be used:
#
#    a. The Maia Mailguard logo appears in the page-top banner of
#       all HTML output pages in an unmodified form, and links
#       directly to the Maia Mailguard home page; or
#
#    b. The "Powered by Maia Mailguard" graphic appears in the HTML
#       output of all gateway pages that lead to this software,
#       linking directly to the Maia Mailguard home page; or
#
#    c. A separate Rebranding License is obtained from the copyright
#       owner, exempting the Licensee from 4(a) and 4(b), subject to
#       the additional conditions laid out in that license document.
#
# THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDER AND CONTRIBUTORS
# "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
# LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS
# FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE
# COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT,
# INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING,
# BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS
# OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
# ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR
# TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE
# USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
########################################################################

    use DBI;
    use Getopt::Long;

    # constants
    use constant SECS_PER_HOUR => 60 * 60;
    use constant SECS_PER_DAY => SECS_PER_HOUR * 24;
    use constant SUSPECTED_NONSPAM =>   1; # Type H
    use constant SUSPECTED_SPAM =>      2; # Type S
    use constant VIRUSES =>             4; # Type V
    use constant BAD_HEADERS =>         8; # Type B
    use constant BANNED_ATTACHMENTS => 16; # Type F
    use constant CONFIRMED_NONSPAM =>  32; # Type G
    use constant CONFIRMED_SPAM =>     64; # Type C
    use constant ALL => (SUSPECTED_NONSPAM +
                         SUSPECTED_SPAM + 
                         VIRUSES +
                         BAD_HEADERS +
                         BANNED_ATTACHMENTS +
                         CONFIRMED_NONSPAM +
                         CONFIRMED_SPAM);

    my %types = (
                  "S" => "Suspected Spam",
                  "P" => "Suspected Spam (Labeled and delivered)",
                  "H" => "Suspected Non-Spam",
                  "V" => "Virus/Malware",
                  "B" => "Invalid Mail Header",
                  "F" => "Banned File Attachment",
                  "G" => "Confirmed Non-Spam",
                  "C" => "Confirmed Spam"
    );

    # prototypes
    sub fatal($);
    sub output($);
    sub get_db_type($);
    sub get_config_value($$);
    sub delete_mail_item($$);
    sub delete_mail_references($$$);
    sub run_expiry_query($$$);
    sub expire_quarantine($$);
    sub expire_ham_cache($$);
    sub expire_orphans($);
    sub expire_strays($);
    sub run_count_query($$);
    sub count_ham_cache($);
    sub count_q_cache($);
    sub expire_tokens($);
    sub update_mail_stats($$$);
    sub recalc_stats($);

    # name of this script
    my $script_name = "expire-quarantine-cache";

    # read configuration file (/etc/maia/maia.conf)
    my $config_file = "/etc/maia/maia.conf";
    unless (my $rv = do $config_file) {
        fatal(sprintf("Couldn't parse %s: %s", $config_file, $@)) if $@;
        fatal(sprintf("Couldn't open %s", $config_file)) if (!defined($rv) || !$rv);
    };

    $pid_dir = "/var/run/maia" if !defined($pid_dir);

    $pid_file = "$pid_dir/.expire-quarantine-cache.pid";

    # Check for existing lock file, remove any stale locks
    if (open(PID_FILE, "< $pid_file\0")) {
        my $pid;
        while (<PID_FILE>) { chomp; $pid = $_ if /^\d+\z/ }
        close(PID_FILE) or fatal(sprintf("Can't close file %s: %s", $pid_file, $!));
        if (!defined($pid)) {
            if ($debug) {
                output("Removing invalid lock file...");
            }
            unlink($pid_file);
        } elsif (kill 0 => $pid) {
            if (!$quiet) {
                output(sprintf("Another instance [%d] is currently running.", $pid));
            }
            exit;
        } else {
            if ($debug) {
                output(sprintf("Removing stale lock file [%d]...", $pid));
            }
            unlink($pid_file);
        }
    }

    # Write lock file, store PID
    open(PID_FILE, "> $pid_file\0") or fatal(sprintf("Can't write lock file %s", $pid_file));
    print PID_FILE "$$";
    close(PID_FILE);


    # defaults (overridden by settings in /etc/maia/maia.conf)
    $mail_types = (ALL - CONFIRMED_NONSPAM - CONFIRMED_SPAM) 
        if !defined($mail_types);

    my $suspected_nonspam = ($mail_types & SUSPECTED_NONSPAM) != 0;
    my $suspected_spam = ($mail_types & SUSPECTED_SPAM) != 0;
    my $viruses = ($mail_types & VIRUSES) != 0;
    my $bad_headers = ($mail_types & BAD_HEADERS) != 0;
    my $banned_files = ($mail_types & BANNED_ATTACHMENTS) != 0;
    my $confirmed_nonspam = ($mail_types & CONFIRMED_NONSPAM) != 0;
    my $confirmed_spam = ($mail_types & CONFIRMED_SPAM) != 0;
    my $help = 0;
    my $debug = 0;
    my $quiet = 0;

    GetOptions("suspected-nonspam|suspected-ham!" => \$suspected_nonspam,
               "suspected-spam!" => \$suspected_spam,
               "viruses!" => \$viruses,
               "bad-headers!" => \$bad_headers,
               "banned-files|banned-attachments!" => \$banned_files,
               "confirmed-nonspam|confirmed-ham!" => \$confirmed_nonspam,
               "confirmed-spam!" => \$confirmed_spam,
               "help" => \$help,
               "debug" => \$debug,
               "quiet" => \$quiet);

    # Display usage information
    if ($help) {
        output("expire-quarantine-cache.pl\n" .
           "   --suspected-nonspam    : expire Suspected Non-Spam items\n" .
           "   --nosuspected-nonspam  : don't expire Suspected Non-Spam items\n" .
           "   --suspected-ham        : same as --suspected-nonspam\n" .
           "   --nosuspected-ham      : same as --nosuspected-nonspam\n" .
           "   --suspected-spam       : expire Suspected Spam items\n" .
           "   --nosuspected-spam     : don't expire Suspected Spam items\n" .
           "   --viruses              : expire Virus/Malware items\n" .
           "   --noviruses            : don't expire Virus/Malware items\n" .
           "   --bad-headers          : expire items with Invalid Mail Headers\n" .
           "   --nobad-headers        : don't expire items with Invalid Mail Headers\n" .
           "   --banned-files         : expire items with Banned File Attachments\n" .
           "   --nobanned-files       : don't expire items with Banned File Attachments\n" .
           "   --banned-attachments   : same as --banned-files\n" .
           "   --nobanned-attachments : same as --nobanned-files\n" .
           "   --confirmed-nonspam    : expire Confirmed Non-Spam items\n" .
           "   --noconfirmed-nonspam  : don't expire Confirmed Non-Spam items\n" .
           "   --confirmed-ham        : same as --confirmed-nonspam\n" .
           "   --noconfirmed-ham      : same as --noconfirmed-nonspam\n" .
           "   --confirmed-spam       : expire Confirmed Spam items\n" .
           "   --noconfirmed-spam     : don't expire Confirmed Spam items\n" .
           "   --help                 : display this help text\n" .
           "   --debug                : display detailed debugging information\n" .
           "   --quiet                : display only error messages");
        exit;
    }

    # Sanity-check any supplied arguments
    if ($debug && $quiet) {
        $debug = 0;
        $quiet = 0;
        output("Warning: --debug and --quiet negate each other.");
    }
    if (!$suspected_nonspam && ($mail_types & SUSPECTED_NONSPAM)) {
        $mail_types -= SUSPECTED_NONSPAM;
    } elsif ($suspected_nonspam && !($mail_types & SUSPECTED_NONSPAM)) {
        $mail_types += SUSPECTED_NONSPAM;
    } 
    if (!$suspected_spam && ($mail_types & SUSPECTED_SPAM)) {
        $mail_types -= SUSPECTED_SPAM;
    } elsif ($suspected_spam && !($mail_types & SUSPECTED_SPAM)) {
        $mail_types += SUSPECTED_SPAM;
    } 
    if (!$viruses && ($mail_types & VIRUSES)) {
        $mail_types -= VIRUSES;
    } elsif ($viruses && !($mail_types & VIRUSES)) {
        $mail_types += VIRUSES;
    } 
    if (!$bad_headers && ($mail_types & BAD_HEADERS)) {
        $mail_types -= BAD_HEADERS;
    } elsif ($bad_headers && !($mail_types & BAD_HEADERS)) {
        $mail_types += BAD_HEADERS;
    } 
    if (!$banned_files && ($mail_types & BANNED_ATTACHMENTS)) {
        $mail_types -= BANNED_ATTACHMENTS;
    } elsif ($banned_files && !($mail_types & BANNED_ATTACHMENTS)) {
        $mail_types += BANNED_ATTACHMENTS;
    } 
    if (!$confirmed_nonspam && ($mail_types & CONFIRMED_NONSPAM)) {
        $mail_types -= CONFIRMED_NONSPAM;
    } elsif ($confirmed_nonspam && !($mail_types & CONFIRMED_NONSPAM)) {
        $mail_types += CONFIRMED_NONSPAM;
    } 
    if (!$confirmed_spam && ($mail_types & CONFIRMED_SPAM)) {
        $mail_types -= CONFIRMED_SPAM;
    } elsif ($confirmed_spam && !($mail_types & CONFIRMED_SPAM)) {
        $mail_types += CONFIRMED_SPAM;
    } 

    if ($debug) {
        output("Starting");
        output(sprintf("Expire Suspected Non-Spam                 : %s", 
               ($mail_types & SUSPECTED_NONSPAM) ? "Yes" : "No"));
        output(sprintf("Expire Suspected Spam                     : %s", 
               ($mail_types & SUSPECTED_SPAM) ? "Yes" : "No"));
        output(sprintf("Expire Viruses/Malware                    : %s", 
               ($mail_types & VIRUSES) ? "Yes" : "No"));
        output(sprintf("Expire items with Invalid Mail Headers    : %s", 
               ($mail_types & BAD_HEADERS) ? "Yes" : "No"));
        output(sprintf("Expire items with Banned File Attachments : %s", 
               ($mail_types & BANNED_ATTACHMENTS) ? "Yes" : "No"));
        output(sprintf("Expire Confirmed Non-Spam                 : %s", 
               ($mail_types & CONFIRMED_NONSPAM) ? "Yes" : "No"));
        output(sprintf("Expire Confirmed Spam                     : %s", 
               ($mail_types & CONFIRMED_SPAM) ? "Yes" : "No"));
    }

    my $dbh;

    # database configuration
    if (defined($dsn) && defined($username) && defined($password)) {
        $dbh = DBI->connect($dsn, $username, $password)
            or fatal("Can't connect to the Maia database (verify \$dsn, \$username, and \$password in maia.conf)");
    } else {
        fatal("Can't connect to the Maia database (missing \$dsn, \$username, or \$password in maia.conf)");
    }

    my ($s_count, $v_count, $b_count, $f_count, $c_count) = expire_quarantine($dbh, $mail_types);
    my ($h_count, $g_count) = expire_ham_cache($dbh, $mail_types);
    my $qcount = $s_count + $v_count + $b_count + $f_count + $c_count;
    my $hcount = $h_count + $g_count;
    my $cleanup = expire_orphans($dbh);
    my $strayclean = expire_strays($dbh);
    my $incomplete = expire_incomplete($dbh);
    recalc_stats($dbh) if ($qcount + $hcount + $cleanup + $strayclean > 0);

    my $cur_h_count = count_ham_cache($dbh);
    my ($cur_s_count, $cur_v_count, $cur_b_count, $cur_f_count) = count_q_cache($dbh);
    expire_tokens($dbh);

    if (!$quiet) {
        output(sprintf("%d Suspected Spam items expired", $s_count))
            if ($mail_types & SUSPECTED_SPAM);
        output(sprintf("%d Virus/Malware items expired", $v_count))
            if ($mail_types & VIRUSES);
        output(sprintf("%d items with Invalid Mail Headers expired", $b_count))
            if ($mail_types & BAD_HEADERS);
        output(sprintf("%d items with Banned File Attachments expired", $f_count))
            if ($mail_types & BANNED_ATTACHMENTS);
        output(sprintf("%d Confirmed Spam items expired", $c_count))
            if ($mail_types & CONFIRMED_SPAM);
        output(sprintf("%d Suspected Non-Spam items expired", $h_count))
            if ($mail_types & SUSPECTED_NONSPAM);
        output(sprintf("%d Confirmed Non-Spam items expired", $g_count))
            if ($mail_types & CONFIRMED_NONSPAM);
        if ($cleanup > 0) {
            output(sprintf("%d orphaned items expired", $cleanup));
        }
        if ($strayclean > 0) {
	    output(sprintf("%d stray references expired", $strayclean));
        }
        if ($incomplete > 0) {
            output(sprintf("%d incomplete references expired", $incomplete));
        }
        output("Current Cache After Expiration:");
        output(sprintf("Suspected Spam items               : %9d", $cur_s_count));
        output(sprintf("Virus/Malware items                : %9d", $cur_v_count));
        output(sprintf("Items with Invalid Mail Headers    : %9d", $cur_b_count));
        output(sprintf("Items with Banned File Attachments : %9d", $cur_f_count));
        output(sprintf("Suspected Non-Spam items           : %9d", $cur_h_count));
    }

    # Disconnect from the database
    $dbh->disconnect;

    unlink($pid_file);

    # We're done.
    exit;


    # Die, printing a time-stamped error message.
    sub fatal($) {
        my ($msg) = @_;

        output("FATAL ERROR: " . $msg);
        unlink($pid_file);
        exit 1;
    }


    # Write a time-stamped string to stdout for logging purposes.
    sub output($) {
        my ($msg) = @_;
        my ($year, $month, $day, $hour, $minute, $second);
        my ($second, $minute, $hour, $day, $month, $year) = (localtime)[0,1,2,3,4,5];

        printf("%04d-%02d-%02d %02d:%02d:%02d Maia: [%s] %s\n",
               $year+1900, $month+1, $day, $hour, $minute, $second, $script_name, $msg);
    }


    # Determine the database type: "mysql" or "pg"
    sub get_db_type($) {
    	my($dbh) = @_;

    	return $dbh->{Driver}->{Name};
    }


    # Read a single value from Maia's configuration table.
    sub get_config_value($$) {
        my($dbh, $key) = @_;
        my($sth, @row, $select);
        my $value = undef;

        $select = "SELECT " . $key . " FROM maia_config WHERE id = 0";
        $select = $1 if $select =~ /^(.*)$/si; # untaint
        $sth = $dbh->prepare($select)
                   or fatal(sprintf("Couldn't prepare query: %s", $dbh->errstr));
        $sth->execute()
            or fatal(sprintf("Couldn't execute query: %s", $dbh->errstr));
        if (@row = $sth->fetchrow_array()) {
            $value = $row[0];
        }
        $sth->finish;

        return $value;
    }


    # Delete one specific mail item and all references to it.
    sub delete_mail_item($$) {
    	my($dbh, $mail_id) = @_;
    	my($sth, $delete);

        $mail_id = $1 if $mail_id =~ /^([0-9]*)$/si; # untaint

        output(sprintf("Deleting mail item %d", $mail_id)) if $debug;

        # Delete the mail item itself
        $delete = "DELETE FROM maia_mail WHERE id = ?";
        $sth = $dbh->prepare($delete)
                    or fatal(sprintf("Couldn't prepare query: %s", $dbh->errstr));
        $sth->execute($mail_id)
            or fatal(sprintf("Couldn't execute query: %s", $dbh->errstr));

        # Delete all recipient references to the mail item
        $delete = "DELETE FROM maia_mail_recipients WHERE mail_id = ?";
        $sth = $dbh->prepare($delete)
                    or fatal(sprintf("Couldn't prepare query: %s", $dbh->errstr));
        $sth->execute($mail_id)
            or fatal(sprintf("Couldn't execute query: %s", $dbh->errstr));

        # Delete any virus references to the mail item
        $delete = "DELETE FROM maia_viruses_detected WHERE mail_id = ?";
        $sth = $dbh->prepare($delete)
                    or fatal(sprintf("Couldn't prepare query: %s", $dbh->errstr));
        $sth->execute($mail_id)
            or fatal(sprintf("Couldn't execute query: %s", $dbh->errstr));

        # Delete any SpamAssassin rule references to the mail item
        $delete = "DELETE FROM maia_sa_rules_triggered WHERE mail_id = ?";
        $sth = $dbh->prepare($delete)
                     or fatal(sprintf("Couldn't prepare query: %s", $dbh->errstr));
        $sth->execute($mail_id)
            or fatal(sprintf("Couldn't execute query: %s", $dbh->errstr));

        # Delete any banned file attachment references to the mail item
        $delete = "DELETE FROM maia_banned_attachments_found WHERE mail_id = ?";
        $sth = $dbh->prepare($delete)
                    or fatal(sprintf("Couldn't prepare query: %s", $dbh->errstr));
        $sth->execute($mail_id)
            or fatal(sprintf("Couldn't execute query: %s", $dbh->errstr));

    }


    # Delete mail references for all recipients who see this mail item
    # as mail of a specific type [SVBFCHG].
    # Delete the mail item itself if there are no other recipients.
    sub delete_mail_references($$$) {
        my($dbh, $mail_id, $type) = @_;
        my($sth, $delete, $select);

        $mail_id = $1 if $mail_id =~ /^([0-9]*)$/si; # untaint

        # Delete mail references for all recipients
        # who see this mail item as suspected spam,
        # virus-infected, a banned attachment, or an
        # invalid mail header.
        $delete = "DELETE FROM maia_mail_recipients " .
                  "WHERE type = ? " .
                  "AND mail_id = ?";

        $sth = $dbh->prepare($delete)
                   or fatal(sprintf("Couldn't prepare query: %s", $dbh->errstr));
        $sth->execute($type, $mail_id)
            or fatal(sprintf("Couldn't execute query: %s", $dbh->errstr));

        # See if any other mail references exist for this mail
        # item, i.e. any other recipients.
        $select = "SELECT recipient_id FROM maia_mail_recipients " .
                  "WHERE mail_id = ?";
        $sth = $dbh->prepare($select)
                   or fatal(sprintf("Couldn't prepare query: %s", $dbh->errstr));
        $sth->execute($mail_id)
            or fatal(sprintf("Couldn't execute query: %s", $dbh->errstr));

        # If no other recipients exist for this mail item,
        # delete the mail item itself.
        if (!$sth->fetchrow_array()) {
            delete_mail_item($dbh, $mail_id);
        }
        $sth->finish;
    }


    # Expire items of the specified type [SVBFCHG] that are older than
    # the specified number of days.
    sub run_expiry_query($$$) {
        my($dbh, $type, $days) = @_;
        my $dbtype = get_db_type($dbh);
        my $secs = $days * SECS_PER_DAY;
        my $count = 0;
        
        output(sprintf("Expiring %s items [%s] older than %d days", $types{$type}, $type, $days))
            if (!$quiet);
        my $select = "SELECT DISTINCT maia_mail.id, maia_mail.received_date " .
                     "FROM maia_mail, maia_mail_recipients " .
                     "WHERE maia_mail.id = maia_mail_recipients.mail_id " .
                     "AND (maia_mail_recipients.type = ?) ";
        if ($dbtype =~ /^mysql$/si) {
            $select .= "AND maia_mail.received_date < DATE_SUB(CURRENT_TIMESTAMP, INTERVAL " . $secs . " SECOND)";
        } elsif ($dbtype =~ /^pg$/si) {
            $select .= "AND maia_mail.received_date < NOW() - INTERVAL '" . $secs . " SECOND'";
        }
        my $sth = $dbh->prepare($select)
            or fatal(sprintf("Couldn't prepare query: %s", $dbh->errstr));
        $sth->execute($type)
            or fatal(sprintf("Couldn't execute query: %s", $dbh->errstr));
        while (my @row = $sth->fetchrow_array()) {
            output(sprintf("Deleting %s references to mail item %d", $types{$type}, $row[0]))
                if $debug;
            delete_mail_references($dbh, $row[0], $type);
            $count++;
        }
        $sth->finish;

        return $count;
    }


    # Expire quarantined items [SVBFC] older than the specified
    # expiration period.
    sub expire_quarantine($$) {
        my($dbh, $mail_types) = @_;
        my $s_count = 0;
        my $v_count = 0;
        my $b_count = 0;
        my $f_count = 0;
        my $c_count = 0;

        my $days = get_config_value($dbh, "expiry_period");
        $days = $1 if $days =~ /^([1-9]+[0-9]*)$/si; # untaint

        $s_count = run_expiry_query($dbh, "S", $days) if ($mail_types & SUSPECTED_SPAM);
        $s_count = $s_count + run_expiry_query($dbh, "P", $days) if ($mail_types & SUSPECTED_SPAM);
        $v_count = run_expiry_query($dbh, "V", $days) if ($mail_types & VIRUSES);
        $b_count = run_expiry_query($dbh, "B", $days) if ($mail_types & BAD_HEADERS);
        $f_count = run_expiry_query($dbh, "F", $days) if ($mail_types & BANNED_ATTACHMENTS);
        $c_count = run_expiry_query($dbh, "C", $days) if ($mail_types & CONFIRMED_SPAM);

        return ($s_count, $v_count, $b_count, $f_count, $c_count);
    }


    # Expire cached ham items [HG] older than the specified
    # expiration period.
    sub expire_ham_cache($$) {
        my($dbh, $mail_types) = @_;
        my $h_count = 0;
        my $g_count = 0;

        my $days = get_config_value($dbh, "ham_cache_expiry_period");
        $days = $1 if $days =~ /^([1-9]+[0-9]*)$/si; # untaint

        $h_count = run_expiry_query($dbh, "H", $days) if ($mail_types & SUSPECTED_NONSPAM);
        $g_count = run_expiry_query($dbh, "G", $days) if ($mail_types & CONFIRMED_NONSPAM);

        return ($h_count, $g_count);
    }


    # Expire orphaned items older than one hour.  Orphans are mail items
    # that exist in spite of the fact that no recipient references are
    # left pointing to it.  Orphans should not exist--they suggest that
    # a bug or some other database inconsistency is to blame--but we do
    # basic housecleaning here just in case.
    sub expire_orphans($) {
        my($dbh) = @_;
        my($select, $sth, @row);
        my($expiry_count);
        my $dbtype = get_db_type($dbh);

        output("Expiring Orphaned items (mail with no recipients) older than one hour")
            if (!$quiet);
        $select = "SELECT DISTINCT maia_mail.id " .
                  "FROM maia_mail " .
                  "LEFT JOIN maia_mail_recipients ".
                  "ON maia_mail.id = maia_mail_recipients.mail_id " .
                  "WHERE maia_mail_recipients.mail_id IS NULL ";
        if ($dbtype =~ /^mysql$/si) {
            $select .= "AND maia_mail.received_date < DATE_SUB(CURRENT_TIMESTAMP, INTERVAL " . 1 * SECS_PER_HOUR . " SECOND)";
        } elsif ($dbtype =~ /^pg$/si) {
            $select .= "AND maia_mail.received_date < NOW() - INTERVAL '" . 1 * SECS_PER_HOUR . " SECOND'";
        }
        $sth = $dbh->prepare($select)
                   or fatal(sprintf("Couldn't prepare query: %s", $dbh->errstr));
        $sth->execute()
            or fatal(sprintf("Couldn't execute query: %s", $dbh->errstr));
        $expiry_count = 0;
        while (@row = $sth->fetchrow_array()) {
            output(sprintf("Deleting ORPHAN %d", $row[0])) if $debug;
            delete_mail_item($dbh, $row[0]);
            $expiry_count++;
        }
        $sth->finish;

        return $expiry_count;
    }


    # Expire stray references.  Strays are references to mail items that
    # no longer exist.  Like orphans, these should not exist, and indicate
    # a bug or a database inconsistency.  We clean these up here for good
    # measure.
    sub expire_strays($) {
	my($dbh) = @_;
	my($select, $sth, @row);
	my($expiry_count);
      
	output("Expiring Stray References (recipient references with no mail items)")
            if (!$quiet);
	$select = "SELECT maia_mail_recipients.mail_id " .
                  "FROM maia_mail_recipients " .
                  "LEFT JOIN maia_mail " .
                  "ON maia_mail_recipients.mail_id = maia_mail.id " .
                  "WHERE maia_mail.id IS NULL ";

	$sth= $dbh->prepare($select)
	    or fatal(sprintf("Couldn't prepare query: %s", $dbh->errstr));
	$sth->execute()
            or fatal(sprintf("Couldn't execute query: %s", $dbh->errstr));
	$expiry_count = 0;
	while (@row = $sth->fetchrow_array()) {
	    output(sprintf("Deleting STRAY RECIPIENT %d", $row[0])) if $debug;
	    # calling delete_mail_item to delete the reference in case there are entries in other tables too.
	    delete_mail_item($dbh, $row[0]);
	    $expiry_count++;
	}
	$sth->finish;
	
	return $expiry_count;
    }

    # Expire old unprocessed entries.  If the server dies in the middle of a scan
    # It might be possible for these to exist...  Like orphans, these should not exist, and indicate
    # a bug or a database inconsistency.  We clean these up here for good
    # measure.
    sub expire_incomplete($) {
    my($dbh) = @_;
    my($select, $sth, @row);
    my($incomplete_count);

    output("Expiring Incomplete References (old references with incomplete status)")
            if (!$quiet);
    $select = "SELECT DISTINCT maia_mail.id FROM maia_mail_recipients
               LEFT JOIN maia_mail ON maia_mail_recipients.mail_id = maia_mail.id
               WHERE type='X' ";
    if ($dbtype =~ /^mysql$/si) {
       $select .= "AND maia_mail.received_date < DATE_SUB(CURRENT_TIMESTAMP, INTERVAL 1 DAY)";
    } elsif ($dbtype =~ /^pg$/si) {
       $select .= "AND maia_mail.received_date < NOW() - INTERVAL 1 DAY";
    }

    $sth= $dbh->prepare($select)
        or fatal(sprintf("Couldn't prepare query: %s", $dbh->errstr));
    $sth->execute()
            or fatal(sprintf("Couldn't execute query: %s", $dbh->errstr));
    $incomplete_count = 0;
    while (@row = $sth->fetchrow_array()) {
        output(sprintf("Deleting INCOMPLETE %d", $row[0])) if $debug;
        # calling delete_mail_item to delete the reference in case there are entries in other tables too.
        delete_mail_item($dbh, $row[0]);
        $incomplete_count++;
    }
    $sth->finish;

    return $incomplete_count;
    }


    # Return a count of the current number of items of the
    # specified type [SVBFCHG].
    sub run_count_query($$) {
        my($dbh, $type) = @_;
        my $count = 0;

	my $select = "SELECT COUNT(DISTINCT maia_mail_recipients.mail_id) " .
                     "FROM maia_mail_recipients " .
                     "WHERE maia_mail_recipients.type = ?";
	
	my $sth= $dbh->prepare($select)
	    or fatal(sprintf("Couldn't prepare query: %s", $dbh->errstr));
	$sth->execute($type)
	    or fatal(sprintf("Couldn't execute query: %s", $dbh->errstr));
	my @row = $sth->fetchrow_array();
	$count = $row[0];
	
	$sth->finish;

	return $count;
    }


    # Returns the total number of unconfirmed items in the ham cache.
    sub count_ham_cache($) {
        my($dbh) = @_;

        my $cur_h_count = run_count_query($dbh, "H");

        return ($cur_h_count);
    }


    # Returns the total number of unconfirmed items in the various quarantines.
    sub count_q_cache($) {
        my($dbh) = @_;

        my $cur_s_count = run_count_query($dbh, "S");
        $cur_s_count = $cur_s_count + run_count_query($dbh, "P");
        my $cur_v_count = run_count_query($dbh, "V");
        my $cur_b_count = run_count_query($dbh, "B");
        my $cur_f_count = run_count_query($dbh, "F");

        return ($cur_s_count, $cur_v_count, $cur_b_count, $cur_f_count);
    }


    # Expire token older than the specified
    # expiration period.
    sub expire_tokens($) {
        my($dbh) = @_;
        my($delete, $sth, @row);

        output("Expiring Tokens due to expire now") if (!$quiet);
        $delete = "DELETE FROM maia_tokens where expires < NOW()";
        $sth = $dbh->prepare($delete)
                   or fatal(sprintf("Couldn't prepare query: %s", $dbh->errstr));
        $sth->execute()
            or fatal(sprintf("Couldn't execute query: %s", $dbh->errstr));
        $sth->finish();
    }


    # Recalculate the suspected spam OR suspected ham statistics
    # for a specific user.
    sub update_mail_stats($$$) {
        my($dbh, $user_id, $type) = @_;
        my($sth, $sth2, $sth3, $sth4, @row, $select, $update, $insert);
      
        if ($type ne "suspected_spam" && $type ne "suspected_ham") {
            return;
        }

        # Calculate current aggregates for items of the specified type
        $select = "SELECT MIN(received_date) AS mindate, " .
                         "MAX(received_date) AS maxdate, " .
                         "MIN(score) AS minscore, " .
                         "MAX(score) AS maxscore, " .
                         "SUM(score) AS totalscore, " .
                         "MIN(size) AS minsize, " .
                         "MAX(size) AS maxsize, " .
                         "SUM(size) AS totalsize, " .
                         "COUNT(id) AS items " .
                  "FROM maia_mail, maia_mail_recipients " .
                  "WHERE maia_mail.id = maia_mail_recipients.mail_id " .
                  "AND maia_mail_recipients.type " .
                  ($type eq "suspected_spam" ? "IN ('S','P') " : "= 'H' ") .
                  "AND maia_mail_recipients.recipient_id = ? ";
        $sth = $dbh->prepare($select)
                   or fatal(sprintf("Couldn't prepare query: %s", $dbh->errstr));
        $sth->execute($user_id)
            or fatal(sprintf("Couldn't execute query: %s", $dbh->errstr));
        my($mindate, $maxdate, $minscore, $maxscore, $totalscore, $minsize, $maxsize, $totalsize, $items);
        if (($mindate, $maxdate, $minscore, $maxscore, $totalscore, $minsize, $maxsize, $totalsize, $items) = $sth->fetchrow()) {
            $select = "SELECT user_id FROM maia_stats WHERE user_id = ?";
            $sth2 = $dbh->prepare($select)
                        or fatal(sprintf("Couldn't prepare query: %s", $dbh->errstr));
            $sth2->execute($user_id)
                 or fatal(sprintf("Couldn't execute query: %s", $dbh->errstr));

            # User already has a stats record, update it.
            if ($user_id == $sth2->fetchrow()) {
                $update = "UPDATE maia_stats SET oldest_" . $type . "_date = ?, " .
                                                "newest_" . $type . "_date = ?, " .
                                                "lowest_" . $type . "_score = ?, " .
                                                "highest_" . $type . "_score = ?, " .
                                                "total_" . $type . "_score = ?, " .
                                                "smallest_" . $type . "_size = ?, " .
                                                "largest_" . $type . "_size = ?, " .
                                                "total_" . $type . "_size = ?, " .
                                                "total_" . $type . "_items = ? " .
                          "WHERE user_id = ?";
                                              
               $sth3 = $dbh->prepare($update)
                           or fatal(sprintf("Couldn't prepare query: %s", $dbh->errstr));
               $sth3->execute($mindate,
                              $maxdate,
                              (defined($minscore) ? $minscore : 0),
                              (defined($maxscore) ? $maxscore : 0),
                              (defined($totalscore) ? $totalscore : 0),
                              (defined($minsize) ? $minsize : 0),
                              (defined($maxsize) ? $maxsize : 0),
                              (defined($totalsize) ? $totalsize : 0),
                              (defined($items) ? $items : 0),
                              $user_id)
                    or fatal(sprintf("Couldn't execute query: %s", $dbh->errstr));
               $sth3->finish;

            # User doesn't have a stats record yet, create a new one for him.
            } else {
                $insert = "INSERT INTO maia_stats (oldest_" . $type . "_date, " .
                                                  "newest_" . $type . "_date, " .
                                                  "lowest_" . $type . "_score, " .
                                                  "highest_" . $type . "_score, " .
                                                  "total_" . $type . "_score, " .
                                                  "smallest_" . $type . "_size, " .
                                                  "largest_" . $type . "_size, " .
                                                  "total_" . $type . "_size, " .
                                                  "total_" . $type . "_items, " .
                                                  "user_id) " .
                          "VALUES (?,?,?,?,?,?,?,?,?,?)";
                $sth4 = $dbh->prepare($insert)
                            or fatal(sprintf("Couldn't prepare query: %s", $dbh->errstr));
                $sth4->execute($mindate,
                               $maxdate,
                               (defined($minscore) ? $minscore : 0),
                               (defined($maxscore) ? $maxscore : 0),
                               (defined($totalscore) ? $totalscore : 0),
                               (defined($minsize) ? $minsize : 0),
                               (defined($maxsize) ? $maxsize : 0),
                               (defined($totalsize) ? $totalsize : 0),
                               (defined($items) ? $items : 0),
                               $user_id)
                    or fatal(sprintf("Couldn't execute query: %s", $dbh->errstr));
                $sth4->finish;
            }
            $sth2->finish;
        }
        $sth->finish;
    }


    # Recalculate the suspected spam and suspected ham statistics
    # for all users.
    sub recalc_stats($) {
        my($dbh) = @_;
        my($sth, @row, $select, $user_id);

        output("Recalculating statistics") if (!$quiet);
        $select = "SELECT maia_users.id FROM maia_users";
        $sth = $dbh->prepare($select)
                   or fatal(sprintf("Couldn't prepare query: %s", $dbh->errstr));
        $sth->execute()
            or fatal(sprintf("Couldn't execute query: %s", $dbh->errstr));
        while (@row = $sth->fetchrow_array()) {
            $user_id = $1 if $row[0] =~ /^([0-9]+[0-9]*)$/si; # untaint
            update_mail_stats($dbh, $user_id, "suspected_spam");
            update_mail_stats($dbh, $user_id, "suspected_ham");
        }
      
        $sth->finish;
    }
