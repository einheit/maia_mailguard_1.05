#!/usr/bin/perl

# $Id: $

########################################################################
# MAIA MAILGUARD LICENSE v.1.0
#
# Copyright 2004 by Robert LeBlanc <rjl@renaissoft.com>
#                   David Morton   <mortonda@dgrmm.net>
# All rights reserved.
#
# PREAMBLE
#
# This License is designed for users of Maia Mailguard
# ("the Software") who wish to support the Maia Mailguard project by
# leaving "Maia Mailguard" branding information in the HTML output
# of the pages generated by the Software, and providing links back
# to the Maia Mailguard home page.  Users who wish to remove this
# branding information should contact the copyright owner to obtain
# a Rebranding License.
#
# DEFINITION OF TERMS
#
# The "Software" refers to Maia Mailguard, including all of the
# associated PHP, Perl, and SQL scripts, documentation files, graphic
# icons and logo images.
#
# GRANT OF LICENSE
#
# Redistribution and use in source and binary forms, with or without
# modification, are permitted provided that the following conditions
# are met:
#
# 1. Redistributions of source code must retain the above copyright
#    notice, this list of conditions and the following disclaimer.
#
# 2. Redistributions in binary form must reproduce the above copyright
#    notice, this list of conditions and the following disclaimer in the
#    documentation and/or other materials provided with the distribution.
#
# 3. The end-user documentation included with the redistribution, if
#    any, must include the following acknowledgment:
#
#    "This product includes software developed by Robert LeBlanc
#    <rjl@renaissoft.com>."
#
#    Alternately, this acknowledgment may appear in the software itself,
#    if and wherever such third-party acknowledgments normally appear.
#
# 4. At least one of the following branding conventions must be used:
#
#    a. The Maia Mailguard logo appears in the page-top banner of
#       all HTML output pages in an unmodified form, and links
#       directly to the Maia Mailguard home page; or
#
#    b. The "Powered by Maia Mailguard" graphic appears in the HTML
#       output of all gateway pages that lead to this software,
#       linking directly to the Maia Mailguard home page; or
#
#    c. A separate Rebranding License is obtained from the copyright
#       owner, exempting the Licensee from 4(a) and 4(b), subject to
#       the additional conditions laid out in that license document.
#
# THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDER AND CONTRIBUTORS
# "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
# LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS
# FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE
# COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT,
# INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING,
# BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS
# OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
# ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR
# TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE
# USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
########################################################################

use Getopt::Long;
use DBI;
use Net::SMTP;
use Digest::MD5;
use Text::CSV;


# prototypes
sub add_address($$$$$$$$);
sub add_address_to_user($$$$$$$);
sub add_domain($$$$);
sub add_policy($$$$);
sub address_domain($);
sub clear_awl($$$);
sub clear_bayes($$$);
sub dedupe($);
sub delete_address($$$$);
sub delete_domain($$$$);
sub delete_domain_admin_references($$$$);
sub delete_mail($$$$);
sub delete_mail_reference($$$$);
sub delete_user_mail_references($$$$);
sub delete_user_wb_entries($$$$);
sub delete_wb_entry($$$$$);
sub expire_bayes($$$);
sub fatal($);
sub filter_addresses($$$);
sub filter_domains($$);
sub generate_random_password();
sub get_address_type($);
sub get_email_address_priority($);
sub get_maia_user_row($$$$);
sub get_rewritten_address($$$);
sub get_user_from_address($$);
sub get_user_id($$$$$);
sub issue_password($$$$);
sub link_address($$$$$$$$$$);
sub output($);
sub prune_awl($$$$);
sub read_input_file($$$);
sub read_link_file($$);
sub read_address_file($$);
sub send_email($$$$$);
sub unconflict($$$);
sub valid_address($);
sub valid_domain($);
sub reset_password($$$$$);
sub convert_address_to_user_id($$$$);
sub link_address_from_ldif($$$$$$$$$$$);
sub import_wblist_csv($$$$);
sub export_wblist_csv($$$$);


# name of this script
my $script_name = "maiadbtool";

# read configuration file (/etc/maia/maia.conf)
my $config_file = "/etc/maia/maia.conf";
unless (my $rv = do $config_file) {
    fatal(sprintf("Couldn't parse %s: %s", $config_file, $@)) if $@;
    fatal(sprintf("Couldn't open %s", $config_file)) if (!defined($rv) || !$rv);
};

# defaults (overridden by settings in /etc/maia/maia.conf)
$sa_learn = "sa-learn" if !defined($sa_learn);
$address_rewriting_type = 0 if !defined($address_rewriting_type);
$routing_domain = "" if !defined($routing_domain);
$auth_method = "internal" if !defined($auth_method);
$preserve_case = 0 if !defined($preserve_case);

my @add_addresses = ();
my @delete_addresses = ();
my $delete_dependent_addresses;
my @add_domains = ();
my @delete_domains = ();
my @link_addresses = ();
my $link_from_ldif = undef;
my $account_attribute = undef;
my $address_atibute = undef;
my $autocreate_account = undef;
my @reset_passwords = ();
my $link_account = undef;
my $add_from_file = undef;
my $delete_from_file = undef;
my $link_from_file = undef;
my $export_wblist = undef;
my $import_wblist = undef;
my $reset_passwords_from_file = undef;
my $clear_bayes = 0;
my $clear_awl = 0;
my $expire_bayes = 0;
my $prune_awl = undef;
my $sysconfig_ref = {};
my $help = 0;
my $debug = 0;
my $quiet = 0;

GetOptions("add-address|add-addresses=s" => \@add_addresses,
           "delete-address|del-address|delete-addresses|del-addresses=s" => \@delete_addresses,
           "delete-dependent-addresses" => \$delete_dependent_addresses,
           "link-address|link-addresses=s" => \@link_addresses,
           "link-account=s" => \$link_account,
           "add-domain|add-domains=s" => \@add_domains,
           "delete-domain|del-domain|delete-domains|del-domains=s" => \@delete_domains,
           "add-from-file=s" => \$add_from_file,
           "delete-from-file|del-from-file=s" => \$delete_from_file,
           "export-wblist=s" => \$export_wblist,
           "import-wblist=s" => \$import_wblist,
           "link-from-file=s" => \$link_from_file,
           "link-from-ldif=s" => \$link_from_ldif,
           "autocreate-account" => \$autocreate_account,
           "account-attribute=s" => \$account_attribute,
           "address-attribute=s" => \$address_attribute,
           "reset-password|reset-passwords=s" => \@reset_passwords,
           "reset-password-from-file|reset-passwords-from-file=s" => \$reset_passwords_from_file,
           "address-rewriting-type=i" => \$address_rewriting_type,
           "routing-domain=s" => \$routing_domain,
           "auth-method|authentication-method=s" => \$auth_method,
           "clear-bayes" => \$clear_bayes,
           "clear-awl" => \$clear_awl,
           "expire-bayes" => \$expire_bayes,
           "prune-awl:s" => \$prune_awl,
           "sa-learn=s" => \$sa_learn,
           "preserve-case" => \$preserve_case,
           "help" => \$help,
           "debug" => \$debug,
           "quiet" => \$quiet);

@add_addresses = split(/,/, join(',', @add_addresses));
@delete_addresses = split(/,/, join(',', @delete_addresses));
@add_domains = split(/,/, join(',', @add_domains));
@delete_domains = split(/,/, join(',', @delete_domains));
@link_addresses = split(/,/, join(',', @link_addresses));
@reset_passwords = split(/,/, join(',', @reset_passwords));

# Display usage information
if ($help) {
    output("maiadbtool.pl\n" .
           "   --add-address addr1,addr2,...      : add one or more user e-mail addresses\n" .
           "   --add-addresses addr1,addr2,...    : same as --add-address\n" .
           "   --delete-address addr1,addr2,...   : delete one or more user e-mail addresses\n" .
           "   --del-address addr1,addr2,...      : same as --delete-address\n" .
           "   --delete-addresses addr1,addr2,... : same as --delete-address\n" .
           "   --del-addresses addr1,addr2,...    : same as --delete-address\n" .
           "   --link-address addr1,addr2,...     : link one or more addresses to a user account\n" .
           "   --link-addresses addr1,addr2,...   : same as --link-address\n" .
           "   --link-account address             : address of user to whom addresses should be linked\n" .
           "   --preserve-case                    : preserve the case of e-mail addresses\n" .
           "   --add-domain dom1,dom2,...         : add one or more domains\n" .
           "   --add-domains dom1,dom2,...        : same as --add-domain\n" .
           "   --delete-domain dom1,dom2,...      : delete one or more domains and all e-mail addresses in those domains\n" .
           "   --del-domain dom1,dom2,...         : same as --delete-domain\n" .
           "   --delete-domains dom1,dom2,...     : same as --delete-domain\n" .
           "   --del-domains dom1,dom2,...        : same as --delete-domain\n" .
           "   --reset-password addr1,addr2,...   : issue new temporary passwords for selected users\n" .
           "   --reset-passwords addr1,addr2,...  : same as --reset-password\n" .
           "   --add-from-file file               : add users and/or domains from a file\n" .
           "   --delete-from-file file            : delete users and/or domains from a file\n" .
           "   --del-from-file file               : same as --delete-from-file\n" .
           "   --link-from-file file              : link addresses to user accounts from a file\n" .
           "   --link-from-ldif file              : link addresses to user accounts from a LDIF file\n" .
           "   --import-wblist file               : import wblist from file, in CSV format:  user, address, type\n" .
           "   --export-wblist file               : export wblist into file, in CSV format:  user, address, type\n" .
           "   --autocreate-account               : autocreate accounts found in link file or ldif\n" .
           "   --account-attribute                : ldap attribute for the account name, use with link-from-ldif\n" .
           "   --address-attribute                : ldap attribute for the addresses, use with link-from-ldif\n" .
           "   --reset-passwords-from-file file   : issue new temporary passwords for users listed in a file\n" .
           "   --address-rewriting-type code      : address rewriting method [0..5] (see config.php)\n" .
           "   --routing-domain domain            : routing domain (see config.php)\n" .
           "   --auth-method method               : authentication method (see config.php)\n" .
           "   --authentication-method method     : same as --auth-method\n" .
           "   --clear-bayes                      : empty the Bayes database\n" .
           "   --clear-awl                        : empty the AWL database\n" .
           "   --expire-bayes                     : expire Bayes tokens\n" .
           "   --prune-awl [min]                  : prune the AWL database, removing entries with less than [min] occurrences\n" .
           "   --sa-learn path                    : path to your sa-learn script\n" .
           "   --help                             : display this help text\n" .
           "   --debug                            : display detailed debugging information\n" .
           "   --quiet                            : display only error messages");
    exit;
}

if (!defined($prune_awl)) {
    $prune_awl = 0;
} elsif ($prune_awl eq "") {
    $prune_awl = 2; # default minimum
}

# Resolve any debug/quiet conflicts
if ($debug && $quiet) {
    $debug = 0;
    $quiet = 0;
    output("Warning: --debug and --quiet negate each other.");
}

if ($clear_bayes && $expire_bayes) {
    $expire_bayes = 0;
    output("Warning: no point expiring the Bayes database when it's being cleared as well.");
}

if ($clear_awl && $prune_awl) {
    $prune_awl = 0;
    output("Warning: no point pruning the AWL database when it's being cleared as well.");
}

if (@link_addresses && !defined($link_account)) {
    @link_addresses = ();
    fatal("--link-account must be specified with --link-address.");
}

if ((@reset_passwords || defined($reset_passwords_from_file)) && lc($auth_method) ne 'internal') {
	@reset_passwords = ();
	$reset_passwords_from_file = undef;
	fatal("Passwords can only be reset when using internal authentication.");
}

# database configuration
if (defined($dsn) && defined($username) && defined($password)) {
	
	# connect to the database
    $dbh = DBI->connect($dsn, $username, $password)
        or fatal("Can't connect to the Maia database (verify \$dsn, \$username, and \$password in maia.conf)");

    # do a one-time load of some system configuration parameters
    my $query = "SELECT admin_email, " .
	                   "newuser_template_file, " .
	                   "reminder_login_url, " .
	                   "smtp_server, " .
	                   "smtp_port, " .
	                   "internal_auth " .
	            "FROM maia_config WHERE id = 0";
	my $sth = $dbh->prepare($query)
	              or fatal(sprintf("Couldn't prepare query: %s", $dbh->errstr));
	$sth->execute()
	    or fatal(sprintf("Couldn't execute query: %s", $dbh->errstr));
	if (my @row = $sth->fetchrow_array()) {
	    $sysconfig_ref->{'admin_email'} = $1 if $row[0] =~ /^(.+\@.+)$/si; # untaint
	    $sysconfig_ref->{'newuser_template_file'} = $1 if $row[1] =~ /^(.+)$/si; # untaint
	    $sysconfig_ref->{'login_url'} = $1 if $row[2] =~ /^(.+)$/si; # untaint
	    $sysconfig_ref->{'smtp_server'} = $1 if $row[3] =~ /^(.+)$/si; # untaint
	    $sysconfig_ref->{'smtp_port'} = $1 if $row[4] =~ /^([1-9]+[0-9]*)$/si; # untaint
	    $sysconfig_ref->{'issue_passwords'} = $1 if $row[5] =~ /^([YN])$/si; # untaint
	};
	$sth->finish;

} else {
    fatal("Can't connect to the Maia database (missing \$dsn, \$username, or \$password in maia.conf)");
}

if ((@reset_passwords || defined($reset_passwords_from_file)) && lc($sysconfig_ref->{'issue_passwords'}) ne 'y') {
	@reset_passwords = ();
	$reset_passwords_from_file = undef;
	fatal("Passwords can only be reset if the 'Auto-Issue Passwords' feature is enabled.");
}

#read from ldif and link accounts
if (defined($link_from_ldif)) {
    fatal("Cannot find ldif: $link_from_ldif")
        if (! -e $link_from_ldif);

    fatal("Must supply account-attribute and address-attribute")
        if (!(defined($account_attribute) && defined($address_attribute)));

    link_address_from_ldif($link_from_ldif,$account_attribute,$address_attribute,$autocreate_account,$dbh, $debug, $quiet, $address_rewriting_type, $routing_domain, $auth_method, $sysconfig_ref);
}

# Read the (optional) input files for addresses and domains to add or delete
read_input_file(\@add_addresses, \@add_domains, $add_from_file)
    if (defined($add_from_file));
read_input_file(\@delete_addresses, \@delete_domains, $delete_from_file)
    if (defined($delete_from_file));
read_link_file(\@link_addresses, $link_from_file)
    if (defined($link_from_file));
read_address_file(\@reset_passwords, $reset_passwords_from_file)
    if (defined($reset_passwords_from_file));

# Filter out any invalid addresses and domains
filter_addresses(\@add_addresses, $quiet, $preserve_case);
filter_addresses(\@delete_addresses, $quiet, $preserve_case);
filter_addresses(\@link_addresses, $quiet, $preserve_case);
filter_addresses(\@reset_passwords, $quiet, $preserve_case);
filter_domains(\@add_domains, $quiet);
filter_domains(\@delete_domains, $quiet);

# Convert addresses to user_ids for account-specific features
convert_address_to_user_id($dbh, \@reset_passwords, $quiet, $debug)
    if (@reset_passwords);

# Remove any duplicates
dedupe(\@add_addresses);
dedupe(\@delete_addresses);
dedupe(\@link_addresses);
dedupe(\@add_domains);
dedupe(\@delete_domains);
dedupe(\@reset_passwords);

# Identify any conflicting addresses and domains
unconflict(\@add_addresses, \@delete_addresses, $debug);
unconflict(\@add_domains, \@delete_domains, $debug);

# Delete domains
foreach my $domain (@delete_domains) {
    delete_domain($dbh, $domain, $debug, $quiet);
}

# Add domains
foreach my $domain (@add_domains) {
    add_domain($dbh, $domain, $debug, $quiet);
}

# Delete addresses
foreach my $address (@delete_addresses) {
    delete_address($dbh, $address, $debug, $quiet);
}

# Add addresses
foreach my $address (@add_addresses) {
    add_address($dbh, $address, $address_rewriting_type, 
                $routing_domain, $auth_method, $sysconfig_ref, $debug, $quiet);
}

# Link addresses
foreach my $address (@link_addresses) {
    link_address($dbh, $address, $link_account, $autocreate_account, $debug, $quiet, $address_rewriting_type, $routing_domain, $auth_method, $sysconfig_ref);
}

# Reset passwords
foreach my $user_id (@reset_passwords) {
	reset_password($dbh, $user_id, $sysconfig_ref, $debug, $quiet);
}

# import wblist
if ($import_wblist) {
    import_wblist_csv($dbh, $import_wblist, $debug, $quiet)
}

# export wblist
if ($export_wblist) {
    export_wblist_csv($dbh, $export_wblist, $debug, $quiet);
}

# Bayes clear/expire
if ($clear_bayes) {
    clear_bayes($dbh, $debug, $quiet);
} elsif ($expire_bayes) {
    expire_bayes($sa_learn, $debug, $quiet);
}

# AWL clear/prune
if ($clear_awl) {
    clear_awl($dbh, $debug, $quiet);
} elsif ($prune_awl) {
    prune_awl($prune_awl, $dbh, $debug, $quiet);
}

# Disconnect from the database
$dbh->disconnect;

exit;


########################################################################
###              End of Script: Subroutines begin below              ###
########################################################################

# Die, printing a time-stamped error message.
sub fatal($) {
    my ($msg) = @_;

    output("FATAL ERROR: " . $msg);
    exit 1;
}


# Write a time-stamped string to stdout for logging purposes.
sub output($) {
    my ($msg) = @_;
    my ($year, $month, $day, $hour, $minute, $second);
    my ($second, $minute, $hour, $day, $month, $year) = (localtime)[0,1,2,3,4,5];

    printf("%04d-%02d-%02d %02d:%02d:%02d Maia: [%s] %s\n",
           $year+1900, $month+1, $day, $hour, $minute, $second, $script_name, $msg);
}


# Verify that an e-mail address is syntactically valid
sub valid_address($) {
    my($address) = @_;
   
    return ($address =~ /^([0-9a-zA-Z]([-.\w]*[0-9a-zA-Z])*@([0-9a-z][-\w]*[0-9a-z]\.)+[a-z]{2,9})$/);
}


# Verify that a domain name is syntactically valid
sub valid_domain($) {
    my($domain) = @_;

    return ($domain =~ /^@([0-9a-z][-\w]*[0-9a-z]\.)+[a-z]{2,9}$/);
}


# Remove any invalid e-mail addresses from the list
sub filter_addresses($$$) {
    my($address_ref, $quiet, $preserve_case) = @_;

    my @valid = ();
    foreach my $address (@$address_ref) {
	    if (!$preserve_case) {
		    $address = lc($address);
	    } else {
		    if ($address =~ /^(.+)@(.+)$/) {
		       $address = $1 . '@' . lc($2);
	        }
	    }
        if (valid_address($address)) {
            push(@valid, $address);
        } else {
            output("Warning: Skipping invalid address '$address'")
                if (!$quiet);
        }
    }
    @$address_ref = @valid;
}


# Remove any invalid domain names from the list
sub filter_domains($$) {
    my($domain_ref, $quiet) = @_;

    my @valid = ();
    foreach my $domain (@$domain_ref) {
	    $domain = lc($domain);
        if (!($domain =~ /^@/)) {
            $domain = "@" . $domain;
        }
        if (valid_domain($domain)) {
            push(@valid, $domain);
        } else {
            output("Warning: Skipping invalid domain '$domain'")
                if (!$quiet);
        }
    }
    @$domain_ref = @valid;
}


# Remove any duplicate array elements
sub dedupe($) {
    my($array_ref) = @_;

    my %seen = ();
    foreach my $element (@$array_ref) {
        $seen{$element}++;
    }
    @$array_ref = keys %seen;
}


# Remove any array elements found on both the addition and deletion lists,
# since these would cancel each other out.
sub unconflict($$$) {
    my($add_ref, $del_ref, $debug) = @_;

    my %adding = ();
    my %deleting = ();
    foreach my $add (@$add_ref) {
        $adding{$add} = 1;
    }
    foreach my $del (@$del_ref) {
        $deleting{$del} = 1;
    }

    my @add_no_conflicts = ();
    foreach my $add (@$add_ref) {
        if (!$deleting{$add}) {
            push(@add_no_conflicts, $add);
        } else {
            output("Ignoring '$add': adding and deleting negate one another")
                if ($debug);
        }
    }
    @$add_ref = @add_no_conflicts;

    my @delete_no_conflicts = ();
    foreach my $del (@$del_ref) {
        if (!$adding{$del}) {
            push(@delete_no_conflicts, $del);
        }
    }
    @$del_ref = @delete_no_conflicts;
}


# Parse an input file for e-mail addresses and domain names, supplying a
# leading '@' for domain names that lack it.  Blank lines and whitespace
# should be ignored.
sub read_input_file($$$) {
    my($addresses_ref, $domains_ref, $infile) = @_;

    open (INFILE, "< $infile")
        or fatal("Can't read input file $infile: $!");
    while (<INFILE>) {
        chomp;
        if ($_ =~ /^\s*(.+@.+)\s*$/) {
            push(@$addresses_ref, $1);
        } elsif ($_ =~ /^\s*(@.+)\s*$/) {
            push(@$domains_ref, $1);
        } elsif ($_ =~ /^\s*([A-Za-z0-9\.\-]+)\s*$/) {
            push(@$domains_ref, "@" . $1);
        } else {
            # skip blank lines
        }
    }
    close INFILE;
}


# Parse an input file for lines containing a username or e-mail address
# followed by one or more e-mail addresses to link to it, separated by
# whitespace.  Blank lines and leading and trailing whitespace should be
# ignored.
sub read_link_file($$) {
    my($addresses_ref, $infile) = @_;

    open (INFILE, "< $infile")
        or fatal("Can't read input file $infile: $!");
    while (<INFILE>) {
        chomp;
    }
    close INFILE;
}


# Parse an input file for lines containing e-mail addresses.  Blank lines
# and whitespace should be ignored.
sub read_address_file($$) {
    my($addresses_ref, $infile) = @_;

    open (INFILE, "< $infile")
        or fatal("Can't read input file $infile: $!");
    while (<INFILE>) {
        chomp;
        if ($_ =~ /^\s*(.+@.+)\s*$/) {
            push(@$addresses_ref, $1);
        } else {
	        # skip blank lines
        }
    }
    close INFILE;
}


# Convert a list of email addresses to a list of user_ids
sub convert_address_to_user_id($$$$) {
	my($dbh, $addresses_ref, $quiet, $debug) = @_;
	my($sth, $query, $address, $user_id);
	
	my @user_id_list = ();
	$query = "SELECT maia_user_id FROM users WHERE email = ?";
	$sth = $dbh->prepare($query)
	           or fatal(sprintf("Couldn't prepare query: %s", $dbh->errstr));
	foreach $address (@$addresses_ref) {
	   $sth->execute($address)
	           or fatal(sprintf("Couldn't execute query: %s", $dbh->errstr));
	   $user_id = $sth->fetchrow();
	   output("Address '$address' maps to user_id $user_id") if ($debug);
	   push(@user_id_list, $user_id);
	}
	$sth->finish;
	@$addresses_ref = @user_id_list;
}


# Regenerate a random password for a given user and e-mail it to him
sub reset_password($$$$$) {
	my($dbh, $user_id, $sysconfig_ref, $debug, $quiet) = @_;
    my($sth, $query, $user_name, $email_addr);

    $query = "SELECT maia_users.user_name, users.email " .
             "FROM maia_users, users " .
             "WHERE maia_users.primary_email_id = users.id " .
             "AND maia_users.id = ?";
    $sth = $dbh->prepare($query)
               or fatal(sprintf("Couldn't prepare query: %s", $dbh->errstr));
    $sth->execute($user_id)
        or fatal(sprintf("Couldn't execute query: %s", $dbh->errstr));
    ($user_name, $email_addr) = $sth->fetchrow();
    $sth->finish;

    output("Issuing new password to user '$user_name' <$email_addr>") if (!$quiet);

    issue_password($dbh, $email_addr, $user_id, $sysconfig_ref);
}


# Delete a domain, and any e-mail addresses in that domain
sub delete_domain($$$$) {
    my($dbh, $domain, $debug, $quiet) = @_;
    my($sth, $query, $address);

    output("Deleting domain '$domain'") if (!$quiet);

    # delete any addresses in the domain
    $query = "SELECT email FROM users WHERE email LIKE '_%$domain'";
    $sth = $dbh->prepare($query)
               or fatal(sprintf("Couldn't prepare query: %s", $dbh->errstr));
    $sth->execute()
        or fatal(sprintf("Couldn't execute query: %s", $dbh->errstr));
    while (($address) = $sth->fetchrow()) {
        delete_address($dbh, $address, $debug, $quiet);
    }
    $sth->finish;

    # delete any references to this domain in the maia_domain_admins table
    delete_domain_admin_references($dbh, $domain, $debug, $quiet);

    output("Deleting domain record from maia_domains table") if ($debug);
    $query = "DELETE FROM maia_domains WHERE domain = ?";
    $sth = $dbh->prepare($query)
               or fatal(sprintf("Couldn't prepare query: %s", $dbh->errstr));
    $sth->execute($domain)
        or fatal(sprintf("Couldn't execute query: %s", $dbh->errstr));

    output("Deleting domain record from maia_users table") if ($debug);
    $query = "DELETE FROM maia_users WHERE user_name = ?";
    $sth = $dbh->prepare($query)
               or fatal(sprintf("Couldn't prepare query: %s", $dbh->errstr));
    $sth->execute($domain)
        or fatal(sprintf("Couldn't execute query: %s", $dbh->errstr));

    output("Deleting domain record from users table") if ($debug);
    $query = "DELETE FROM users WHERE email = ?";
    $sth = $dbh->prepare($query)
               or fatal(sprintf("Couldn't prepare query: %s", $dbh->errstr));
    $sth->execute($domain)
        or fatal(sprintf("Couldn't execute query: %s", $dbh->errstr));

    output("Deleting domain record from policy table") if ($debug);
    $query = "DELETE FROM policy WHERE policy_name = ?";
    $sth = $dbh->prepare($query)
               or fatal(sprintf("Couldn't prepare query: %s", $dbh->errstr));
    $sth->execute($domain)
        or fatal(sprintf("Couldn't execute query: %s", $dbh->errstr));

}


# Delete any domain administrator records associated with a domain
sub delete_domain_admin_references($$$$) {
    my($dbh, $domain, $debug, $quiet) = @_;
    my($sth, $sth2, $sth3, $query, $admin_id, $domain_id, $other_domain_id);

    # list all the admins that reference the target domain
    $query = "SELECT maia_domain_admins.admin_id, maia_domain_admins.domain_id " .
             "FROM maia_domain_admins, maia_domains " .
             "WHERE maia_domain_admins.domain_id = maia_domains.id " .
             "AND maia_domains.domain = ?";
    $sth = $dbh->prepare($query)
               or fatal(sprintf("Couldn't prepare query: %s", $dbh->errstr));
    $sth->execute($domain)
        or fatal(sprintf("Couldn't execute query: %s", $dbh->errstr));

    while (($admin_id, $domain_id) = $sth->fetchrow()) {

        # delete this admin's reference to the target domain
        $query = "DELETE FROM maia_domain_admins WHERE domain_id = ? AND admin_id = ?";
        $sth2 = $dbh->prepare($query)
                   or fatal(sprintf("Couldn't prepare query: %s", $dbh->errstr));
        $sth2->execute($domain_id, $admin_id)
            or fatal(sprintf("Couldn't execute query: %s", $dbh->errstr));

        # does this admin administer any other domains?
        $query = "SELECT domain_id FROM maia_domain_admins WHERE admin_id = ?";
        $sth2 = $dbh->prepare($query)
                   or fatal(sprintf("Couldn't prepare query: %s", $dbh->errstr));
        $sth2->execute($admin_id)
            or fatal(sprintf("Couldn't execute query: %s", $dbh->errstr));

        if (!(($other_domain_id) = $sth2->fetchrow())) {

            # no - return his privilege level to that of a normal user
            $query = "UPDATE maia_users SET user_level = 'U' WHERE id = ?";
            $sth3 = $dbh->prepare($query)
                       or fatal(sprintf("Couldn't prepare query: %s", $dbh->errstr));
            $sth3->execute($admin_id)
                or fatal(sprintf("Couldn't execute query: %s", $dbh->errstr));

        }
        $sth2->finish;


    }
    $sth->finish;
}


# Create a new policy record for an address or domain, based on defaults
# inherited from the domain-default or system-default policies.
sub add_policy($$$$) {
    my($dbh, $address, $debug, $quiet) = @_;
    my($sth, $query, $domain, $policy_id, $nodefault);
    my($virus_lover, $spam_lover, $banned_files_lover, $bad_header_lover);
    my($bypass_virus_checks, $bypass_spam_checks, $bypass_banned_checks, $bypass_header_checks);
    my($discard_viruses, $discard_spam, $discard_banned_files, $discard_bad_headers);
    my($spam_modifies_subj, $spam_tag_level, $spam_tag2_level, $spam_kill_level);

    $policy_id = 0;
    $domain = address_domain($address);
    $query = "SELECT virus_lover, " .
                    "spam_lover, " .
                    "banned_files_lover, " .
                    "bad_header_lover, " .
                    "bypass_virus_checks, " .
                    "bypass_spam_checks, " .
                    "bypass_banned_checks, " .
                    "bypass_header_checks, " .
                    "discard_viruses, " .
                    "discard_spam, " .
                    "discard_banned_files, " .
                    "discard_bad_headers, " .
                    "spam_modifies_subj, " .
                    "spam_tag_level, " .
                    "spam_tag2_level, " .
                    "spam_kill_level " .
             "FROM policy WHERE policy_name = ?";
    $sth = $dbh->prepare($query)
               or fatal(sprintf("Couldn't prepare query: %s", $dbh->errstr));

    # try to find a domain-based set of defaults for this user, based on his e-mail address
    $sth->execute($domain)
        or fatal(sprintf("Couldn't execute query: %s", $dbh->errstr));

    if (($virus_lover, $spam_lover, $banned_files_lover, $bad_header_lover,
         $bypass_virus_checks, $bypass_spam_checks, $bypass_banned_checks, $bypass_header_checks,
         $discard_viruses, $discard_spam, $discard_banned_files, $discard_bad_headers,
         $spam_modifies_subj, $spam_tag_level, $spam_tag2_level, $spam_kill_level) = $sth->fetchrow()) {

        $nodefault = 0;

    } else {

        # try to find a "Default" policy (@.) to copy defaults from
        $sth->execute('Default')
            or fatal(sprintf("Couldn't execute query: %s", $dbh->errstr));
        
        if (($virus_lover, $spam_lover, $banned_files_lover, $bad_header_lover,
             $bypass_virus_checks, $bypass_spam_checks, $bypass_banned_checks, $bypass_header_checks,
             $discard_viruses, $discard_spam, $discard_banned_files, $discard_bad_headers,
             $spam_modifies_subj, $spam_tag_level, $spam_tag2_level, $spam_kill_level) = $sth->fetchrow()) {

            $nodefault = 0;

        } else {

            # no suitable defaults found (should never get here)
            $nodefault = 1;
        }
    }
    $sth->finish;

    if ($nodefault) {

        # use the database defaults as our last resort.
        $query = "INSERT INTO policy (policy_name) VALUES (?)";
        $sth = $dbh->prepare($query)
            or fatal(sprintf("Couldn't prepare query: %s", $dbh->errstr));
        $sth->execute($address)
            or fatal(sprintf("Couldn't execute query: %s", $dbh->errstr));

    } else {

        # use the domain or system default values found above.
        $query = "INSERT INTO policy (policy_name, " .
                                     "virus_lover, " .
                                     "spam_lover, " .
                                     "banned_files_lover, " .
                                     "bad_header_lover, " .
                                     "bypass_virus_checks, " .
                                     "bypass_spam_checks, " .
                                     "bypass_banned_checks, " .
                                     "bypass_header_checks, " .
                                     "discard_viruses, " .
                                     "discard_spam, " .
                                     "discard_banned_files, " .
                                     "discard_bad_headers, " .
                                     "spam_modifies_subj, " .
                                     "spam_tag_level, " .
                                     "spam_tag2_level, " .
                                     "spam_kill_level" .
                 ") VALUES (?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?)";
        $sth = $dbh->prepare($query)
            or fatal(sprintf("Couldn't prepare query: %s", $dbh->errstr));
        $sth->execute($address,
                      $virus_lover,
                      $spam_lover,
                      $banned_files_lover,
                      $bad_header_lover,
                      $bypass_virus_checks,
                      $bypass_spam_checks,
                      $bypass_banned_checks,
                      $bypass_header_checks,
                      $discard_viruses,
                      $discard_spam,
                      $discard_banned_files,
                      $discard_bad_headers,
                      $spam_modifies_subj,
                      $spam_tag_level,
                      $spam_tag2_level,
                      $spam_kill_level)
            or fatal(sprintf("Couldn't execute query: %s", $dbh->errstr));

    }

    $query = "SELECT id FROM policy WHERE policy_name = ?";
    $sth = $dbh->prepare($query)
        or fatal(sprintf("Couldn't prepare query: %s", $dbh->errstr));
    $sth->execute($address)
        or fatal(sprintf("Couldn't execute query: %s", $dbh->errstr));
    if (!(($policy_id) = $sth->fetchrow())) {
        fatal("Couldn't find address '$address' in the policy table after insertion!");
    }
    $sth->finish;

    return $policy_id;
}


# Determine the address type:
#
#   0 : a plain domain name (e.g. example.com)
#   1 : a domain name with leading '@' (e.g. @example.com)
#   2 : an email address (e.g. joe@example.com)
sub get_address_type($) {
    my($address) = @_;

    my $pos = index($address, '@');
    if ($pos == -1) {      # "domain"
        return 0;
    } elsif ($pos > 0) {   # "user@domain"
        return 2;
    } else {               # "@domain"
        return 1;
    }
}


# Determine the priority value of an email address, based on
# how 'specific' it is.  The more dots it contains, the more
# specific we decide it to be.  Full email addresses (as
# opposed to domain names) are given additional priority.
sub get_email_address_priority($) {
    my($address) = @_;
    my($base);

    # give user@domain addresses more priority than @domain types
    my $address_type = get_address_type($address);
    if ($address_type == 2) {   # "user@domain"
        $base = 10;
    } else {
        $base = 0;
    }

    # give more specific addresses (i.e. addresses with more '.' in them)
    # higher priority.
    my $dot_count = 0;
    while ($address =~ /\./g) {
        $dot_count++;
    }

    return ($base + 2 * $dot_count);
}


# Determine the username to use for authentication purposes from
# an email address.  In most cases this is everything to the left of
# the last '@' in the address, but when $address_rewriting_type is 4
# the entire email address is treated as the username.
sub get_user_from_address($$) {
    my($address, $address_rewriting_type) = @_;

    if ($address_rewriting_type == 4) {  # entire address is the username
        return $address;
    } elsif ($address =~ /^(.+)@.+$/) {
        return $1;
    }
    return undef;
}


# Rewrite an email address according to the rules specified by the
# $address_rewriting_type:
#
#    0 : no rewriting is performed
#    1 : user@domain becomes user.domain@$routing_domain
#    2 : user@domain becomes user_domain@$routing_domain
#    3 : user@domain becomes user@domain@$routing_domain
#    4 : no rewriting is performed
#    5 : user@domain becomes user@$routing_domain
sub get_rewritten_address($$$) {
    my($address, $address_rewriting_type, $routing_domain) = @_;
    my($new_address);

    if ($address_rewriting_type == 1) {   # user.domain@isp

        $new_address = $address;
        $new_address =~ s/\@/\./g;
        $new_address .= "@" . $routing_domain;

    } elsif ($address_rewriting_type == 2) {   # user_domain@isp

        $new_address = $address;
        $new_address =~ s/[\@\.]/\_/g;
        $new_address .= "@" . $routing_domain;

    } elsif ($address_rewriting_type == 3) {   # user@domain@isp

        $new_address = $address . "@" . $routing_domain;

    } elsif ($address_rewriting_type == 5) {   # user@isp

        $new_address = get_user_from_address($address, $address_rewriting_type) . "@" . $routing_domain;

    } else {   # no rewriting for types 0 and 4

        $new_address = $address;

    }

    return $new_address;
}


# Adds an email address to the users table, linking it to a Maia user account
sub add_address_to_user($$$$$$$) {
    my($dbh, $policy_id, $address, $user_id, $domain_id, $debug, $quiet) = @_;

    output("Adding address '$address' to user account '$user_id'") if ($debug);
    $priority = get_email_address_priority($address);
    $query = "INSERT INTO users (policy_id, email, priority, maia_user_id, maia_domain_id) VALUES (?,?,?,?,?)";
    $sth = $dbh->prepare($query)
        or fatal(sprintf("Couldn't prepare query: %s", $dbh->errstr));
    $sth->execute($policy_id, $address, $priority, $user_id, $domain_id)
        or fatal(sprintf("Couldn't execute query: %s", $dbh->errstr));

    $query = "SELECT id FROM users WHERE email = ?";
    $sth = $dbh->prepare($query)
        or fatal(sprintf("Couldn't prepare query: %s", $dbh->errstr));
    $sth->execute($address)
        or fatal(sprintf("Couldn't execute query: %s", $dbh->errstr));
    if (!(($address_id) = $sth->fetchrow())) {
        fatal("Couldn't find address '$address' in the users table after insertion!");
    }
    $sth->finish;

    return $address_id;
}


# Reads a single Maia user's configuration data into a single-element array
# containing a hash of all the column values from the maia_users table.
# Elements can be referenced as, e.g. @$row[0]->{'user_name'}
sub get_maia_user_row($$$$) {
    my($dbh, $user_id, $debug, $quiet) = @_;
       
    $query = "SELECT * FROM maia_users WHERE id = ?";
    $sth = $dbh->prepare($query)
               or fatal(sprintf("Couldn't prepare query: %s", $dbh->errstr));
    $sth->execute($user_id)
        or fatal(sprintf("Couldn't execute query: %s", $dbh->errstr));
    if (!(($row) = $sth->fetchall_arrayref({}))) {
        fatal("Couldn't find user ID '$user_id' in the maia_users table!");
    }
    $sth->finish;

    return $row;
}


# Returns the ID of the Maia user account associated with a given
# username.
sub get_user_id($$$$$) {
    my($dbh, $user_name, $address, $debug, $quiet) = @_;

    my $user_id = 0;

    $query = "SELECT id FROM maia_users WHERE user_name = ?";
    $sth = $dbh->prepare($query)
               or fatal(sprintf("Couldn't prepare query: %s", $dbh->errstr));
    $sth->execute($user_name)
        or fatal(sprintf("Couldn't execute query: %s", $dbh->errstr));

    # try to look the user up by name first
    if (!(($user_id) = $sth->fetchrow())) {

        # now try looking the user up by e-mail address,
        # in case the user was "auto-created".
        $sth->execute($address)
            or fatal(sprintf("Couldn't execute query: %s", $dbh->errstr));
 
        if (($user_id) = $sth->fetchrow()) {

            # set the user's proper name in the database
            # record, to speed up future lookups.
            $query = "UPDATE maia_users SET user_name = ? WHERE id = ?";
            $sth = $dbh->prepare($query)
                or fatal(sprintf("Couldn't prepare query: %s", $dbh->errstr));
            $sth->execute($user_name, $user_id)
                or fatal(sprintf("Couldn't execute query: %s", $dbh->errstr));

        }
    }

    return $user_id;
}


# Add a new domain
sub add_domain($$$$) {
    my($dbh, $domain, $debug, $quiet) = @_;
    my($sth, $query, $existing_domain_id, $default_user_autocreation_policy);
    my($domain_id, $policy_id, $primary_email_id, $default_user_id);
    my($default_user_config, $maia_user_id);

    # make sure the domain doesn't already exist
    output("Making sure the '$domain' doesn't already exist") if ($debug);
    $query = "SELECT id FROM maia_domains WHERE domain = ?";
    $sth = $dbh->prepare($query)
               or fatal(sprintf("Couldn't prepare query: %s", $dbh->errstr));
    $sth->execute($domain)
        or fatal(sprintf("Couldn't execute query: %s", $dbh->errstr));
    if (($existing_domain_id) = $sth->fetchrow()) {
        output("Skipping domain '$domain', since it already exists") if (!$quiet);
        $sth->finish;
        return;
    } else {
        output("Adding domain '$domain'") if (!$quiet);
    }
    $sth->finish;

    # get global autocreation policy
    output("Looking up global creation policies") if ($debug);
    $query = "SELECT enable_user_autocreation, transport FROM maia_domains WHERE domain = '@.'";
    $sth = $dbh->prepare($query)
               or fatal(sprintf("Couldn't prepare query: %s", $dbh->errstr));
    $sth->execute()
        or fatal(sprintf("Couldn't execute query: %s", $dbh->errstr));
    if (!(($default_user_autocreation_policy, $default_transport) = $sth->fetchrow())) {
        $default_user_autocreation_policy = 'N';
        $default_transport = ':';
    }
    $sth->finish;

    # add the domain to the maia_domains table
    output("Adding '$domain' to the maia_domains table") if ($debug);
    $query = "INSERT INTO maia_domains (domain, enable_user_autocreation, routing_domain, transport) VALUES (?,?,?,?)";
    $sth = $dbh->prepare($query)
               or fatal(sprintf("Couldn't prepare query: %s", $dbh->errstr));
    $sth->execute($domain, $default_user_autocreation_policy, substr($domain,1), $default_transport)
        or fatal(sprintf("Couldn't execute query: %s", $dbh->errstr));

    $query = "SELECT id FROM maia_domains WHERE domain = ?";
    $sth = $dbh->prepare($query)
               or fatal(sprintf("Couldn't prepare query: %s", $dbh->errstr));
    $sth->execute($domain)
        or fatal(sprintf("Couldn't execute query: %s", $dbh->errstr));
    if (!(($domain_id) = $sth->fetchrow())) {
        fatal("Couldn't find domain '$domain' in the maia_domains table after insertion!");
    }

    # add a new policy for the domain, based on the system defaults
    $policy_id = add_policy($dbh, $domain, $debug, $quiet);

    # add the domain default address to the users table
    $primary_email_id = add_address_to_user($dbh, $policy_id, $domain, 0, $domain_id, $debug, $quiet);

    # add the domain default account to the maia_users table
    $default_user_id = get_user_id($dbh, "@.", "@.", $debug, $quiet);
    $default_user_config = get_maia_user_row($dbh, $default_user_id, $debug, $quiet);
    output("Adding a domain-default account to the maia_users table for '$domain'") if ($debug);
    $query = "INSERT INTO maia_users (user_name, primary_email_id, reminders, theme_id, " .
                                     "charts, language, charset, auto_whitelist, items_per_page, " .
                                     "quarantine_digest_interval, truncate_subject, truncate_email) " .
             "VALUES (?,?,'N',?,?,?,?,?,?,?,?,?)";
    $sth = $dbh->prepare($query)
               or fatal(sprintf("Couldn't prepare query: %s", $dbh->errstr));
    $sth->execute($domain,
                  $primary_email_id,
                  @$default_user_config[0]->{'theme_id'},
                  @$default_user_config[0]->{'charts'},
                  @$default_user_config[0]->{'language'},
                  @$default_user_config[0]->{'charset'},
                  @$default_user_config[0]->{'auto_whitelist'},
                  @$default_user_config[0]->{'items_per_page'},
                  @$default_user_config[0]->{'quarantine_digest_interval'},
                  @$default_user_config[0]->{'truncate_subject'},
                  @$default_user_config[0]->{'truncate_email'})
        or fatal(sprintf("Couldn't execute query: %s", $dbh->errstr));

    $query = "SELECT id FROM maia_users WHERE user_name = ?";
    $sth = $dbh->prepare($query)
               or fatal(sprintf("Couldn't prepare query: %s", $dbh->errstr));
    $sth->execute($domain)
        or fatal(sprintf("Couldn't execute query: %s", $dbh->errstr));
    if (!(($maia_user_id) = $sth->fetchrow())) {
        fatal("Couldn't find user '$domain' in the maia_users table after insertion!");
    }
    $sth->finish;

    # update the users table to link the e-mail address back to the domain
    output("Linking the '$domain' address to the '$domain' domain-default account") if ($debug);
    $query = "UPDATE users SET maia_user_id = ? WHERE id = ?";
    $sth = $dbh->prepare($query)
               or fatal(sprintf("Couldn't prepare query: %s", $dbh->errstr));
    $sth->execute($maia_user_id, $primary_email_id)
        or fatal(sprintf("Couldn't execute query: %s", $dbh->errstr));

}

# Delete a policy row
sub delete_policy_row($$$$) {
    my($dbh, $policy_id, $debug, $quiet) = @_;
    my( $sth, $query);

    output("Deleting address record from policy table, id '$policy_id'") if ($debug);
    $query = "DELETE FROM policy WHERE id = ?";
    $sth = $dbh->prepare($query)
               or fatal(sprintf("Couldn't prepare query: %s", $dbh->errstr));
    $sth->execute($policy_id)
        or fatal(sprintf("Couldn't execute query: %s", $dbh->errstr));

}

# delete user row
sub delete_user_row($$$$) {
    my($dbh, $user_id, $debug, $quiet) = @_;
    my( $sth, $query);

    output("Deleting address record from user table, id '$user_id'") if ($debug);
    $query = "DELETE FROM users WHERE id = ?";
    $sth = $dbh->prepare($query)
               or fatal(sprintf("Couldn't prepare query: %s", $dbh->errstr));
    $sth->execute($user_id)
        or fatal(sprintf("Couldn't execute query: %s", $dbh->errstr));
}


# Delete an e-mail address
sub delete_address($$$$) {
    my($dbh, $address, $debug, $quiet) = @_;
    my($sth, $sth2, $sth3, $query, $maia_user_id, $policy_id, $maia_user_name, $address_id, $new_primary_address);

    output("Deleting e-mail address '$address'") if (!$quiet);

    $query = "SELECT users.id, users.policy_id, users.maia_user_id, maia_users.user_name, maia_users.primary_email_id " .
             "FROM users, maia_users " .
             "WHERE users.maia_user_id = maia_users.id " .
             "AND users.email = ?";
    $sth = $dbh->prepare($query)
               or fatal(sprintf("Couldn't prepare query: %s", $dbh->errstr));
    $sth->execute($address)
        or fatal(sprintf("Couldn't execute query: %s", $dbh->errstr));
    if (($address_id, $policy_id, $maia_user_id, $maia_user_name, $primary_email_id) = $sth->fetchrow()) {

        # was this address the owner's primary address?
        if ($address_id == $primary_email_id) {
            # yes - does the address owner own any other addresses?
            $query = "SELECT id, policy_id, email FROM users WHERE maia_user_id = ? AND id <> ?";
            $sth2 = $dbh->prepare($query)
                       or fatal(sprintf("Couldn't prepare query: %s", $dbh->errstr));
            $sth2->execute($maia_user_id, $address_id)
                or fatal(sprintf("Couldn't execute query: %s", $dbh->errstr));
            while (($other_address_id, $other_policy_id, $other_email) = $sth2->fetchrow()) {
                # yes - we can't delete main address unless override is set.
                if (! $delete_dependent_addresses) {
                  fatal("Address has linked addresses, aborting.");
                } else {
                  # override is set, delete all linked addresses...
                  output("Deleting linked account '$other_email' by requested override") if ($debug);
                  delete_policy_row($dbh,$other_policy_id,$debug,$quiet);
                  delete_user_row($dbh,$other_address_id,$debug,$quiet);
                }
            }

            # at this point, either we have died or this is a primary account and no dependent addresses exist
            # it's now safe to delete the user account as well

            delete_policy_row($dbh,$policy_id,$debug,$quiet);
            delete_user_row($dbh,$address_id,$debug,$quiet);

            output("Deleting user account '$maia_user_name', since it owns no other addresses") if ($debug);
            $query = "DELETE FROM maia_users WHERE id = ?";
            $sth3 = $dbh->prepare($query)
            or fatal(sprintf("Couldn't prepare query: %s", $dbh->errstr));
            $sth3->execute($maia_user_id)
            or fatal(sprintf("Couldn't execute query: %s", $dbh->errstr));

            output("Deleting administrator records for user account '$maia_user_name'") if ($debug);
            $query = "DELETE FROM maia_domain_admins WHERE admin_id = ?";
            $sth3 = $dbh->prepare($query)
            or fatal(sprintf("Couldn't prepare query: %s", $dbh->errstr));
            $sth3->execute($maia_user_id)
            or fatal(sprintf("Couldn't execute query: %s", $dbh->errstr));

            output("Deleting current statistics for user account '$maia_user_name'") if ($debug);
            $query = "DELETE FROM maia_stats WHERE user_id = ?";
            $sth3 = $dbh->prepare($query)
            or fatal(sprintf("Couldn't prepare query: %s", $dbh->errstr));
            $sth3->execute($maia_user_id)
            or fatal(sprintf("Couldn't execute query: %s", $dbh->errstr));

            output("Deleting statistics history for user account '$maia_user_name'") if ($debug);
            $query = "DELETE FROM maia_stats_history WHERE user_id = ?";
            $sth3 = $dbh->prepare($query)
            or fatal(sprintf("Couldn't prepare query: %s", $dbh->errstr));
            $sth3->execute($maia_user_id)
            or fatal(sprintf("Couldn't execute query: %s", $dbh->errstr));

            delete_user_mail_references($dbh, $maia_user_id, $debug, $quiet);
            delete_user_wb_entries($dbh, $maia_user_id, $debug, $quiet);
        } else {
            #this is not a primary account, so just delete the linked rows
            delete_policy_row($dbh,$policy_id,$debug,$quiet);
            delete_user_row($dbh,$address_id,$debug,$quiet);
        }
        $sth->finish;

    } else {
        output("Address '$address' does not exist, skipping") if (!$quiet);
    }
}


# Returns a randomly-generated 8-character alphanumeric
# password and its 32-byte MD5 hash.
sub generate_random_password() {
    my(@chars, $password, $digest);
    my($md5) = Digest::MD5->new;

    @chars = ("A".."Z", "a".."z", 0..9);
    $password = join("", @chars[ map { rand @chars } (1..8) ]);
    $md5->add($password);
    $digest = $1 if $md5->hexdigest =~ /^([0-9a-f]{32})$/; # untaint

    return ($password, $digest);
}


# Sends an e-mail via the downstream MTA
sub send_email($$$$$) {
    my ($smtp_server, $smtp_port, $from, $to, $body) = @_;

    my($smtp) = Net::SMTP->new($smtp_server, Port => $smtp_port) ;
    fatal("Couldn't connect to SMTP server: $!") unless $smtp;
    $smtp->mail($from) ;
    $smtp->to($to) ;
    $smtp->data() ;
    $smtp->datasend($body . "\n") ;
    $smtp->dataend() ;
    $smtp->quit() ;
}


# Assigns a random password to a new user and sends
# the user an e-mail with temporary login credentials.
sub issue_password($$$$) {
    my ($dbh, $user_email, $user_id, $sysconfig_ref) = @_;
    my ($update, $sth);

    # Read the e-mail template file into memory once
    open TEMPLATEFILE, "<" . $sysconfig_ref->{'newuser_template_file'}
        or fatal("Unable to open '$sysconfig_ref->{'newuser_template_file'}': $!");
    my($template) = "";
    my($line);
    while ($line = <TEMPLATEFILE>) {
        $template .= $line;
    }
    close TEMPLATEFILE;

    # generate a random password
    my($password, $digest) = generate_random_password();

    my $query = "UPDATE maia_users SET password = ? WHERE id = ?";
    $sth = $dbh->prepare($query)
               or fatal(sprintf("Couldn't prepare query: %s", $dbh->errstr));
    $sth->execute($digest, $user_id)
        or fatal(sprintf("Couldn't execute query: %s", $dbh->errstr));

    # Perform substitutions in the template
    my($body) = $template;
    $body =~ s/%%LOGIN%%/$user_email/g;
    $body =~ s/%%PASSWORD%%/$password/g;
    $body =~ s/%%ADMINEMAIL%%/$sysconfig_ref->{'admin_email'}/g;
    $body =~ s/%%LOGINURL%%/$sysconfig_ref->{'login_url'}/g;

    # Send the e-mail
    send_email($sysconfig_ref->{'smtp_server'}, 
               $sysconfig_ref->{'smtp_port'}, 
               $sysconfig_ref->{'admin_email'}, 
               $user_email,
               $body);
}


# Add an e-mail address, and its domain if necessary
sub add_address($$$$$$$$) {
    my($dbh, $address, $address_rewriting_type, $routing_domain, $auth_method, 
	   $sysconfig_ref, $debug, $quiet) = @_;
    my($sth, $query, $domain, $default_domain_id, $default_domain_config);
    my($existing_address_id, $existing_domain_id, $user_name, $new_address);
    my($policy_id, $primary_address_id, $user_id);

    # determine the username and the rewritten e-mail address
    if ((lc($auth_method) eq 'pop3') && ($routing_domain ne '')) {
        $user_name = get_user_from_address($address, $address_rewriting_type);
        $new_address = $user_name . "@" . $routing_domain;
    } elsif (lc($auth_method) eq 'imap') {
        $new_address = get_rewritten_address($address, $address_rewriting_type, $routing_domain);
        $user_name = get_user_from_address($new_address, $address_rewriting_type);
    } elsif (lc($auth_method) eq 'internal') {
        $new_address = get_rewritten_address($address, $address_rewriting_type, $routing_domain);
        $user_name = $new_address;
    } else {
        $new_address = $address;
        $user_name = get_user_from_address($address, $address_rewriting_type);
    }
    if (!defined($user_name)) {
        output("Skipping invalid address '$address' (rewritten as '$new_address')") if (!$quiet);
        return;
    }
    if ($address ne $new_address) {
        output("Address '$address' rewritten as '$new_address'") if ($debug);
    }
    output("Username for authentication purposes is '$user_name'") if ($debug);

    # make sure the address doesn't already exist
    output("Making sure address '$new_address' doesn't already exist") if ($debug);
    $query = "SELECT id FROM users WHERE email = ?";
    $sth = $dbh->prepare($query)
               or fatal(sprintf("Couldn't prepare query: %s", $dbh->errstr));
    $sth->execute($new_address)
        or fatal(sprintf("Couldn't execute query: %s", $dbh->errstr));
    if (($existing_address_id) = $sth->fetchrow()) {
        output("Skipping address '$new_address', since it already exists") if (!$quiet);
        $sth->finish;
        return;
    } else {
        output("Adding address '$new_address'") if (!$quiet);
    }
    $sth->finish;

    # create the domain if necessary
    $domain = address_domain($new_address);
    output("Verifying that the '$domain' domain exists") if ($debug);
    $query = "SELECT id FROM maia_domains WHERE domain = ?";
    $sth = $dbh->prepare($query)
               or fatal(sprintf("Couldn't prepare query: %s", $dbh->errstr));
    $sth->execute($domain)
        or fatal(sprintf("Couldn't execute query: %s", $dbh->errstr));
    if (!(($existing_domain_id) = $sth->fetchrow())) {
        add_domain($dbh, $domain, $debug, $quiet);
    }
    $sth->finish;

    # get domain-default configuration 
    $default_domain_id = get_user_id($dbh, $domain, $domain, $debug, $quiet);
    $default_domain_config = get_maia_user_row($dbh, $default_domain_id, $debug, $quiet);

    # add an entry to the maia_users table
    $query = "INSERT INTO maia_users (user_name, theme_id, reminders, charts, language, " .
                                     "charset, auto_whitelist, items_per_page, " .
                                     "quarantine_digest_interval, truncate_subject, truncate_email) " .
             "VALUES (?,?,?,?,?,?,?,?,?,?,?)";
    $sth = $dbh->prepare($query)
               or fatal(sprintf("Couldn't prepare query: %s", $dbh->errstr));
    $sth->execute($user_name,
                  @$default_domain_config[0]->{'theme_id'},
                  @$default_domain_config[0]->{'reminders'},
                  @$default_domain_config[0]->{'charts'},
                  @$default_domain_config[0]->{'language'},
                  @$default_domain_config[0]->{'charset'},
                  @$default_domain_config[0]->{'auto_whitelist'},
                  @$default_domain_config[0]->{'items_per_page'},
                  @$default_domain_config[0]->{'quarantine_digest_interval'},
                  @$default_domain_config[0]->{'truncate_subject'},
                  @$default_domain_config[0]->{'truncate_email'})
        or fatal(sprintf("Couldn't execute query: %s", $dbh->errstr));

    # get the UID of this new record
    $query = "SELECT id FROM maia_users WHERE user_name = ?";
    $sth = $dbh->prepare($query)
               or fatal(sprintf("Couldn't prepare query: %s", $dbh->errstr));
    $sth->execute($user_name)
        or fatal(sprintf("Couldn't execute query: %s", $dbh->errstr));
    if (!(($user_id) = $sth->fetchrow())) {
        fatal("Couldn't find user '$user_name' in the maia_users table after insertion!");
    }
    $sth->finish;

    # add a new policy for the address, based on the domain defaults
    $policy_id = add_policy($dbh, $new_address, $debug, $quiet);

    # add the address to the users table
    $primary_address_id = add_address_to_user($dbh, $policy_id, $new_address, $user_id, 0, $debug, $quiet);

    # Make this address the user's primary address
    $query = "UPDATE maia_users SET primary_email_id = ? WHERE id = ?";
    $sth = $dbh->prepare($query)
               or fatal(sprintf("Couldn't prepare query: %s", $dbh->errstr));
    $sth->execute($primary_address_id, $user_id)
        or fatal(sprintf("Couldn't execute query: %s", $dbh->errstr));

    # generate a random password and email it to the new user if necessary
    if (lc($auth_method) eq 'internal' && lc($sysconfig_ref->{'issue_passwords'}) eq 'y') {
        issue_password($dbh, $new_address, $user_id, $sysconfig_ref);
    }

    return $user_id;
}


# Link an e-mail address to a user account
sub link_address($$$$$$$$$$) {
    my($dbh, $address, $account, $autocreate_account, $debug, $quiet, $address_rewriting_type, $routing_domain, $auth_method, $sysconfig_ref) = @_;
    my $sth, $query, $account_maia_users_id, $address_users_id, $address_maia_users_id;
    output("Linking address '$address' to account '$account'")
        if (!$quiet);
 
    $query = "SELECT id FROM maia_users WHERE user_name=?";
    $sth = $dbh->prepare($query) 
        or fatal(sprintf("Couldn't prepare query: %s", $dbh->errstr));
    $sth->execute($account)  
        or fatal(sprintf("Couldn't execute query: %s", $dbh->errstr));
    if (!(($account_maia_users_id) = $sth->fetchrow())) {
        if ($autocreate_account) {
          output("Creating account: $account") if (!$quiet);
          $account_maia_users_id = add_address($dbh, $account, $address_rewriting_type, $routing_domain, $auth_method,
                        $sysconfig_ref, $debug, $quiet);
        } else {
          fatal("Couldn't find account '$account' in the maia_users table!");
        }
    }
    $query ="SELECT id FROM users WHERE email=?";
    $sth = $dbh->prepare($query) 
        or fatal(sprintf("Couldn't prepare query: %s", $dbh->errstr));
    $sth->execute($address)  
        or fatal(sprintf("Couldn't execute query: %s", $dbh->errstr));
    if (!(($address_users_id) = $sth->fetchrow())) {
        # add a new policy for the address, based on the domain defaults
        $policy_id = add_policy($dbh, $address, $debug, $quiet);
        output ("Address '$address' not found, adding it first") 
            if (!$quiet);

        # add the address to the users table
        $address_users_id = add_address_to_user($dbh, $policy_id, $address, $account_maia_users_id, 0, $debug, $quiet);
       #  Done, no need to transfer any mail.
       return true; 
    }

    $query = "SELECT maia_user_id FROM users WHERE email=?";
    $sth = $dbh->prepare($query) 
        or fatal(sprintf("Couldn't prepare query: %s", $dbb->errstr));
    $sth->execute($address)  
        or fatal(sprintf("Couldn't execute query: %s", $dbh->errstr));
    if (!(( $address_maia_users_id ) = $sth->fetchrow())) {
        fatal("Couldn't find account $address in the maia_users table!");
    }

    # check that address is not already linked to this account
    $query = "SELECT maia_user_id FROM users WHERE id=?";
    $sth = $dbh->prepare($query)
        or fatal(sprintf("Couldn't prepare query: %s", $dbb->errstr));
    $sth->execute($address_users_id)
        or fatal(sprintf("Couldn't execute query: %s", $dbh->errstr));
    my $existing_maia_user_id;
    $existing_maia_users_id  = $sth->fetchrow();
    if ($existing_maia_users_id == $account_maia_users_id) {
        output("$address is already linked to $account") if (!$quiet);
        return true;
    }

    # check to see if this is already a linked address
    # assume that primary_email_id will be the same as users.id where email =  $account
    $query = "SELECT primary_email_id FROM maia_users WHERE id=?";
    $sth = $dbh->prepare($query);
    $sth->execute($existing_maia_users_id);
    $existing_primary_email_id = $sth->fetchrow();
    if ($existing_primary_email_id != $address_users_id) {
        $query = "SELECT email FROM users WHERE id=?";
        $sth = $dbh->prepare($query)
            or fatal(sprintf("Couldn't prepare query: %s", $dbb->errstr));
        $sth->execute($existing_primary_email_id)
            or fatal(sprintf("Couldn't execute query: %s", $dbh->errstr));
        my $linked_account = $sth->fetchrow();
        
        #this will be very easy in Maia 1.1, as recipient_id will match users.id instead of maia_users.id
        fatal("$address is already linked to $linked_account, relinking addressess is not (yet) supported");
    }

    # update users to link address to account
    $query = "UPDATE users SET maia_user_id=? WHERE id=?";
    $sth = $dbh->prepare($query) 
        or fatal(sprintf("Couldn't prepare query: %s", $dbh->errstr));
    $sth->execute($account_maia_users_id, $address_users_id)  
        or fatal(sprintf("Couldn't execute query: %s", $dbh->errstr));

    # move all linked mail from maia_mail_recipients
    $query = "UPDATE maia_mail_recipients SET recipient_id=? WHERE recipient_id=?";
    $sth = $dbh->prepare($query)
        or fatah(sprintf("Couldn' prepare query: %s", $dhb->errstr));
    $sth->execute($account_maia_users_id, $address_users_id)
        or fatal(sprintf("Couldn't execute query: %s", $dbh->errstr));

    # now remove orphan in maia_users
    $query = "DELETE FROM maia_users WHERE id=?";
    $sth = $dbh->prepare($query)       
        or fatal(sprintf("Couldn't prepare query: %s", $dbh->errstr));
    $sth->execute($address_maia_users_id)  
        or fatal(sprintf("Couldn't execute query: %s", $dbh->errstr));
}


# Delete one or more cached/quarantined emails referenced by IDs
sub delete_mail($$$$) {
    my($dbh, $mail_ids_ref, $debug, $quiet) = @_;
    my($sth, $query, @mail_ids);

    @mail_ids = ();
    if (ref($mail_ids_ref) eq "ARRAY") {
        @mail_ids = @$mail_ids_ref;
    } else {
        push(@mail_ids, $mail_ids_ref);  # scalar implies a single mail ID
    }

    # delete any references to recipients
    $query = "DELETE FROM maia_mail_recipients " .
             "WHERE mail_id IN (?" . 
             ",?" x (scalar(@mail_ids) - 1) . 
             ")";
    $sth = $dbh->prepare($query)
               or fatal(sprintf("Couldn't prepare query: %s", $dbh->errstr));
    $sth->execute(@mail_ids)
        or fatal(sprintf("Couldn't execute query: %s", $dbh->errstr));

    # delete any references to SpamAssassin rules
    $query = "DELETE FROM maia_sa_rules_triggered " .
             "WHERE mail_id IN (?" . 
             ",?" x (scalar(@mail_ids) - 1) . 
             ")";
    $sth = $dbh->prepare($query)
               or fatal(sprintf("Couldn't prepare query: %s", $dbh->errstr));
    $sth->execute(@mail_ids)
        or fatal(sprintf("Couldn't execute query: %s", $dbh->errstr));

    # delete any references to viruses
    $query = "DELETE FROM maia_viruses_detected " .
             "WHERE mail_id IN (?" . 
             ",?" x (scalar(@mail_ids) - 1) .
             ")";
    $sth = $dbh->prepare($query)
               or fatal(sprintf("Couldn't prepare query: %s", $dbh->errstr));
    $sth->execute(@mail_ids)
        or fatal(sprintf("Couldn't execute query: %s", $dbh->errstr));

    # delete any references to banned file attachments
    $query = "DELETE FROM maia_banned_attachments_found " .
             "WHERE mail_id IN (?" . 
             ",?" x (scalar(@mail_ids) - 1) .
             ")";
    $sth = $dbh->prepare($query)
               or fatal(sprintf("Couldn't prepare query: %s", $dbh->errstr));
    $sth->execute(@mail_ids)
        or fatal(sprintf("Couldn't execute query: %s", $dbh->errstr));

    # delete the mail item itself
    $query = "DELETE FROM maia_mail " .
             "WHERE id IN (?" .
             ",?" x (scalar(@mail_ids) - 1) .
             ")";
    $sth = $dbh->prepare($query)
               or fatal(sprintf("Couldn't prepare query: %s", $dbh->errstr));
    $sth->execute(@mail_ids)
        or fatal(sprintf("Couldn't execute query: %s", $dbh->errstr));

}


# Delete references to a specific set of mail items received by a 
# specific Maia user
sub delete_mail_references($$$$$) {
    my($dbh, $user_id, $mail_ids_ref, $debug, $quiet) = @_;
    my($sth, $query, @deletions, $maia_mail_id);

    $query = "DELETE FROM maia_mail_recipients " .
             "WHERE recipient_id = ? " .
             "AND mail_id IN (?" .
             ",?" x (scalar(@$mail_ids_ref) - 1) .
             ")";
    $sth = $dbh->prepare($query)
               or fatal(sprintf("Couldn't prepare query: %s", $dbh->errstr));
    $sth->execute($user_id, @$mail_ids_ref)
        or fatal(sprintf("Couldn't execute query: %s", $dbh->errstr));

    # delete any mail items without remaining recipient references
    $query = "SELECT maia_mail.id " .
             "FROM maia_mail, maia_mail_recipients " .
             "WHERE maia_mail.id = maia_mail_recipients.mail_id " .
             "AND maia_mail.id IN (?" . 
             ",?" x (scalar(@$mail_ids_ref) - 1) .
             ") " .
             "AND maia_mail_recipients.mail_id IS NULL";
    $sth = $dbh->prepare($query)
               or fatal(sprintf("Couldn't prepare query: %s", $dbh->errstr));
    $sth->execute(@$mail_ids_ref)
        or fatal(sprintf("Couldn't execute query: %s", $dbh->errstr));

    @deletions = ();
    while (($maia_mail_id) = $sth->fetchrow()) {
        push(@deletions, $maia_mail_id);
    }
    $sth->finish;
    if (@deletions) {
        delete_mail($dbh, \@deletions, $debug, $quiet);
    }
}


# Delete references to any mail items received by a specific Maia user
sub delete_user_mail_references($$$$) {
    my($dbh, $user_id, $debug, $quiet) = @_;
    my($sth, $query, $mail_id, @mail_ids);

    $query = "SELECT mail_id FROM maia_mail_recipients WHERE recipient_id = ?";
    $sth = $dbh->prepare($query)
               or fatal(sprintf("Couldn't prepare query: %s", $dbh->errstr));
    $sth->execute($user_id)
        or fatal(sprintf("Couldn't execute query: %s", $dbh->errstr));
    @mail_ids = ();
    while (($mail_id) = $sth->fetchrow()) {
        push(@mail_ids, $mail_id);
    }
    $sth->finish;
    if (@mail_ids) {
        delete_mail_references($dbh, $user_id, \@mail_ids, $debug, $quiet);
    }
}


# Delete a single sender-recipient whitelist or blacklist entry
sub delete_wb_entry($$$$$) {
    my($dbh, $user_id, $addr_id, $debug, $quiet) = @_;
    my($sth, $sth2, $query, $wb);

    $query = "DELETE FROM wblist WHERE rid = ? AND sid = ?";
    $sth = $dbh->prepare($query)
               or fatal(sprintf("Couldn't prepare query: %s", $dbh->errstr));
    $sth->execute($user_id, $addr_id)
        or fatal(sprintf("Couldn't execute query: %s", $dbh->errstr));

    # if there are no other references to this sender address,
    # remove it from the mailaddr table as well.
    $query = "SELECT wb FROM wblist WHERE sid = ?";
    $sth = $dbh->prepare($query)
               or fatal(sprintf("Couldn't prepare query: %s", $dbh->errstr));
    $sth->execute($addr_id)
        or fatal(sprintf("Couldn't execute query: %s", $dbh->errstr));
    if (!(($wb) = $sth->fetchrow())) {
        $query = "DELETE FROM mailaddr WHERE id = ?";
        $sth2 = $dbh->prepare($query)
                   or fatal(sprintf("Couldn't prepare query: %s", $dbh->errstr));
        $sth2->execute($addr_id)
            or fatal(sprintf("Couldn't execute query: %s", $dbh->errstr));
    }
    $sth->finish;
}


# Delete any whitelist/blacklist entries belonging to a specific Maia user
sub delete_user_wb_entries($$$$) {
    my($dbh, $user_id, $debug, $quiet) = @_;
    my($sth, $query, $sid);

    $query = "SELECT sid FROM wblist WHERE rid = ?";
    $sth = $dbh->prepare($query)
               or fatal(sprintf("Couldn't prepare query: %s", $dbh->errstr));
    $sth->execute($user_id)
        or fatal(sprintf("Couldn't execute query: %s", $dbh->errstr));
    while (($sid) = $sth->fetchrow()) {
        delete_wb_entry($dbh, $user_id, $sid, $debug, $quiet);
    }
    $sth->finish;
}



# Returns the domain portion of an e-mail address, including the '@'
sub address_domain($) {
    my($address) = @_;

    if ($address =~ /^.*(@.+)$/) {
        return $1;
    }
    return undef;
}


# Empty the Bayes database of all token records
sub clear_bayes($$$) {
    my($dbh, $debug, $quiet) = @_;
    my($sth, $query);

    output("Erasing the SpamAssassin Bayes database")
        if (!$quiet);

    output("Clearing the maia.bayes_token table")
        if ($debug);
    $query = "TRUNCATE TABLE bayes_token";
    $sth = $dbh->prepare($query)
               or fatal(sprintf("Couldn't prepare query: %s", $dbh->errstr));
    $sth->execute()
        or fatal(sprintf("Couldn't execute query: %s", $dbh->errstr));

    output("Clearing the maia.bayes_seen table")
        if ($debug);
    $query = "TRUNCATE TABLE bayes_seen";
    $sth = $dbh->prepare($query)
               or fatal(sprintf("Couldn't prepare query: %s", $dbh->errstr));
    $sth->execute()
        or fatal(sprintf("Couldn't execute query: %s", $dbh->errstr));

    output("Clearing the maia.bayes_vars table")
        if ($debug);
    $query = "TRUNCATE TABLE bayes_vars";
    $sth = $dbh->prepare($query)
               or fatal(sprintf("Couldn't prepare query: %s", $dbh->errstr));
    $sth->execute()
        or fatal(sprintf("Couldn't execute query: %s", $dbh->errstr));

    output("Clearing the maia.bayes_expire table")
        if ($debug);
    $query = "TRUNCATE TABLE bayes_expire";
    $sth = $dbh->prepare($query)
               or fatal(sprintf("Couldn't prepare query: %s", $dbh->errstr));
    $sth->execute()
        or fatal(sprintf("Couldn't execute query: %s", $dbh->errstr));

}


# Empty the AWL database of all sender address records
sub clear_awl($$$) {
    my($dbh, $debug, $quiet) = @_;
    my($sth, $query);

    output("Erasing the SpamAssassin Auto-Whitelist (AWL) database")
        if (!$quiet);

    output("Clearing the maia.awl table")
        if ($debug);
    $query = "TRUNCATE TABLE awl";
    $sth = $dbh->prepare($query)
               or fatal(sprintf("Couldn't prepare query: %s", $dbh->errstr));
    $sth->execute()
        or fatal(sprintf("Couldn't execute query: %s", $dbh->errstr));
}


# Expire obsolete and/or statistically insignificant tokens from the Bayes
# database.
sub expire_bayes($$$) {
    my($sa_learn, $debug, $quiet) = @_;

    output("Expiring tokens from the SpamAssassin Bayes database")
        if (!$quiet);
    output("Using $sa_learn")
        if ($debug);

    my $command = "$sa_learn " . ($debug ? "-D " : "") . "--sync --force-expire 2>&1";
    my $result = `$command`;
    if ($? == -1) {
    	fatal("Failed to execute $sa_learn: $!");
    }
    if (!$quiet) {
        my @lines = split(/\n/, $result);
        foreach $line (@lines) {
            output($line);
        }
    }
}


# Prune the AWL database by removing sender records that occur less than
# a certain number of times (default: 2), and are associated with positive
# scores.
sub prune_awl($$$$) {
    my($prune_awl, $dbh, $debug, $quiet) = @_;
    my($sth, $query);

    output("Pruning the SpamAssassin Auto-Whitelist (AWL) database")
        if (!$quiet);
    output("Positive-scoring senders that appear less than $prune_awl times in the AWL will be deleted")
        if ($debug);

    $query = "DELETE FROM awl WHERE count < ? AND totscore >= 0";
    $sth = $dbh->prepare($query)
               or fatal(sprintf("Couldn't prepare query: %s", $dbh->errstr));
    $sth->execute($prune_awl)
        or fatal(sprintf("Couldn't execute query: %s", $dbh->errstr));
}

sub link_address_from_ldif($$$$$$$$$$$) {

    my ($link_from_ldif, $account_attribute, $address_attribute, $autocreate_account, $dbh, $debug, $quiet, $address_rewriting_type, $routing_domain, $auth_method, $sysconfig_ref) = @_;
    use Net::LDAP::LDIF;

    $ldif = Net::LDAP::LDIF->new( $link_from_ldif, "r", onerror => 'undef' );
    while( not $ldif->eof ( ) ) {
      $entry = $ldif->read_entry ( );
      if ( $ldif->error ( ) ) {
        fatal("Error msg: " . $ldif->error ( ) . "\n" .
              "Error lines:\n" . $ldif->error_lines ( ) . "\n");
      } else {
        my $account = $entry->get_value($account_attribute);
        my @addresses = $entry->get_value($address_attribute);

        foreach my $address (@addresses) {
          next if ($address eq $account); #skip its own identity
          output("Linking address '$address' to account '$account'")
                if (!$quiet);
          link_address($dbh, $address, $account, $autocreate_account, $debug, $quiet,$address_rewriting_type, $routing_domain, $auth_method, $sysconfig_ref);
        }

      }
    }
    $ldif->done ( );
}

sub export_wblist_csv($$$$) {
    my ($dbh, $export_wblist, $debug, $quiet) = @_;
    my $sth;

    my $csv = Text::CSV->new ( { binary => 1 } )  # should set binary attribute.
        or die "Cannot use CSV: ".Text::CSV->error_diag ();
    $csv->eol ("\r\n");
    $query ="SELECT user_name, email, wb FROM wblist left join mailaddr on wblist.sid = mailaddr.id LEFT JOIN maia_users on maia_users.id=wblist.rid";

    $sth = $dbh->prepare($query)
        or fatal(sprintf("Couldn't prepare query: %s", $dbh->errstr));
    $sth->execute()
        or fatal(sprintf("Couldn't execute query: %s", $dbh->errstr));

    open $fh, ">:encoding(utf8)", $export_wblist or die "$export_wblist: $!";

    while (@row = $sth->fetchrow_array()) {
        $csv->print($fh, \@row) ;
    }
    $sth->finish;
    close $fh or die "new.csv: $!";
}


sub import_wblist_csv($$$$) {
    my ($dbh, $import_wblist, $debug, $quiet) = @_;
    my $fh, $username, $address, $wb;

    my $csv = Text::CSV->new ( { binary => 1 } )  # should set binary attribute.
         or die "Cannot use CSV: ".Text::CSV->error_diag ();

    open $fh, "<:encoding(utf8)", $import_wblist or die "new.csv: $!";
    $csv->bind_columns (\$username, \$address, \$wb);

    while ($csv->getline ($fh)) {
        # insert entry into database
        update_wblist($dbh, $username, $address, $wb, $debug, $quiet)
    }

    close $fh or die "new.csv: $!";
}

sub update_wblist($$$$$$) {
    my ($dbh, $username, $address, $wb, $debug, $quiet) = @_;

    $query ="SELECT id FROM maia_users WHERE user_name=?";

    $sth = $dbh->prepare($query)
        or fatal(sprintf("Couldn't prepare query: %s", $dbh->errstr));
    $sth->execute($username)
        or fatal(sprintf("Couldn't execute query: %s", $dbh->errstr));

    if (@row = $sth->fetchrow()) {
        $user_id = $row[0];

        $query ="SELECT id FROM mailaddr WHERE email=?";
        $sth1 = $dbh->prepare($query)
               or fatal(sprintf("Couldn't prepare query: %s", $dbh->errstr));
        $sth1->execute($address)
               or fatal(sprintf("Couldn't execute query: %s", $dbh->errstr));
        if (@address_id_row = $sth1->fetchrow()) {
            $address_id = $address_id_row[0];
        } else {
            $insert = "INSERT INTO mailaddr (email,priority) VALUES(?,?)";
            $sth2 = $dbh->prepare($insert)
                   or fatal(sprintf("Couldn't prepare query: %s", $dbh->errstr));
            $sth2->execute($address,get_email_address_priority($address))
                   or fatal(sprintf("Couldn't execute query: %s", $dbh->errstr));
            $address_id = $dbh->last_insert_id(undef, undef, "mailaddr", undef);
        }
        $sth1->finish;
        $status = get_wb_status($dbh, $user_id, $address_id);
        if ($status eq '') {
            add_wb_entry($dbh, $user_id, $address_id, $wb);
        } else {
            if ($wb_stat ne $wb) {
                set_wb_status($dbh, $user_id, $address_id, $wb);
            }
        }
    }
    $sth->finish;
}

sub get_wb_status($$$) {
    my ($dbh, $user_id, $addr_id) = @_;

    $wb = '';
    $select = "SELECT wb " .
             "FROM wblist " .
             "WHERE rid = ? " .
             "AND sid = ?";
    $sth = $dbh->prepare($select)
       or fatal(sprintf("Couldn't prepare query: %s", $dbh->errstr));
    $sth->execute($user_id, $addr_id)
       or fatal(sprintf("Couldn't execute query: %s", $dbh->errstr));

    if (@row = $sth->fetchrow()) {
      $wb = $row[0];
    }
    $sth->finish;
    return $wb;

}

sub add_wb_entry($$$$) {
    my ($dbh, $user_id, $addr_id, $wb) = @_;

    $insert = "INSERT INTO wblist (rid, sid, wb) VALUES (?, ?, ?)";
    $sth = $dbh->prepare($insert)
      or fatal(sprintf("Couldn't prepare query: %s", $dbh->errstr));
    $sth->execute( $user_id, $addr_id, $wb)
      or fatal(sprintf("Couldn't execute query: %s", $dbh->errstr));
    $sth->finish;
}

sub set_wb_status($$$$) {
    my ($dbh, $user_id, $addr_id, $wb) = @_;

    $update = "UPDATE wblist SET wb = ? WHERE rid = ? AND sid = ?";
    $sth = $dbh->prepare($update)
        or fatal(sprintf("Couldn't prepare query: %s", $dbh->errstr));
    $sth->execute($wb, $user_id, $addr_id)
        or fatal(sprintf("Couldn't execute query: %s", $dbh->errstr));
    $sth->finish;
}
