#!/usr/bin/perl -w

# $Id: $

########################################################################
# MAIA MAILGUARD LICENSE v.1.0
#
# Copyright 2004 by Robert LeBlanc <rjl@renaissoft.com>
#                   David Morton   <mortonda@dgrmm.net>
# All rights reserved.
#
# PREAMBLE
#
# This License is designed for users of Maia Mailguard
# ("the Software") who wish to support the Maia Mailguard project by
# leaving "Maia Mailguard" branding information in the HTML output
# of the pages generated by the Software, and providing links back
# to the Maia Mailguard home page.  Users who wish to remove this
# branding information should contact the copyright owner to obtain
# a Rebranding License.
#
# DEFINITION OF TERMS
#
# The "Software" refers to Maia Mailguard, including all of the
# associated PHP, Perl, and SQL scripts, documentation files, graphic
# icons and logo images.
#
# GRANT OF LICENSE
#
# Redistribution and use in source and binary forms, with or without
# modification, are permitted provided that the following conditions
# are met:
#
# 1. Redistributions of source code must retain the above copyright
#    notice, this list of conditions and the following disclaimer.
#
# 2. Redistributions in binary form must reproduce the above copyright
#    notice, this list of conditions and the following disclaimer in the
#    documentation and/or other materials provided with the distribution.
#
# 3. The end-user documentation included with the redistribution, if
#    any, must include the following acknowledgment:
#
#    "This product includes software developed by Robert LeBlanc
#    <rjl@renaissoft.com>."
#
#    Alternately, this acknowledgment may appear in the software itself,
#    if and wherever such third-party acknowledgments normally appear.
#
# 4. At least one of the following branding conventions must be used:
#
#    a. The Maia Mailguard logo appears in the page-top banner of
#       all HTML output pages in an unmodified form, and links
#       directly to the Maia Mailguard home page; or
#
#    b. The "Powered by Maia Mailguard" graphic appears in the HTML
#       output of all gateway pages that lead to this software,
#       linking directly to the Maia Mailguard home page; or
#
#    c. A separate Rebranding License is obtained from the copyright
#       owner, exempting the Licensee from 4(a) and 4(b), subject to
#       the additional conditions laid out in that license document.
#
# THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDER AND CONTRIBUTORS
# "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
# LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS
# FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE
# COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT,
# INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING,
# BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS
# OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
# ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR
# TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE
# USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
########################################################################

use Getopt::Long;
use DBI;
use Net::SMTP;

# prototypes
sub output($);
sub fatal($);
sub dedupe($);
sub read_users_file($$);
sub send_email($$$$$);
sub resend_mail($$$$$$);

# name of this script
my $script_name = "resend";

# read configuration file (/etc/maia/maia.conf)
my $config_file = "/etc/maia/maia.conf";
unless (my $rv = do $config_file) {
    fatal(sprintf("Couldn't parse %s: %s", $config_file, $@)) if $@;
    fatal(sprintf("Couldn't open %s", $config_file)) if (!defined($rv) || !$rv);
};

# defaults
my @users = ();
my $users_from_file = undef;
my $from_date = undef;
my $to_date = undef;
my $from_id = undef;
my $to_id = undef;
my $debug = 0;
my $help = 0;
my $delay = 0;
my $sysconfig_ref = {};

GetOptions("users=s" => \@users,
           "users-from-file=s" => \$users_from_file,
           "from-date=s" => \$from_date,
           "to-date=s" => \$to_date,
           "from-id=i" => \$from_id,
           "to-id=i" => \$to_id,
           "delay=i" => \$delay,
           "debug" => \$debug,
           "help" => \$help);

@users = split(/,/, join(',', @users));

if ($help) {
    output("resend.pl\n" .
           "   --users addr1,addr2,...  : resend mail for selected users\n" .
           "   --users-from-file file   : same as --users, but reads user list from a file\n" .
           "   --users all              : same as --users, except for all users\n" .
           "   --from-date yyyy-mm-dd   : oldest mail to resend (default: oldest in cache)\n" .
           "   --to-date yyyy-mm-dd     : newest mail to resend (default: newest in cache)\n" .
           "   --from-id id             : lowest mail ID to resend\n" .
           "   --to-id id               : highest mail ID to resend\n" .
           "   --delay seconds          : seconds to delay between emails (default: 0)\n" .
           "   --debug                  : display detailed debugging information\n" .
           "   --help                   : display this help text\n");
    exit;
}

# database configuration
if (defined($dsn) && defined($username) && defined($password)) {
	
    # connect to the database
    $dbh = DBI->connect($dsn, $username, $password)
        or fatal("Can't connect to the Maia database (verify \$dsn, \$username, and \$password in maia.conf)");

    # do a one-time load of some system configuration parameters
    my $query = "SELECT smtp_server, smtp_port FROM maia_config WHERE id = 0";
	my $sth = $dbh->prepare($query)
	              or fatal(sprintf("Couldn't prepare query: %s", $dbh->errstr));
	$sth->execute()
	    or fatal(sprintf("Couldn't execute query: %s", $dbh->errstr));
	if (my @row = $sth->fetchrow_array()) {
	    $sysconfig_ref->{'smtp_server'} = $1 if $row[0] =~ /^(.+)$/si; # untaint
	    $sysconfig_ref->{'smtp_port'} = $1 if $row[1] =~ /^([1-9]+[0-9]*)$/si; # untaint
	};
	$sth->finish;

} else {
    fatal("Can't connect to the Maia database (missing \$dsn, \$username, or \$password in maia.conf)");
}


# Read the (optional) input files for user addresses
read_users_file(\@users, $users_from_file)
    if (defined($users_from_file));

# Remove any duplicates
dedupe(\@users);

# Sanity-check user-supplied arguments
if (!@users) {
    fatal("No users specified.");
}
if (defined($from_date)) {
    if ($from_date =~ /^(\d{4})[\-\/:](\d{2})[\-\/:](\d{2})$/) {
        my $year = $1;
        my $month = $2;
        my $day = $3;
        my $yearnow = (localtime)[5] + 1900;
        if ($year < 1900 || $year > $yearnow || $month < 1 || $month > 12 || $day < 1 || $day > 31) {
            fatal("'From' date parameters out of range, use YYYY-MM-DD.");
        }
    } else {
        fatal("Invalid 'From' date, use YYYY-MM-DD.");
    }
}
if (defined($to_date)) {
    if ($to_date =~ /^(\d{4})[\-\/:](\d{2})[\-\/:](\d{2})$/) {
        my $year = $1;
        my $month = $2;
        my $day = $3;
        my $yearnow = (localtime)[5] + 1900;
        if ($year < 1900 || $year > $yearnow || $month < 1 || $month > 12 || $day < 1 || $day > 31) {
            fatal("'To' date parameters out of range, use YYYY-MM-DD.");
        }
    } else {
        fatal("Invalid 'To' date, use YYYY-MM-DD.");
    }
}
if (defined($from_id)) {
    if ($from_id < 1) {
        fatal("Invalid mail ID, must be a positive integer.");
    }
}
if (defined($to_id)) {
    if ($to_id < 1) {
        fatal("Invalid mail ID, must be a positive integer.");
    }
}


# Resend cached email
foreach my $user (@users) {
    resend_mail($dbh, $user, $from_date, $to_date, $from_id, $to_id);
}

# Disconnect from the database
$dbh->disconnect;

exit;

########################################################################
###              End of Script: Subroutines begin below              ###
########################################################################

# Die, printing a time-stamped error message.
sub fatal($) {
    my ($msg) = @_;

    output("FATAL ERROR: " . $msg);
    exit 1;
}


# Write a time-stamped string to stdout for logging purposes.
sub output($) {
    my ($msg) = @_;
    my ($second, $minute, $hour, $day, $month, $year) = (localtime)[0,1,2,3,4,5];

    printf("%04d-%02d-%02d %02d:%02d:%02d Maia: [%s] %s\n",
           $year+1900, $month+1, $day, $hour, $minute, $second, $script_name, $msg);
}


# Remove any duplicate array elements
sub dedupe($) {
    my($array_ref) = @_;

    my %seen = ();
    foreach my $element (@$array_ref) {
        $seen{$element}++;
    }
    @$array_ref = keys %seen;
}


# Sends an e-mail via the downstream MTA
sub send_email($$$$$) {
    my ($smtp_server, $smtp_port, $from, $to, $body) = @_;

    my($smtp) = Net::SMTP->new($smtp_server, Port => $smtp_port) ;
    fatal("Couldn't connect to SMTP server: $!") unless $smtp;
    $smtp->mail($from) ;
    $smtp->to($to) ;
    $smtp->data() ;
    $smtp->datasend($body . "\n") ;
    $smtp->dataend() ;
    $smtp->quit() ;
}


# Parse an input file for lines containing e-mail addresses.  Blank lines
# and whitespace should be ignored.
sub read_users_file($$) {
    my($addresses_ref, $infile) = @_;

    open (INFILE, "< $infile")
        or fatal("Can't read input file $infile: $!");
    while (<INFILE>) {
        chomp;
        if ($_ =~ /^\s*(.+@.+)\s*$/) {
            push(@$addresses_ref, $1);
        } elsif ($_ =~ /^all$/i) {
            push(@$addresses_ref, '*');
        } else {
	        # skip blank lines
        }
    }
    close INFILE;
}


sub resend_mail($$$$$$) {
    my($dbh, $user, $from_date, $to_date, $from_id, $to_id) = @_;
    my $user_clause = '';
    my $from_clause = '';
    my $to_clause = '';
    my $fromid_clause = '';
    my $toid_clause = '';
    my @params = ();

    if ($user ne '*') {
        $user_clause = " AND users.email = ?";
        push @params, $user;
        output("Resending cached emails for $user") if ($debug);
    } else {
        output("Resending cached emails for all users") if ($debug);
    }

    if (defined($from_date)) {
        $from_date .= ' 00:00:00';
        $from_clause = " AND maia_mail.received_date >= ?";
        push @params, $from_date;
        output("Items received no earlier than $from_date") if ($debug);
    }

    if (defined($to_date)) {
        $to_date .= ' 23:59:59';
        $to_clause = " AND maia_mail.received_date <= ?";
        push @params, $to_date;
        output("Items received no later than $to_date") if ($debug);
    } 

    if (defined($from_id)) {
        $fromid_clause = " AND maia_mail.id >= ?";
        push @params, $from_id;
        output("Item ID no lower than $from_id") if ($debug);
    }

    if (defined($to_id)) {
        $toid_clause = " AND maia_mail.id <= ?";
        push @params, $to_id;
        output("Item ID no higher than $to_id") if ($debug);
    }

    if ($delay && $debug) {
        output("Pausing for $delay seconds between mailings");
    }

    my $query = <<EOQ;
SELECT maia_mail.id, email, sender_email, received_date, contents 
FROM maia_mail, maia_mail_recipients, maia_users, users 
WHERE maia_mail.id = maia_mail_recipients.mail_id 
AND maia_mail_recipients.recipient_id = maia_users.id 
AND maia_users.primary_email_id = users.id 
AND maia_mail_recipients.type = 'H'
EOQ

    $query .= $user_clause . $from_clause . $to_clause . $fromid_clause . $toid_clause;
    $query .= " ORDER BY received_date ASC";

    my $sth = $dbh->prepare($query)
        or fatal(sprintf("Couldn't prepare query: %s", $dbh->errstr));

    $sth->execute(@params)
        or fatal(sprintf("Couldn't execute query: %s", $dbh->errstr));

    my $resent_count = 0;
    while (my @row = $sth->fetchrow()) {
        my $mail_id = $row[0];
        my $mail_recipient = $row[1];
        my $mail_sender = $row[2];
        my $mail_date = $row[3];
        my $mail_contents = $row[4];

        if ($debug) {
            output("Mail ID $mail_id: Received $mail_date : From $mail_sender : To $mail_recipient");
        }

        send_email($sysconfig_ref->{'smtp_server'}, 
                   $sysconfig_ref->{'smtp_port'}, 
                   $mail_sender,
                   $mail_recipient,
                   $mail_contents);

        $resent_count++;

        if ($delay) {
            sleep($delay);
        }
    }
    $sth->finish;

    output("$resent_count emails redelivered.");

}

