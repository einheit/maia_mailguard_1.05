#!/usr/bin/perl

# $Id$

########################################################################
# MAIA MAILGUARD LICENSE v.1.0
#
# Copyright 2005 by Robert LeBlanc <rjl@renaissoft.com>
#                and David Morton  <mortonda@dgrmm.net>
# All rights reserved.
#
# PREAMBLE
#
# This License is designed for users of Maia Mailguard
# ("the Software") who wish to support the Maia Mailguard project by
# leaving "Maia Mailguard" branding information in the HTML output
# of the pages generated by the Software, and providing links back
# to the Maia Mailguard home page.  Users who wish to remove this
# branding information should contact the copyright owner to obtain
# a Rebranding License.
#
# DEFINITION OF TERMS
#
# The "Software" refers to Maia Mailguard, including all of the
# associated PHP, Perl, and SQL scripts, documentation files, graphic
# icons and logo images.
#
# GRANT OF LICENSE
#
# Redistribution and use in source and binary forms, with or without
# modification, are permitted provided that the following conditions
# are met:
#
# 1. Redistributions of source code must retain the above copyright
#    notice, this list of conditions and the following disclaimer.
#
# 2. Redistributions in binary form must reproduce the above copyright
#    notice, this list of conditions and the following disclaimer in the
#    documentation and/or other materials provided with the distribution.
#
# 3. The end-user documentation included with the redistribution, if
#    any, must include the following acknowledgment:
#
#    "This product includes software developed by Robert LeBlanc
#    <rjl@renaissoft.com>."
#
#    Alternately, this acknowledgment may appear in the software itself,
#    if and wherever such third-party acknowledgments normally appear.
#
# 4. At least one of the following branding conventions must be used:
#
#    a. The Maia Mailguard logo appears in the page-top banner of
#       all HTML output pages in an unmodified form, and links
#       directly to the Maia Mailguard home page; or
#
#    b. The "Powered by Maia Mailguard" graphic appears in the HTML
#       output of all gateway pages that lead to this software,
#       linking directly to the Maia Mailguard home page; or
#
#    c. A separate Rebranding License is obtained from the copyright
#       owner, exempting the Licensee from 4(a) and 4(b), subject to
#       the additional conditions laid out in that license document.
#
# THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDER AND CONTRIBUTORS
# "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
# LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS
# FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE
# COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT,
# INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING,
# BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS
# OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
# ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR
# TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE
# USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
########################################################################

use DBI;
use POSIX;
use Net::SMTP;
use Template;
use Data::UUID;

# prototypes
sub fatal($);
sub output($);
sub get_config_value($$);
sub phrase_generate();
sub generate_confirm_token($$);

# name of this script
my $script_name = "send-quarantine-digests";

# read configuration file (/etc/maia/maia.conf)
my $config_file = "/etc/maia/maia.conf";
unless (my $rv = do $config_file) {
    fatal(sprintf("Couldn't parse %s: %s", $config_file, $@)) if $@;
    fatal(sprintf("Couldn't open %s", $config_file)) if (!defined($rv) || !$rv);
};

$pid_dir = "/var/run/maia" if !defined($pid_dir);

$pid_file = "$pid_dir/.send-quarantine-digests.pid";

# Check for existing lock file, remove any stale locks
if (open(PID_FILE, "< $pid_file\0")) {
    my $pid;
    while (<PID_FILE>) { chomp; $pid = $_ if /^\d+\z/ }
    close(PID_FILE) or fatal(sprintf("Can't close file %s: %s", $pid_file, $!));
    if (!defined($pid)) {
        if ($debug) {
            output("Removing invalid lock file...");
        }
        unlink($pid_file);
    } elsif (kill 0 => $pid) {
        if (!$quiet) {
            output(sprintf("Another instance [%d] is currently running.", $pid));
        }
        exit;
    } else {
        if ($debug) {
            output(sprintf("Removing stale lock file [%d]...", $pid));
        }
        unlink($pid_file);
    }
}

# Write lock file, store PID
open(PID_FILE, "> $pid_file\0") or fatal(sprintf("Can't write lock file %s", $pid_file));
print PID_FILE "$$";
close(PID_FILE);


# defaults (overridden by settings in /etc/maia/maia.conf)
$base_url = "http://example.com/" if !defined($base_url);
$template_dir = "/var/lib/maia/templates" if !defined($template_dir);

fatal("Can't read template file: $!") if !(-r "$template_dir/digest.tpl");
%sort = (
            'ham'   => "score DESC",  # puts the high scores at the top
            'spam'  => "score ASC",   # puts the low scroes at the top
            'virus' => "received_date DESC",
            'attachment' => "received_date DESC",
            'header'  => "received_date DESC",
) if !(%sort);
$titles = { 'spam'        =>  "Spam Quarantine",
            'virus'       =>  "Virus Quarantine",
            'attachment' =>  "Banned File Attachments",
            'header'  =>  "Invalid Email Headers",
            'ham'         =>  "Delivered Email"
} if !defined($titles);
@report_order = ('spam','ham','virus','attachment','header') if !(@report_order);

my $dbh;

# database configuration
if (defined($dsn) && defined($username) && defined($password)) {
    $dbh = DBI->connect($dsn, $username, $password)
        or fatal("Can't connect to the Maia database (verify \$dsn, \$username, and \$password in maia.conf)");
} else {
    fatal("Can't connect to the Maia database (missing \$dsn, \$username, or \$password in maia.conf)");
}

my $dbType = get_db_type($dbh);

my($query, $sth, @row, %config_value_cache);
my($admin_email, $smtp_server, $smtp_port);

$query = <<"endSQL;";
  SELECT admin_email, smtp_server, smtp_port
  FROM   maia_config
  WHERE  id = 0
endSQL;

$sth = $dbh->prepare($query)
    or fatal(sprintf("Couldn't prepare query: %s", $dbh->errstr));
$sth->execute()
    or fatal(sprintf("Couldn't execute query: %s", $dbh->errstr));

if (@row = $sth->fetchrow_array()) {
    $admin_email = $1 if $row[0] =~ /^(.+@.+\..+)$/si;  # untaint
    $smtp_server = $1 if $row[1] =~ /^(.+)$/si;         # untaint
    $smtp_port = $1 if $row[2] =~ /^([1-9]+[0-9]*)$/si; # untaint
}
$sth->finish();

my $bgcolor;
my $token; 
my $received_date; 
my $score; 
my $sender; 
my $subject; 
my $mail_id;
my $timestamp = time();
my ($secs, $mins, $hours, $day, $mon, $year) = localtime($timestamp);
my $dbtimestamp = sprintf("%04d-%02d-%02d %02d:%02d:%02d", $year+1900, $mon+1, $day, $hours, $mins, $secs);

my $unixTime = $dbType eq 'pg' ? "( ROUND(DATE_PART('epoch', NOW())) - ROUND(DATE_PART('epoch', maia_users.last_digest_sent)))"
                     : "(UNIX_TIMESTAMP() - UNIX_TIMESTAMP(maia_users.last_digest_sent))";

$query = <<"endSQL;";
  SELECT   maia_users.id, users.email
  FROM     maia_users, users
  WHERE    maia_users.primary_email_id = users.id
           AND maia_users.quarantine_digest_interval > 0
           AND (maia_users.quarantine_digest_interval <= ($unixTime / 60)
                OR maia_users.last_digest_sent IS NULL)
  ORDER BY maia_users.id ASC
endSQL;

my $users_sth = $dbh->prepare($query)
    or fatal(sprintf("Couldn't prepare query: %s", $dbh->errstr));
$users_sth->execute()
    or fatal(sprintf("Couldn't execute query: %s", $dbh->errstr));

$query = <<"endSQL;";
SELECT email, domain, maia_users.id
FROM maia_domains 
  JOIN maia_domain_admins ON maia_domains.id=maia_domain_admins.domain_id 
  JOIN maia_users on maia_users.id=maia_domain_admins.admin_id 
  JOIN users ON maia_users.primary_email_id=users.id
WHERE domain=?
endSQL;

my $domain_admin_sth = $dbh->prepare($query)
  or fatal(sprintf("Couldn't prepare query: %s", $dbh->errstr));

# Preparing the same statement over & over is wasteful. Granted,
# performance doesn't really matter in this application, but there is no
# sense in wasting db resources (which COULD be at a premium).

my %report_statements;
while (my($element, $sort) = each(%sort)) {
    next if exists $report_statements{$sort};
    my %report_type_lookup = (
           'ham'         => 'H',
           'spam'        => 'S',
           'virus'       => 'V',
           'attachment' => 'F',
           'header'  => 'B',
    );

    $query = <<"endSQL;";
  SELECT   mmr.token, mm.received_date, mm.score,
           mm.sender_email, mm.subject, mm.id as mail_id
  FROM     maia_mail AS mm, maia_mail_recipients AS mmr
  WHERE    mm.id = mmr.mail_id 
endSQL;
    $query .= $element eq 'spam' ? "AND mmr.type IN ('S','P') " : "AND mmr.type = '$report_type_lookup{$element}' ";
$query .= <<"endSQL;";
           AND mmr.recipient_id = ?
  ORDER BY mm.$sort
endSQL;

    $report_statements{$sort} = $dbh->prepare($query)
  or fatal(sprintf("Couldn't prepare query: %s", $dbh->errstr));
}

$query = <<"endSQL;";
  UPDATE maia_users SET last_digest_sent = ? WHERE id = ?
endSQL;
my $update_sth = $dbh->prepare($query)
    or fatal(sprintf("Couldn't prepare query: %s", $dbh->errstr));

# postgres has a strange calulation to avoid having to tack on "days" to the execute value...
my $date_add = $dbType eq 'pg' ? "TO_TIMESTAMP(EXTRACT(EPOCH FROM TIMESTAMP 'NOW()') + (? * 86400))"
         : "DATE_ADD(NOW(), INTERVAL ? DAY)";
$query = <<"endSQL;";
  INSERT INTO maia_tokens (token_system, token, data, expires)
  VALUES ('digest', ?, ?, $date_add)
endSQL;

my $confirm_sth = $dbh->prepare($query);

while (my @row3 = $users_sth->fetchrow_array()) {
    my $user_id = $1 if $row3[0] =~ /^(\d+)$/si; # untaint
    my $user_email = $1 if $row3[1] =~ /^(.*@.+\..+)$/si; # untaint

    #regenerate template vars for every user, to minimize memory usage
    my %vars = (
                'admin_email'     => $admin_email,
                'date'            => $dbtimestamp,
                'maia_user_id'    => $user_id,
                'euid'            => $user_id,
                'recipient'       => $user_email,
                'titles'          => $titles,
                'baseurl'         => $base_url,
                'report_types'    => ""
               );

    # We need to use an array to Separate Report Elements, since hashes can't keep reliable ordering
    my $report_count = 0;
    my $at_least_one = 0;
    for my $report_element (@report_order) {
        $sth = $report_statements{$sort{$report_element}};
        
        $sth->execute($user_id)
                  or fatal(sprintf("Couldn't execute query: %s", $dbh->errstr));
        if ($sth->rows > 0) {
            $at_least_one = 1;
            my $rowcount = 0;
            $vars{'report_types'} .= '&' . "report_" . $report_element . "=true";
            while (@row = $sth->fetchrow_array()) {
                $token = $received_date = $score = $sender = $subject = $mail_id = "";
                $token = $1 if $row[0] =~  /^([a-zA-Z0-9]+)$/si; # untaint
                $received_date = $1 if $row[1] =~ /^(\d{4}-\d{2}-\d{2} \d{2}:\d{2}:\d{2})(\.\d*)*$/si; # untaint
                $score = $1 if $row[2] =~ /^(-?\d+\.\d+)$/si; # untaint
                $sender = $1 if $row[3] =~ /^(.+\@.+\..+)$/si; # untaint
                $subject = $1 if $row[4] =~ /^(.*)$/si; # untaint
                $mail_id = $1 if $row[5] =~ /^(\d+)$/s; #untaint
                
                if ($received_date eq "") { 
                    $received_date = "(no received_date)"; 
         	      } 
         	      if ($score eq "") { 
         	          $score = "(no score)"; 
         	      } 
         	      if ($sender eq "") { 
         	          $sender = "(no sender)"; 
         	      } 
         	      if ($subject eq "") { 
         	          $subject = "(no subject)"; 
         	      } 

                $vars{'list'}[$report_count]{$report_element}[$rowcount]{'token'} =  $token;
                $vars{'list'}[$report_count]{$report_element}[$rowcount]{'received_date'} =  $received_date;
                if ($report_element eq 'ham' || $report_element eq 'spam') {
                    $vars{'list'}[$report_count]{$report_element}[$rowcount]{'score'} =  $score;
                }

                $vars{'list'}[$report_count]{$report_element}[$rowcount]{'sender'} =  $sender;
                $vars{'list'}[$report_count]{$report_element}[$rowcount]{'subject'} =  $subject;
                $vars{'list'}[$report_count]{$report_element}[$rowcount]{'mail_id'} =  $mail_id;

                $rowcount++;
            }
            $report_count++
        }
        $sth->finish();
    }

    # Send out the e-mail
    if ($at_least_one) {
        my($smtp) = Net::SMTP->new($smtp_server, Port => $smtp_port);
        fatal("Couldn't connect to SMTP server") unless $smtp;

        my $output = '';
        my $template = Template->new({INCLUDE_PATH => $template_dir,
                    OUTPUT => \$output });

        if ($user_email =~ /^@/) { #domain address, mail to admins instead
            $domain_admin_sth->execute($user_email)
              or fatal(sprintf("Couldn't execute query: %s", $dbh->errstr));
            while (my @admin_row = $domain_admin_sth->fetchrow_array()) {
                 my $admin = $1 if $admin_row[0] =~ /^(.+@.+\..+)$/si; # untaint
                 my $uid = $1 if $admin_row[2]  =~ /^(\d+)$/s; #untaint
                 output("uid: $uid $admin_row[2]");
                 $vars{'maia_user_id'} = $uid;
                 $vars{'confirm_token'} = generate_confirm_token($dbh, $uid);
                 $vars{'recipient'} = "Domain Account <$vars{'recipient'}>";
                 $template->process("digest.tpl", \%vars)
                     || fatal(sprintf("Template process failed: %s", $template->error()));
                 send_message($smtp, $admin, $user_email, $admin_email, $output);
            }
        } else {
            $vars{'confirm_token'} = generate_confirm_token($dbh, $user_id);
            $template->process("digest.tpl", \%vars)
                || fatal(sprintf("Template process failed: %s", $template->error()));

            send_message($smtp, $user_email, $user_email, $admin_email, $output);
        }

        $smtp->quit();
        $update_sth->execute($dbtimestamp, $user_id)
            or fatal(sprintf("Couldn't execute query: %s", $dbh->errstr));
        $update_sth->finish();

    }
}

# not strictly necessary, since we're about to disconnect, but good
# policy on the whole.
$users_sth->finish();

# Disconnect from the database
$dbh->disconnect;

unlink($pid_file);

# We're done.
exit;

sub send_message($$$$$) {
    my ($smtp, $recip, $user_email, $admin_email, $output) = @_;

    if ($recip ne $user_email) {
     output(sprintf("Sending quarantine digest for domain <%s> to <%s>", $user_email, $recip));
    } else {
     output(sprintf("Sending quarantine digest to <%s>", $recip));
    }
    $smtp->mail($admin_email);
    $smtp->to($recip);
    $smtp->data();
    $smtp->datasend($output);
    $smtp->dataend();
}

# Die, printing a time-stamped error message.
sub fatal($) {
    my ($msg) = @_;

    output("FATAL ERROR: " . $msg);
    unlink($pid_file);
    exit 1;
}


# Write a time-stamped string to stdout for logging purposes.
sub output($) {
    my ($msg) = @_;
    my ($year, $month, $day, $hour, $minute, $second);
    my ($second, $minute, $hour, $day, $month, $year) = (localtime)[0,1,2,3,4,5];

    printf("%04d-%02d-%02d %02d:%02d:%02d Maia: [%s] %s\n",
           $year+1900, $month+1, $day, $hour, $minute, $second, $script_name, $msg);
}


# Read a single value from Maia's configuration table.
sub get_config_value($$) {
    my($dbh, $key) = @_;
    my($sth, @row, $select);
    my $value = undef;

    return $config_value_cache{$key} if (exists $config_value_cache{$key});

    $select = "SELECT " . $key . " FROM maia_config WHERE id = 0";
    $select = $1 if $select =~ /^(.*)$/si; # untaint
    $sth = $dbh->prepare($select)
        or fatal(sprintf("Couldn't prepare query: %s", $dbh->errstr));
    $sth->execute()
        or fatal(sprintf("Couldn't execute query: %s", $dbh->errstr));
    if (@row = $sth->fetchrow_array()) {
        $value = $row[0];
    }
    $sth->finish;
    $config_value_cache{$key} = $value;
    return $value;
}


# random phrase generated from password generator
# credit: http://web.uconn.edu/~cdavid/cgi-bin/book/make_password_html.pl
sub phrase_generate() {
    my $ug    = new Data::UUID;
    my $uuid = $ug->create_hex();
    $uuid =~ s/0x(.*)/$1/;

    my (@passset,$rnd_passwd,$randum_num);
    @passset = ('A'..'Z','0'..'9');
    $rnd_passwd = "";
    for (my $i = 0; $i<32;$i++) {
        $randum_num = int(rand($#passset+1));
        $rnd_passwd .= $passset[$randum_num];
    }

    return $uuid . $rnd_passwd ;
}

# generate the random confirmation token
sub generate_confirm_token($$) {
    my ($dbh, $maia_user_id) = @_;
    my $spamexpiry = get_config_value($dbh, "expiry_period");
    my $hamexpiry = get_config_value($dbh, "ham_cache_expiry_period");
    my $days = $spamexpiry > $hamexpiry ? $spamexpiry : $hamexpiry;

    my $unique_string = phrase_generate();

    $confirm_sth->execute($unique_string, $maia_user_id,$days) 
        or fatal(sprintf("Couldn't execute query: %s", $dbh->errstr));
    $confirm_sth->finish();
    return $unique_string;
}

# Determine the database type: "mysql" or "pg"
# lowercasing it due to a report of a "Pg" being returned... the rest of the code expects lc
sub get_db_type($) {
   my($dbh) = @_;

   return lc($dbh->{Driver}->{Name});
}
